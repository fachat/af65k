<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="" />

<meta name="description" content="65002 documentation" />
<meta name="keywords" content="8-bit,6502,65002" />
<link rev="made" href="mailto:" />
<link rel="stylesheet" title="Default" type="text/css" href="doc.css" /><link rel="stylesheet" type="text/css" href="optable.css" />
<title>65002 Opcode Prefixes</title></head>
<body><div id="headerbox"><div id="lefthdr">The 65k Project</div><div id="righthdr"><div class="large">65002</div><div class="small">The 65k processor - a modern 6502 with 64 bit</div></div></div><div id="mainbox"><a name="top" id="top"></a><div id="leftcol"><div id="menu" class="top"><div class="tophead">navigate</div>
<div id="mtree">
<ul>
<li><a href="af65002front.html">Overview</a></li>
<li><a href="af65002regs.html">Register Set</a></li>
<li><a href="af65002opstruct.html">Opcodes Structure </a></li>
<li><a href="af65002admodes.html">Addressing Modes </a></li>
<li><a href="af65002prefixes.html">Prefixes</a></li>
<li><a href="af65002opcodes.html">Opcode Overview</a></li>
<li><a href="af65002opdesc.html">Opcode Docs</a></li>
<li><a href="af65002int.html">Reset, Traps and Interrupts</a></li>
<li><a href="af65002hyper.html">User/Hypervisor Mode</a></li>
<li><a href="af65002config.html">Configuration Registers</a></li>
<li><a href="af65002compat.html">Compatibility</a></li>
</ul>
</div>
		</div></div><div id="rightcol"><div class="top" id="twitter"><div class="tophead">follow</div><div>
		            Follow the 65k tweets on<br /><a class="extlink" target="_blank" href="https://twitter.com/#!/search/realtime/afachat%20%2365k">Twitter</a><br /> (In new window)
		</div></div><div class="top" id="forum"><div class="tophead">discuss</div><div><p>Discuss my site on <a class="extlink" target="_blank" href="http://forum.6502.org/viewtopic.php?t=956">this 6502.org forum thread</a></p><p>(Forum registration required to post)</p></div></div></div><div id="midcol"><div class="top" id="ie6warn">
You are using an old MS Internet Explorer as browser. This version is not supported anymore. Please use a 
more modern browser, like Internet Explorer 8 or later, 
<a target="_blank" class="extlink" href="http://www.firefox.com">Firefox</a>,
<a target="_blank" class="extlink" href="http://www.google.com/chrome">Google Chrome</a>, or
<a target="_blank" class="extlink" href="http://www.opera.com">Opera</a>.
</div><div class="top" id="content"><div id="minmax"></div><h1>65002 Opcode Prefixes</h1><div class="overview">
	<p>
	This page describes the opcode structure for the 65k line of processors.
	</p>
  </div><div id="toc" class="h2"><div class="h2h"><div class="h2t"> </div><h2>Table of content</h2><div class="toplink"><a href="#top">Top</a></div></div><div class="h2c"><ul><li><a href="#ovpref">Prefix Overview</a></li><li><a href="#prefam">Addressing Mode</a></li><li><a href="#prefof">Offset prefix</a></li><li><a href="#prefrs">Register Size prefix</a></li><li><a href="#prefle">Load Extensions prefix</a></li><li><a href="#prefum">User Mode selector</a></li><li><a href="#prefnf">No Flags prefix</a></li></ul></div></div><div class="h2"><div class="h2h"><div class="h2t"> </div><h2><a name="ovpref" id="ovpref">Prefix Overview</a></h2><div class="toplink"><a href="#top">Top</a></div></div><div class="h2c"><p>
        In the opcode map there are 32 codes designated as "prefix1" and 16 codes designated as "prefix2". These opcodes are no operations in themselves, but
        modify the following operation. The prefix has these values:</p>
<table class="bittable">
<tr><th colspan="8">prefix1</th></tr>
<tr><th>bit 7</th><th>bit 6</th><th>bit 5</th><th>bit 4</th><th>bit 3</th><th>bit 2</th><th>bit 1</th><th>bit 0</th></tr>
<tr><th>128</th><th>64</th><th>32</th><th>16</th><th>8</th><th>4</th><th>2</th><th>1</th></tr>
<tr><td>OF1</td><td>OF0</td><td>RS1</td><td>RS0</td><td>0</td><td>AM</td><td>1</td><td>1</td></tr>
</table><p>
        I.e. in prefix1 the lowest two bits are always one and bit 2 (value 4) is always zero, but all of the other five
        bits have a special meaning.</p>
<table class="bittable">
<tr><th colspan="8">prefix2</th></tr>
<tr><th>bit 7</th><th>bit 6</th><th>bit 5</th><th>bit 4</th><th>bit 3</th><th>bit 2</th><th>bit 1</th><th>bit 0</th></tr>
<tr><th>128</th><th>64</th><th>32</th><th>16</th><th>8</th><th>4</th><th>2</th><th>1</th></tr>
<tr><td>UM</td><td>LE1</td><td>LE0</td><td>NF</td><td>1</td><td>0</td><td>1</td><td>1</td></tr>
</table><p>
        For prefix2 the low four bit are fixed, the other bits are used as prefix.
</p>
<p>
        The following table explains the prefix bits.
</p>
<table class="optable">
<tr><th>AM</th><th>Adressing Modes</th></tr>
<tr><td>0</td><td>normal addressing modes (8 / 16 bit)</td></tr>
<tr><td>1</td><td>extended addressing modes (32 / 64 bit)</td></tr>
<tr><th>LE</th><th>Load extension</th></tr>
<tr><td>0/0</td><td>Do not extend values to full register width when loading a value with RS width; operations use RS width - default for all AC-related operations.</td></tr>
<tr><td>0/1</td><td>Sign-extend values to full register width when loading a value with RS width; operations use full width</td></tr>
<tr><td>1/0</td><td>Zero-extend values to full register width when loading a value with RS width; operations use full width - default for XR/YR-related operations.</td></tr>
<tr><td>1/1</td><td>One-extend values to full register width when loading a value with RS width; operations use full width</td></tr>
<tr><th>RS1/RS0</th><th>Register Size</th></tr>
<tr><td>0/0</td><td>8 bit register</td></tr>
<tr><td>0/1</td><td>16 bit register</td></tr>
<tr><td>1/0</td><td>32 bit register</td></tr>
<tr><td>1/1</td><td>64 bit register</td></tr>
<tr><th>OF1/OF0</th><th>Offset Register</th></tr>
<tr><td>0/0</td><td>No offset added to address</td></tr>
<tr><td>0/1</td><td>Add Program Counter (PC) to address</td></tr>
<tr><td>1/0</td><td>Add Stack Pointer (SP) to address</td></tr>
<tr><td>1/1</td><td>Add Base Offset Register (BR) to address</td></tr>
<tr><th>UM</th><th>User mode selector</th></tr>
<tr><td>0</td><td>Current mode environment (user space/hypervisor mode)</td></tr>
<tr><td>1</td><td>User mode environment, privileged operation; Stack Pointer for OF=10 is also User Space stack pointer </td></tr>
<tr><th>NF</th><th>No Flags selector</th></tr>
<tr><td>0</td><td>Flags are updated on each (relevant) operation according to standard 6502 rules</td></tr>
<tr><td>1</td><td>Flags are not updated.</td></tr>
</table>
<p>
        These prefix opcodes modify the following opcodes in various aspects. The following opcodes
        are taken from the original 8  bit opcodes. I.e. there could be a new opcode
        </p><pre>
        LDA.L #$12345678
        </pre><p>to load the accumulator with a long (32  bit) value, that is implemented as
        </p><pre>
        23 A9 78 56 34 12
        </pre><p>Here 23 is the prefix with RS=%10, i.e. 32  bit registers, and A9 is the original
        LDA immediate opcode - only the parameter is now 4 byte (32  bit) not 1 byte anymore.
        </p><p>
        Please note that when all variable prefix bits are zero, the original 6502 operation is executed - 
	with the notable exception on LD* opcodes as described in the section about
	<a href="#prefle">Load Extension</a>.
        </p><p>
        Please also note that the order of the prefix bytes is well defined. prefix1 must be before prefix2,
        which is before the actual opcode. This way the prefix1 codes can be reused in the actual prefixed opcode.
        This would not be the case if prefix2 was before prefix1, because then it would not be distinguishable
        of the byte following prefix2 is a prefix1 or a reused opcode. This is done to be able to
	reuse the prefix1 values for extended opcodes, when a prefix1 byte has already occured.
	With AM=1 a prefix1 byte must be set, so there can be additional opcodes in the prefix1 space
	that use extended <a href="af65002admodes.html">addressing modes</a>.
        </p><p>
	The following table gives an overview on which prefix applies to which opcode.
	</p>

<table class="optable"><tr><th>LSB-&gt;<br/>MSB</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>A</th><th>B</th><th>C</th><th>D</th><th>E</th><th>F</th></tr>
<tr><th>0</th><td><div>BRK #byte</div>
<div class="prefixes"><br/>RS</div>
</td><td><div>ORA (zp,X)</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td class="c65k"><div>LDA zp,Y</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td class="prefix"><div>ORA [[zp,X]]</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM=1</div>
</td><td class="cmos"><div>TSB zp</div>
<div class="prefixes"><br/>NF, RS, UM, OF, AM</div>
</td><td><div>ORA zp</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>ASL zp</div>
<div class="prefixes"><br/>NF, RS, UM, OF, AM</div>
</td><td class="prefix"><div>JMP [[abs]]</div>
<div class="prefixes"><br/>UM, OF, LE, AM=1</div>
</td><td><div>PHP </div>
<div class="prefixes"><br/>UM</div>
</td><td><div>ORA #byte</div>
<div class="prefixes"><br/>NF, RS, LE</div>
</td><td><div>ASL </div>
<div class="prefixes"><br/>NF, RS</div>
</td><td class="prefix">prefix2</td><td class="cmos"><div>TSB abs</div>
<div class="prefixes"><br/>NF, RS, UM, OF, AM</div>
</td><td><div>ORA abs</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>ASL abs</div>
<div class="prefixes"><br/>NF, RS, UM, OF, AM</div>
</td><td class="prefix">EXT</td></tr>
<tr><th>1</th><td><div>BPL rel</div>
<div class="prefixes"><br/>RS</div>
</td><td><div>ORA (zp),Y</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td class="cmos"><div>ORA (zp)</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td class="prefix"><div>ORA [[zp]],Y</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM=1</div>
</td><td class="cmos"><div>TRB zp</div>
<div class="prefixes"><br/>NF, RS, UM, OF, AM</div>
</td><td><div>ORA zp,X</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>ASL zp,X</div>
<div class="prefixes"><br/>NF, RS, UM, OF, AM</div>
</td><td class="prefix"><div>ORA [[zp]]</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM=1</div>
</td><td><div>CLC </div>
<div class="prefixes"></div>
</td><td><div>ORA abs,Y</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td class="cmos"><div>INC </div>
<div class="prefixes"><br/>NF, RS</div>
</td><td class="prefix">prefix2</td><td class="cmos"><div>TRB abs</div>
<div class="prefixes"><br/>NF, RS, UM, OF, AM</div>
</td><td><div>ORA abs,X</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>ASL abs,X</div>
<div class="prefixes"><br/>NF, RS, UM, OF, AM</div>
</td><td class="unused"></td></tr>
<tr><th>2</th><td><div>JSR abs</div>
<div class="prefixes"><br/>RS, OF, LE, AM</div>
</td><td><div>AND (zp,X)</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td class="c65k"><div>STA zp,Y</div>
<div class="prefixes"><br/>RS, UM, OF, AM</div>
</td><td class="prefix"><div>AND [[zp,X]]</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM=1</div>
</td><td><div>BIT zp</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>AND zp</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>ROL zp</div>
<div class="prefixes"><br/>NF, RS, UM, OF, AM</div>
</td><td class="prefix"><div>JMP [[abs,X]]</div>
<div class="prefixes"><br/>UM, OF, LE, AM=1</div>
</td><td><div>PLP </div>
<div class="prefixes"></div>
</td><td><div>AND #byte</div>
<div class="prefixes"><br/>NF, RS, LE</div>
</td><td><div>ROL </div>
<div class="prefixes"><br/>NF, RS</div>
</td><td class="prefix">prefix2</td><td><div>BIT abs</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>AND abs</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>ROL abs</div>
<div class="prefixes"><br/>NF, RS, UM, OF, AM</div>
</td><td class="prefix">SYS</td></tr>
<tr><th>3</th><td><div>BMI rel</div>
<div class="prefixes"><br/>RS</div>
</td><td><div>AND (zp),Y</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td class="cmos"><div>AND (zp)</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td class="prefix"><div>AND [[zp]],Y</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM=1</div>
</td><td class="cmos"><div>BIT zp,X</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>AND zp,X</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>ROL zp,X</div>
<div class="prefixes"><br/>NF, RS, UM, OF, AM</div>
</td><td class="prefix"><div>AND [[zp]]</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM=1</div>
</td><td><div>SEC </div>
<div class="prefixes"></div>
</td><td><div>AND abs,Y</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td class="cmos"><div>DEC </div>
<div class="prefixes"><br/>NF, RS</div>
</td><td class="prefix">prefix2</td><td class="cmos"><div>BIT abs,X</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>AND abs,X</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>ROL abs,X</div>
<div class="prefixes"><br/>NF, RS, UM, OF, AM</div>
</td><td class="unused"></td></tr>
<tr><th>4</th><td><div>RTI </div>
<div class="prefixes"></div>
</td><td><div>EOR (zp,X)</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td class="c65k"><div>LDA (abs),Y</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td class="prefix"><div>EOR [[zp,X]]</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM=1</div>
</td><td class="c65k"><div>BSR relwide</div>
<div class="prefixes"><br/>RS, AM</div>
</td><td><div>EOR zp</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>LSR zp</div>
<div class="prefixes"><br/>NF, RS, UM, OF, AM</div>
</td><td class="prefix"><div>LDA [[abs]],Y</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM=1</div>
</td><td><div>PHA </div>
<div class="prefixes"><br/>RS, UM</div>
</td><td><div>EOR #byte</div>
<div class="prefixes"><br/>NF, RS, LE</div>
</td><td><div>LSR </div>
<div class="prefixes"><br/>NF, RS</div>
</td><td class="prefix">prefix2</td><td><div>JMP abs</div>
<div class="prefixes"><br/>UM, OF, LE, AM</div>
</td><td><div>EOR abs</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>LSR abs</div>
<div class="prefixes"><br/>NF, RS, UM, OF, AM</div>
</td><td class="prefix">QUICK</td></tr>
<tr><th>5</th><td><div>BVC rel</div>
<div class="prefixes"><br/>RS</div>
</td><td><div>EOR (zp),Y</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td class="cmos"><div>EOR (zp)</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td class="prefix"><div>EOR [[zp]],Y</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM=1</div>
</td><td class="unused"></td><td><div>EOR zp,X</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>LSR zp,X</div>
<div class="prefixes"><br/>NF, RS, UM, OF, AM</div>
</td><td class="prefix"><div>EOR [[zp]]</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM=1</div>
</td><td><div>CLI </div>
<div class="prefixes"></div>
</td><td><div>EOR abs,Y</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td class="cmos"><div>PHY </div>
<div class="prefixes"><br/>RS, UM</div>
</td><td class="prefix">prefix2</td><td class="unused"></td><td><div>EOR abs,X</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>LSR abs,X</div>
<div class="prefixes"><br/>NF, RS, UM, OF, AM</div>
</td><td class="unused"></td></tr>
<tr><th>6</th><td><div>RTS </div>
<div class="prefixes"><br/>RS</div>
</td><td><div>ADC (zp,X)</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td class="c65k"><div>LDA (abs,X)</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td class="prefix"><div>ADC [[zp,X]]</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM=1</div>
</td><td class="cmos"><div>STZ zp</div>
<div class="prefixes"><br/>RS, UM, OF, AM</div>
</td><td><div>ADC zp</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>ROR zp</div>
<div class="prefixes"><br/>NF, RS, UM, OF, AM</div>
</td><td class="prefix"><div>LDA [[abs,X]]</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM=1</div>
</td><td><div>PLA </div>
<div class="prefixes"><br/>NF, RS, UM, LE</div>
</td><td><div>ADC #byte</div>
<div class="prefixes"><br/>NF, RS, LE</div>
</td><td><div>ROR </div>
<div class="prefixes"><br/>NF, RS</div>
</td><td class="prefix">prefix2</td><td><div>JMP (abs)</div>
<div class="prefixes"><br/>UM, OF, LE, AM</div>
</td><td><div>ADC abs</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>ROR abs</div>
<div class="prefixes"><br/>NF, RS, UM, OF, AM</div>
</td><td class="prefix">reserved prefix</td></tr>
<tr><th>7</th><td><div>BVS rel</div>
<div class="prefixes"><br/>RS</div>
</td><td><div>ADC (zp),Y</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td class="cmos"><div>ADC (zp)</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td class="prefix"><div>ADC [[zp]],Y</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM=1</div>
</td><td class="cmos"><div>STZ zp,X</div>
<div class="prefixes"><br/>RS, UM, OF, AM</div>
</td><td><div>ADC zp,X</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>ROR zp,X</div>
<div class="prefixes"><br/>NF, RS, UM, OF, AM</div>
</td><td class="prefix"><div>ADC [[zp]]</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM=1</div>
</td><td><div>SEI </div>
<div class="prefixes"></div>
</td><td><div>ADC abs,Y</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td class="cmos"><div>PLY </div>
<div class="prefixes"><br/>NF, RS, UM, LE</div>
</td><td class="prefix">prefix2</td><td class="cmos"><div>JMP (abs,X)</div>
<div class="prefixes"><br/>UM, OF, LE, AM</div>
</td><td><div>ADC abs,X</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>ROR abs,X</div>
<div class="prefixes"><br/>NF, RS, UM, OF, AM</div>
</td><td class="unused"></td></tr>
<tr><th>8</th><td class="cmos"><div>BRA rel</div>
<div class="prefixes"><br/>RS</div>
</td><td><div>STA (zp,X)</div>
<div class="prefixes"><br/>RS, UM, OF, AM</div>
</td><td class="c65k"><div>BSR rel</div>
<div class="prefixes"><br/>RS, AM</div>
</td><td class="prefix"><div>STA [[zp,X]]</div>
<div class="prefixes"><br/>RS, UM, OF, AM=1</div>
</td><td><div>STY zp</div>
<div class="prefixes"><br/>RS, UM, OF, AM</div>
</td><td><div>STA zp</div>
<div class="prefixes"><br/>RS, UM, OF, AM</div>
</td><td><div>STX zp</div>
<div class="prefixes"><br/>RS, UM, OF, AM</div>
</td><td class="prefix"><div>JSR [[abs]]</div>
<div class="prefixes"><br/>RS, OF, LE, AM=1</div>
</td><td><div>DEY </div>
<div class="prefixes"><br/>NF, RS</div>
</td><td class="cmos"><div>BIT #byte</div>
<div class="prefixes"><br/>NF, RS, LE</div>
</td><td><div>TXA </div>
<div class="prefixes"><br/>NF, RS, LE</div>
</td><td class="prefix">prefix2</td><td><div>STY abs</div>
<div class="prefixes"><br/>RS, UM, OF, AM</div>
</td><td><div>STA abs</div>
<div class="prefixes"><br/>RS, UM, OF, AM</div>
</td><td><div>STX abs</div>
<div class="prefixes"><br/>RS, UM, OF, AM</div>
</td><td class="prefix">reserved prefix</td></tr>
<tr><th>9</th><td><div>BCC rel</div>
<div class="prefixes"><br/>RS</div>
</td><td><div>STA (zp),Y</div>
<div class="prefixes"><br/>RS, UM, OF, AM</div>
</td><td class="cmos"><div>STA (zp)</div>
<div class="prefixes"><br/>RS, UM, OF, AM</div>
</td><td class="prefix"><div>STA [[zp]],Y</div>
<div class="prefixes"><br/>RS, UM, OF, AM=1</div>
</td><td><div>STY zp,X</div>
<div class="prefixes"><br/>RS, UM, OF, AM</div>
</td><td><div>STA zp,X</div>
<div class="prefixes"><br/>RS, UM, OF, AM</div>
</td><td><div>STX zp,Y</div>
<div class="prefixes"><br/>RS, UM, OF, AM</div>
</td><td class="prefix"><div>STA [[zp]]</div>
<div class="prefixes"><br/>RS, UM, OF, AM=1</div>
</td><td><div>TYA </div>
<div class="prefixes"><br/>NF, RS, LE</div>
</td><td><div>STA abs,Y</div>
<div class="prefixes"><br/>RS, UM, OF, AM</div>
</td><td><div>TXS </div>
<div class="prefixes"><br/>RS, UM, LE</div>
</td><td class="prefix">prefix2</td><td class="cmos"><div>STZ abs</div>
<div class="prefixes"><br/>RS, UM, OF, AM</div>
</td><td><div>STA abs,X</div>
<div class="prefixes"><br/>RS, UM, OF, AM</div>
</td><td class="cmos"><div>STZ abs,X</div>
<div class="prefixes"><br/>RS, UM, OF, AM</div>
</td><td class="prefix">reserved prefix</td></tr>
<tr><th>A</th><td><div>LDY #byte</div>
<div class="prefixes"><br/>NF, RS, LE</div>
</td><td><div>LDA (zp,X)</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>LDX #byte</div>
<div class="prefixes"><br/>NF, RS, LE</div>
</td><td class="prefix"><div>LDA [[zp,X]]</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM=1</div>
</td><td><div>LDY zp</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>LDA zp</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>LDX zp</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td class="prefix"><div>JSR [[abs,X]]</div>
<div class="prefixes"><br/>RS, OF, LE, AM=1</div>
</td><td><div>TAY </div>
<div class="prefixes"><br/>NF, RS, LE</div>
</td><td><div>LDA #byte</div>
<div class="prefixes"><br/>NF, RS, LE</div>
</td><td><div>TAX </div>
<div class="prefixes"><br/>NF, RS, LE</div>
</td><td class="prefix">prefix2</td><td><div>LDY abs</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>LDA abs</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>LDX abs</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td class="prefix">reserved prefix</td></tr>
<tr><th>B</th><td><div>BCS rel</div>
<div class="prefixes"><br/>RS</div>
</td><td><div>LDA (zp),Y</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td class="cmos"><div>LDA (zp)</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td class="prefix"><div>LDA [[zp]],Y</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM=1</div>
</td><td><div>LDY zp,X</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>LDA zp,X</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>LDX zp,Y</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td class="prefix"><div>LDA [[zp]]</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM=1</div>
</td><td><div>CLV </div>
<div class="prefixes"></div>
</td><td><div>LDA abs,Y</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>TSX </div>
<div class="prefixes"><br/>NF, RS, UM, LE</div>
</td><td class="prefix">prefix2</td><td><div>LDY abs,X</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>LDA abs,X</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>LDX abs,Y</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td class="prefix">reserved prefix</td></tr>
<tr><th>C</th><td><div>CPY #byte</div>
<div class="prefixes"><br/>RS, LE</div>
</td><td><div>CMP (zp,X)</div>
<div class="prefixes"><br/>RS, UM, OF, LE, AM</div>
</td><td class="c65k"><div>STA (abs),Y</div>
<div class="prefixes"><br/>RS, UM, OF, AM</div>
</td><td class="prefix"><div>CMP [[zp,X]]</div>
<div class="prefixes"><br/>RS, UM, OF, LE, AM=1</div>
</td><td><div>CPY zp</div>
<div class="prefixes"><br/>RS, UM, OF, LE, AM</div>
</td><td><div>CMP zp</div>
<div class="prefixes"><br/>RS, UM, OF, LE, AM</div>
</td><td><div>DEC zp</div>
<div class="prefixes"><br/>NF, RS, UM, OF, AM</div>
</td><td class="prefix"><div>STA [[abs]],Y</div>
<div class="prefixes"><br/>RS, UM, OF, AM=1</div>
</td><td><div>INY </div>
<div class="prefixes"><br/>NF, RS</div>
</td><td><div>CMP #byte</div>
<div class="prefixes"><br/>RS, LE</div>
</td><td><div>DEX </div>
<div class="prefixes"><br/>NF, RS</div>
</td><td class="prefix">prefix2</td><td><div>CPY abs</div>
<div class="prefixes"><br/>RS, UM, OF, LE, AM</div>
</td><td><div>CMP abs</div>
<div class="prefixes"><br/>RS, UM, OF, LE, AM</div>
</td><td><div>DEC abs</div>
<div class="prefixes"><br/>NF, RS, UM, OF, AM</div>
</td><td class="prefix">reserved prefix</td></tr>
<tr><th>D</th><td><div>BNE rel</div>
<div class="prefixes"><br/>RS</div>
</td><td><div>CMP (zp),Y</div>
<div class="prefixes"><br/>RS, UM, OF, LE, AM</div>
</td><td class="cmos"><div>CMP (zp)</div>
<div class="prefixes"><br/>RS, UM, OF, LE, AM</div>
</td><td class="prefix"><div>CMP [[zp]],Y</div>
<div class="prefixes"><br/>RS, UM, OF, LE, AM=1</div>
</td><td class="unused"></td><td><div>CMP zp,X</div>
<div class="prefixes"><br/>RS, UM, OF, LE, AM</div>
</td><td><div>DEC zp,X</div>
<div class="prefixes"><br/>NF, RS, UM, OF, AM</div>
</td><td class="prefix"><div>CMP [[zp]]</div>
<div class="prefixes"><br/>RS, UM, OF, LE, AM=1</div>
</td><td><div>CLD </div>
<div class="prefixes"></div>
</td><td><div>CMP abs,Y</div>
<div class="prefixes"><br/>RS, UM, OF, LE, AM</div>
</td><td class="cmos"><div>PHX </div>
<div class="prefixes"><br/>RS, UM</div>
</td><td class="prefix">prefix2</td><td class="c65k"><div>JSR (abs)</div>
<div class="prefixes"><br/>RS, OF, LE, AM</div>
</td><td><div>CMP abs,X</div>
<div class="prefixes"><br/>RS, UM, OF, LE, AM</div>
</td><td><div>DEC abs,X</div>
<div class="prefixes"><br/>NF, RS, UM, OF, AM</div>
</td><td class="prefix">reserved prefix</td></tr>
<tr><th>E</th><td><div>CPX #byte</div>
<div class="prefixes"><br/>RS, LE</div>
</td><td><div>SBC (zp,X)</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td class="c65k"><div>STA (abs,X)</div>
<div class="prefixes"><br/>RS, UM, OF, AM</div>
</td><td class="prefix"><div>SBC [[zp,X]]</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM=1</div>
</td><td><div>CPX zp</div>
<div class="prefixes"><br/>RS, UM, OF, LE, AM</div>
</td><td><div>SBC zp</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>INC zp</div>
<div class="prefixes"><br/>NF, RS, UM, OF, AM</div>
</td><td class="prefix"><div>STA [[abs,X]]</div>
<div class="prefixes"><br/>RS, UM, OF, AM=1</div>
</td><td><div>INX </div>
<div class="prefixes"><br/>NF, RS</div>
</td><td><div>SBC #byte</div>
<div class="prefixes"><br/>NF, RS, LE</div>
</td><td><div>NOP </div>
<div class="prefixes"></div>
</td><td class="prefix">prefix2</td><td><div>CPX abs</div>
<div class="prefixes"><br/>RS, UM, OF, LE, AM</div>
</td><td><div>SBC abs</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>INC abs</div>
<div class="prefixes"><br/>NF, RS, UM, OF, AM</div>
</td><td class="prefix">reserved prefix</td></tr>
<tr><th>F</th><td><div>BEQ rel</div>
<div class="prefixes"><br/>RS</div>
</td><td><div>SBC (zp),Y</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td class="cmos"><div>SBC (zp)</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td class="prefix"><div>SBC [[zp]],Y</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM=1</div>
</td><td class="c65k"><div>TRP #byte</div>
<div class="prefixes"></div>
</td><td><div>SBC zp,X</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>INC zp,X</div>
<div class="prefixes"><br/>NF, RS, UM, OF, AM</div>
</td><td class="prefix"><div>SBC [[zp]]</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM=1</div>
</td><td><div>SED </div>
<div class="prefixes"></div>
</td><td><div>SBC abs,Y</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td class="cmos"><div>PLX </div>
<div class="prefixes"><br/>NF, RS, UM, LE</div>
</td><td class="prefix">prefix2</td><td class="c65k"><div>JSR (abs,X)</div>
<div class="prefixes"><br/>RS, OF, LE, AM</div>
</td><td><div>SBC abs,X</div>
<div class="prefixes"><br/>NF, RS, UM, OF, LE, AM</div>
</td><td><div>INC abs,X</div>
<div class="prefixes"><br/>NF, RS, UM, OF, AM</div>
</td><td class="prefix">reserved prefix</td></tr>
</table>

       <p>
        The grey fields note opcodes that do not use any prefix bits.
        </p>	<p>
        The LE flags only apply to opcodes that read an operand from memory, but not to read-modify-write opcodes.
        It does not apply to store operations (which could have been done switching memory and register sides).
	However, as the processor is available in different native register widths, the store would
	happen in different widths depending on the processor - effectively binding the software to a fixed
	processor width.
        </p><p>
        The NF flag does not apply to compare opcodes - their only purpose is to set the flags...
        </p> <p>
        Note that the Register size option for the RTS and JSR opcodes determine the size of the
        return address as put on the stack. The RS=00 (8  bit register size option) however is mapped to the
        natural address width of the processor (mode).
        </p><p>
        The Register size option for the branch opcodes determines the size of the relative address
        offset. For the BSR opcode this is in conflict with the size options for the address on
        the stack. Therefore BSR is handled similar to JSR, in that RS determines the size of the
        return address on the stack, and AM modifies the relative offset from "rel" to "rellong"
        resp. from "relwide" to "relquad".
        </p><p>
        Note that the TRAP opcode is marked as using no prefix bits, but still written down in that
        table. This is for future extensions, when RS may be used to allow more than 256 trap codes.
        </p><p>
        The green cells are duplicate opcodes. These take the place of prefix1 <!--resp. some opcodes that
        do not use prefix flags (like CLC)--> and require at least one prefix bit set (AM in the current cases).
        These duplicate opcodes allow to extend an indirect opcode, more specifically to have more options
        for the size of the address stored at the indirect location. <!--For a description see below.-->
        </p><p>
        Normally not all addressing modes would be supported with direct addressing mode replacements.
        The quad (longlong) indirect addressing modes
        are not reached. Thus the indirect opcodes are mirrored, and extended from long to quad (longlong) indirect
        addressing modes.
        Row LSB 1 is mirrored thus to row LSB 3, as well as row LSB 2 is mirrored to LSB 7.
        These values are marked with a green background in the table. The LSB 3 and 7 rows then change from
        (normal = word) indirect addressing modes to quad (longlong) indirect addressing modes.
        </p><p>
        Also note that there a are no indirect addressing modes that take a long or quad (longlong) value 
	as indirect address.
        </p>
     </div></div><div class="h2"><div class="h2h"><div class="h2t"> </div><h2><a name="prefam" id="prefam">Addressing Mode</a></h2><div class="toplink"><a href="#top">Top</a></div></div><div class="h2c"><p>
	The AM prefix allows to select an alternative addressing mode compared to the original 6502
	addressing mode. For example the "zeropage" addressing mode is converted to the "long"
	alternative addressing mode.
	</p><p>
	For more details on this please see the <a href="af65002admodes.html">addressing modes</a> page.
	</p></div></div><div class="h2"><div class="h2h"><div class="h2t"> </div><h2><a name="prefof" id="prefof">Offset prefix</a></h2><div class="toplink"><a href="#top">Top</a></div></div><div class="h2c">
        <p>
        The offset prefix bits allows to add an address offset to the effective address of the operand.
        Four options are available:
        </p><table class="optable">
        <tr><th>OF1/0</th><th>Register</th><th>Register Name</th><th>Syntax</th><th>Examples</th></tr>
        <tr><td>00</td><td>-</td><td>no register value added</td><td>-</td><td>LDA $1234</td></tr>
        <tr><td>01</td><td>PC</td><td>Program Counter</td><td>Address prefix P,</td><td>LDA P,$1234; LDA (P,$12),Y</td></tr>
        <tr><td>10</td><td>SR</td><td>Stack Pointer</td><td>Address prefix S,</td><td>LDA S,$1234; LDA [S,$23,X]</td></tr>
        <tr><td>11</td><td>BR</td><td>Base Register</td><td>Address prefix B,</td><td>LDA B,$1234; LDA B,$12,X</td></tr>
        </table><p>
        For (non-indirect) zeropage/absolute and indexed addressing modes to compute the effective address
        the standard addressing mode effective address is computed, then the register value is added to get the
        final effective address.
        </p><p>
        For the indirect addressing mode that situation is more complex. The offset register value is added
        to the zeropage or absolute address given in the opcode, to compute the indirect address.
        For indexed with XR addressing modes XR is added to this address to get the real indirect address.
        Then the effective address is read from the computed indirect address, for indexed with YR then
        the value of YR is added to the address read, to get the real effective address. Here the offset
        is not added again.
        </p>
<p>
        Note that the size of the address read from the indirect address is defined by the addressing mode
        alone (which is also determined by the AM prefix bit).
        </p>
       </div></div><div class="h2"><div class="h2h"><div class="h2t"> </div><h2><a name="prefrs" id="prefrs">Register Size prefix</a></h2><div class="toplink"><a href="#top">Top</a></div></div><div class="h2c">
        <p>
        The maximum register size depends on the used processor option. Each operation has a possibly smaller width.
        The Register size prefix defines the operation width. I.e. this determines the number of bytes to read from
        memory (from the effective address), the number of bytes to store to memory, or the number bytes to use
        from resp. store in a register.
        </p><p>
        The different width prefixes are written as postfixes to the opcode:
        </p>
        <table class="optable">
        <tr><th>RS1/0</th><th>width</th><th>Postfix</th><th>Example</th></tr>
        <tr><td>00</td><td>8</td><td></td><td>LDA #$12</td></tr>
        <tr><td>01</td><td>16</td><td>.W</td><td>LDA.W #$1234</td></tr>
        <tr><td>10</td><td>32</td><td>.L</td><td>LDA.L #$12345678</td></tr>
        <tr><td>11</td><td>64</td><td>.Q</td><td>LDA.Q #$123456789ABCDEF0</td></tr>
        </table><p>
        Please note that 8  bit width has no postfix.
        </p><p>
        TODO: rename to "OS" = "Operation size" or "OW" = "Operation width"?
        </p>
       </div></div><div class="h2"><div class="h2h"><div class="h2t"> </div><h2><a name="prefle" id="prefle">Load Extensions prefix</a></h2><div class="toplink"><a href="#top">Top</a></div></div><div class="h2c">
        <p>
        The registers have a defined width - depending on processor option - of 16, 32 or 64  bit. Operations can be
        from 8 to 64  bit.
        There are some use cases where some adaption of a value to the register size is practical. For example if
        an 8-bit value is used on a 32-bit operation - like adding <code>#8</code> to an address register.
        </p><p>
        For this purpose the LE bits define how a value loaded from memory (or from another register in the case of the
        Txy opcodes) is extended to full register size. Four options are available:</p>
        <table class="optable">
        <tr><th>LE1/0</th><th>Extension type</th><th>Postfix</th><th>Example</th><th>Description</th></tr>
        <tr><td rowspan="2">00</td><td rowspan="2">no extension</td><td></td><td>ADC #$92</td>
                <td>Adds $92 to AC in 8 bit operation, leaves upper bits untouched.
                Default for non-load/transfer operations.</td></tr>
        <tr><td>.E</td><td>LDY.E #$92</td><td>Loads $92 into YR, leaves upper bits untouched.</td></tr>
        <tr><td>01</td><td>sign-extension</td><td>.S</td><td>ADC.S #$92</td><td>Because the sign of $92 is 1, this
                adds $ffffffffffffff92 to AC with a 64 bit operation, truncated to actual processor width.</td></tr>
        <tr><td rowspan="2">10</td><td rowspan="2">zero-extension</td><td>.0</td><td>ADC.0 #$92</td><td>Extends with zeros and
                adds $0000000000000092 to AC in a 64 bit operation, truncated to actual AC width.
                </td></tr>
        <tr><td></td><td>LDY #$92</td><td>Extends with zeros and
                loads $0000000000000092 into a 64 bit YR, truncated to actual processor width.
                Default for loads and transfer operations</td></tr>
        <tr><td>11</td><td>ones-extension</td><td>.1</td><td>ADC.1 #$92</td><td>Extends with ones and
                adds $ffffffffffffff92 to AC in a 64 bit operation, truncated to actual processor width.</td></tr>
        </table>
        <p>
        When the result of an operation is written to a memory location or register, the data is written
        in the same width as the operation.
        </p><p>
        Using this extension - i.e. having a value of not 00 - modifies the meaning of the RS prefix. RS then actually
        defines the width of the memory location to be read. The actual operation happens after loading the value,
        and it happens at full width.
        For operations other than loads, the flags are set appropriately from the
        full width operation result value. For loads (LDA, LDX, LDY) and transfers (TAX, ...), however,
        the flags are set from the RS-width value that is read from memory (note: if you need flags from
        the full width value, use BIT A, but in general you should know the outcome of the extension of a load opcode).
        </p><p>
        There is another difference between loads/transfers and other operations. Loads and transfers do a zero-extension
        by default, while other opcodes do not extend. To change the load/transfer default behaviour, use an explicit LE prefix
        of 00. The assembler should take care to create the correct prefix when using another prefix bit in prefix2.
        For example doing a LDA.U should automatically be set to LDA.U0.
        </p><p>
        This somewhat inconsistent behaviour between loads/stores and others implements a "least surprise" strategy
        for loads. X and Y are always used full-width in address calculation. Doing an LDY #0 would not clear all bits
        and depending what previously executed code left in those bits this leads to unexpected behaviour.
        Even with the extension, however, the flags need to be set from the width that has been read - in general 8 bits,
        to be compatible with 6502 code.
        </p><p>
        So when loading a register, the upper bits are filled with zero by default - but flags are set
        from the original width (as defined by RS). To load AC with the lower bits only, explicitely
        set the prefix with LE0=LE1=0 (using the postfix .E). This would normally denote the original 6502
        behaviour and could thus be left out, but not in this case as the default - for loads/transfers - is not the
        6502 behaviour, yet compatible.
        </p>
       </div></div><div class="h2"><div class="h2h"><div class="h2t"> </div><h2><a name="prefum" id="prefum">User Mode selector</a></h2><div class="toplink"><a href="#top">Top</a></div></div><div class="h2c">
        <p>
        Normally the opcode uses the current processor mode - user or hypervisor - to compute the correct address.
        For the supervisor mode there is an option, however, to use an address from user mode as operand.
        This is what the User Mode selector bit (UM) is for.
        </p><p>
        When the User Mode selector is set, the operand following the opcode is read from the current (hypervisor mode)
        memory environment (as defined by the matchcode). Then the processor temporarily switches to user mode,
        using the user mode matchcode and usermode stack pointer. For non-indirect addressing modes then the operand
        is written to or read from the computed address. For indirect addressing modes the indirect address is
        read from user mode, then the actual operand is read from or written to user mode as well.
        </p><p>
        Note that this bit is a privileged operation - unavailable if no hypervisor mode option is present, and
        trapping into an abort if executed in user mode.
        </p><p>
        With the user mode selector such operations as PHA or PLX etc can be easily redirected to the user space
        stack.
        </p>
	</div></div><div class="h2"><div class="h2h"><div class="h2t"> </div><h2><a name="prefnf" id="prefnf">No Flags prefix</a></h2><div class="toplink"><a href="#top">Top</a></div></div><div class="h2c">
        <p>
	The NF bit, when set, prevents the status register bits from being changed.
	For example you can do index register increments for example without 
	losing the contents of the Z and N status register flags.
        </p>
	</div></div><div class="h2"><div class="h2h"><div class="h2t"> </div><h2>Disclaimer</h2><div class="toplink"><a href="#top">Top</a></div></div><div class="h2c">
All Copyrights are acknowledged.
The information here is provided under the terms as described
in <a href=af65002front.html#lic>the license section</a>.
    </div></div><hr />
Last updated 2012-04-23.
  </div></div><div id="footer"> </div></div></body></html> 

