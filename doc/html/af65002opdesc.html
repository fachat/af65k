<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="" />

<meta name="description" content="65002 documentation" />
<meta name="keywords" content="8-bit,6502,65002" />
<link rev="made" href="mailto:" />
<link rel="stylesheet" title="Default" type="text/css" href="doc.css" /><link rel="stylesheet" type="text/css" href="optable.css" />
<title>65002 Operation Documentation</title></head>
<body><div id="headerbox"><div id="lefthdr">The 65k Project</div><div id="righthdr"><div class="large">65002</div><div class="small">The 65k processor - a modern 6502 with 64 bit</div></div></div><div id="mainbox"><a name="top" id="top"></a><div id="leftcol"><div id="menu" class="top"><div class="tophead">navigate</div>
<div id="mtree">
<p>Specification</p>
<ul>
<li><a href="af65002front.html">Overview</a></li>
<li><a href="af65002regs.html">Register Set</a></li>
<li><a href="af65002opstruct.html">Opcodes Structure </a></li>
<li><a href="af65002admodes.html">Addressing Modes </a></li>
<li><a href="af65002prefixes.html">Prefixes</a></li>
<li><a href="af65002opcodes.html">Opcode Overview</a></li>
<li><a href="af65002opdesc.html">Opcode Docs</a></li>
<li><a href="af65002int.html">Reset, Traps and Interrupts</a></li>
<li><a href="af65002hyper.html">User/Hypervisor Mode</a></li>
<li><a href="af65002mem.html">Memory Management</a></li>
<li><a href="af65002config.html">Configuration Registers</a></li>
<li><a href="af65002compat.html">Compatibility</a></li>
<li><a href="af65002usage.html">Usage</a></li>
</ul>
<p>Implementation</p>
<ul>
<li><a href="af65002arch.html">Architecture Overview</a></li>
</ul>

</div>
		</div></div><div id="rightcol"><div class="top" id="twitter"><div class="tophead">follow</div><div>
		            Follow the 65k tweets on<br /><a class="extlink" target="_blank" href="https://twitter.com/#!/search/realtime/afachat%20%2365k">Twitter</a><br /> (In new window)
		</div></div><div class="top" id="forum"><div class="tophead">discuss</div><div><p>Discuss my site on <a class="extlink" target="_blank" href="http://forum.6502.org/viewtopic.php?t=956">this 6502.org forum thread</a></p><p>(Forum registration required to post)</p></div></div></div><div id="midcol"><div class="top" id="ie6warn">
You are using an old MS Internet Explorer as browser. This version is not supported anymore. Please use a 
more modern browser, like Internet Explorer 8 or later, 
<a target="_blank" class="extlink" href="http://www.firefox.com">Firefox</a>,
<a target="_blank" class="extlink" href="http://www.google.com/chrome">Google Chrome</a>, or
<a target="_blank" class="extlink" href="http://www.opera.com">Opera</a>.
</div><div class="top" id="content"><div id="minmax"></div><h1>65002 Operation Documentation</h1><div class="overview">
	<p>
	This page lists all the opcodes of the 65002 with appropriate explanations.
	</p>
<h2>List of operations</h2>
<ul>
<li>
<a href="#ADC">ADC</a>
 - Add content of memory location to accumulator</li>
<li>
<a href="#ADD">ADD</a>
 - Add content of memory location to accumulator without using
				carry as input
			</li>
<li>
<a href="#ADE">ADE</a>
 - Add value to E register</li>
<li>
<a href="#ADI">ADI</a>
 - Add immediate value to a memory location</li>
<li>
<a href="#ADQ">ADQ</a>
 - Add immediate value to a register</li>
<li>
<a href="#AND">AND</a>
 - Bitwise AND accumulator with content of memory location</li>
<li>
<a href="#ASL">ASL</a>
 - Arithmetic Shift Left - shift accumulator one bit to the left,
				shifting in zero in bit 0
			</li>
<li>
<a href="#ASR">ASR</a>
 - Arithmetic Shift Right - Similar to LSR, but shifts in the sign
				of the value, not zero
			</li>
<li>
<a href="#BBR#">BBR#</a>
 - Branch on bit reset</li>
<li>
<a href="#BBS#">BBS#</a>
 - Branch on bit set</li>
<li>
<a href="#BCC">BCC</a>
 - Branch on carry clear - take branch when C flag is cleared
			</li>
<li>
<a href="#BCN">BCN</a>
 - Bit Count: counts 1-bits in AC or in given location, stores
				number of 1-bits back in AC
			</li>
<li>
<a href="#BCS">BCS</a>
 - Branch on carry set - take branch when C flag is set</li>
<li>
<a href="#BEQ">BEQ</a>
 - Branch on equal - take branch when Z flag is set</li>
<li>
<a href="#BEV">BEV</a>
 - Branch on even</li>
<li>
<a href="#BGES">BGES</a>
 - Branch on signed greater or equal than</li>
<li>
<a href="#BGT">BGT</a>
 - Branch if greater - take branch when C flag is set but Z flag
				is
				clear
			</li>
<li>
<a href="#BGTS">BGTS</a>
 - Branch if greater - take branch when signed greater or equal G
				flag is set but Z flag is clear
			</li>
<li>
<a href="#BIT">BIT</a>
 - Bitwise test with accumulator - AND the memory location with
				the
				accumulator, and set N (=bit 7), V (=bit 7), Z
				(iff all bits
				zero) flags from the result. In case of the accumulator addressing,
				simply
				set the flags from the
				accumulator
			</li>
<li>
<a href="#BLE">BLE</a>
 - Branch if less or equal - take branch when C flag is clear or Z
				flag is set
			</li>
<li>
<a href="#BLES">BLES</a>
 - Branch if less or equal - take branch when signed greater or
				equal flag G is clear or Z flag is set
			</li>
<li>
<a href="#BLTS">BLTS</a>
 - Branch on signed less than</li>
<li>
<a href="#BMI">BMI</a>
 - Branch on minus - take branch when N flag is set</li>
<li>
<a href="#BNE">BNE</a>
 - Branch on not equal - take branch when Z flag is cleared</li>
<li>
<a href="#BOD">BOD</a>
 - Branch on odd</li>
<li>
<a href="#BPL">BPL</a>
 - Branch on plus - take branch when N flag is cleared</li>
<li>
<a href="#BRA">BRA</a>
 - Branch always - branch independent from any flags</li>
<li>
<a href="#BRK">BRK</a>
 - Starts the break routine.</li>
<li>
<a href="#BSR">BSR</a>
 - Branch subroutine - similar to JSR, but use relative addressing
				similar to branch opcodes
			</li>
<li>
<a href="#BSW">BSW</a>
 - Bit Swap: exchanges bit 0 with bit W-1, bit 1 with bit W-2 and
				so on.
			</li>
<li>
<a href="#BVC">BVC</a>
 - Branch on overflow clear - take branch when V flag is cleared
			</li>
<li>
<a href="#BVS">BVS</a>
 - Branch on overflow set - take branch when V flag is set</li>
<li>
<a href="#CLC">CLC</a>
 - Clear the C flag</li>
<li>
<a href="#CLD">CLD</a>
 - Clear the decimal (D) flag</li>
<li>
<a href="#CLI">CLI</a>
 - Clear the interrupt (I) flag</li>
<li>
<a href="#CLV">CLV</a>
 - Clear the overflow (V) flag</li>
<li>
<a href="#CMP">CMP</a>
 - Compare accumulator with content of memory location</li>
<li>
<a href="#CPX">CPX</a>
 - Compare X register with content of memory location</li>
<li>
<a href="#CPY">CPY</a>
 - Compare Y register with content of memory location</li>
<li>
<a href="#CPZ">CPZ</a>
 - Compare Z register with content of memory location</li>
<li>
<a href="#CSW">CSW</a>
 - Compare and SWap - compare memory with AC, and if matches, set to value from XR. AC is loaded with the value from the memory location.
			</li>
<li>
<a href="#DAD">DAD</a>
 - Decimal adjust of a normal ADC of two BCD numbers.</li>
<li>
<a href="#DAS">DAS</a>
 - Decimal adjust of a normal SBC of two BCD numbers.</li>
<li>
<a href="#DEC">DEC</a>
 - Decrement the content of a memory location by one</li>
<li>
<a href="#DEX">DEX</a>
 - Decrement the content of the X register by one</li>
<li>
<a href="#DEY">DEY</a>
 - Decrement the Y register by one</li>
<li>
<a href="#DEZ">DEZ</a>
 - Decrement Z register</li>
<li>
<a href="#EOR">EOR</a>
 - Bitwise Exclusive-OR accumulator with content of memory
				location
			</li>
<li>
<a href="#EXT">EXT</a>
 - Extend a value in AC from RS to the full size. Setting LE
				defines the type of extension.
			</li>
<li>
<a href="#INC">INC</a>
 - Increment the content of a memory location by one</li>
<li>
<a href="#INV">INV</a>
 - Invert AC, i.e. set AC to the 1s-complement of AC</li>
<li>
<a href="#INX">INX</a>
 - Increment the content of the X register by one</li>
<li>
<a href="#INY">INY</a>
 - Increment the content of the Y register by one</li>
<li>
<a href="#INZ">INZ</a>
 - Increment Z register</li>
<li>
<a href="#JMP">JMP</a>
 - Jump to new code address</li>
<li>
<a href="#JSR">JSR</a>
 - Jump subroutine - jump to a new code location, save return
				address on stack for RTS
			</li>
<li>
<a href="#LDA">LDA</a>
 - Load accumulator</li>
<li>
<a href="#LDB">LDB</a>
 - Load B with an immediate value</li>
<li>
<a href="#LDE">LDE</a>
 - Load E with an immediate value</li>
<li>
<a href="#LDX">LDX</a>
 - Load X register</li>
<li>
<a href="#LDY">LDY</a>
 - Load Y register</li>
<li>
<a href="#LDZ">LDZ</a>
 - Load Z register with a value</li>
<li>
<a href="#LEA">LEA</a>
 - Load Effective Address: compute the effective address and store
				it in the E (effective Address) register (always
				full width)
			</li>
<li>
<a href="#LSR">LSR</a>
 - Logical Shift Right - shift accumulator one bit to the right,
				shifting in zero in the highest bit
			</li>
<li>
<a href="#NEG">NEG</a>
 - negate AC, i.e. set AC to the 2s-complement of AC</li>
<li>
<a href="#NOP">NOP</a>
 - No operation</li>
<li>
<a href="#ORA">ORA</a>
 - Bitwise OR accumulator with content of memory location</li>
<li>
<a href="#PHA">PHA</a>
 - Push contents of the accumulator onto the stack</li>
<li>
<a href="#PHB">PHB</a>
 - Push B onto stack (full width)</li>
<li>
<a href="#PHE">PHE</a>
 - Push E onto stack (always full width)</li>
<li>
<a href="#PHI">PHI</a>
 - Push immediate value onto the stack</li>
<li>
<a href="#PHM">PHM</a>
 - Push contents of multiple registers onto the stack</li>
<li>
<a href="#PHP">PHP</a>
 - Push processor status register onto the stack</li>
<li>
<a href="#PHX">PHX</a>
 - Push contents of the X register onto the stack</li>
<li>
<a href="#PHY">PHY</a>
 - Push contents of the Y register onto the stack</li>
<li>
<a href="#PHZ">PHZ</a>
 - Push Z Register onto stack</li>
<li>
<a href="#PLA">PLA</a>
 - Pull the contents of the accumulator from the stack</li>
<li>
<a href="#PLB">PLB</a>
 - Pull B from stack (full width)</li>
<li>
<a href="#PLE">PLE</a>
 - Pull E from stack (full width)</li>
<li>
<a href="#PLM">PLM</a>
 - Pull contents of multiple registers from the stack</li>
<li>
<a href="#PLP">PLP</a>
 - Pull processor status register from the stack</li>
<li>
<a href="#PLX">PLX</a>
 - Pull the contents of the X register from the stack</li>
<li>
<a href="#PLY">PLY</a>
 - Pull the contents of the Y register from the stack</li>
<li>
<a href="#PLZ">PLZ</a>
 - Pull Z Register from stack</li>
<li>
<a href="#PRB">PRB</a>
 - Push and Replace Base register: Push base offset register to
				the
				stack, then transfer E-register to the base
				register
			</li>
<li>
<a href="#RDL">RDL</a>
 - Rotate Direct Left - similar to ROL, but do not shift in carry,
				but the highest bit of the original value
			</li>
<li>
<a href="#RDL#">RDL#</a>
 - Rotate Direct Left - similar to ROL, but do not shift in carry,
				but the highest bit of the original value
			</li>
<li>
<a href="#RDR">RDR</a>
 - Rotate Direct Right - similar to ROR, but do not shift in
				carry,
				but the lowest bit of the original value
			</li>
<li>
<a href="#RDR#">RDR#</a>
 - Rotate Direct Right - similar to ROR, but do not shift in
				carry,
				but the lowest bit of the original value
			</li>
<li>
<a href="#RMB#">RMB#</a>
 - Reset memory bit</li>
<li>
<a href="#ROL">ROL</a>
 - Rotate Left - shift accumulator one bit to the left, shifting
				in
				the carry flag in bit 0, and shifting the
				highest bit into the
				carry flag instead.
			</li>
<li>
<a href="#ROL#">ROL#</a>
 - Rotate Left - shift accumulator one bit to the left, shifting
				in
				the carry flag in bit 0, and shifting the
				highest bit into the
				carry flag instead.
			</li>
<li>
<a href="#ROR">ROR</a>
 - Rotate Right - shift accumulator one bit to the right, shifting
				in the carry flag in the highest bit, and
				shifting
				bit 0 into the
				carry flag instead.
			</li>
<li>
<a href="#ROR#">ROR#</a>
 - Rotate Right - shift accumulator one bit to the right, shifting
				in the carry flag in the highest bit, and
				shifting
				bit 0 into the
				carry flag instead.
			</li>
<li>
<a href="#RTI">RTI</a>
 - Return from interrupt</li>
<li>
<a href="#RTS">RTS</a>
 - Return from subroutine - read return address from stack</li>
<li>
<a href="#RTU">RTU</a>
 - Return from trap handler.</li>
<li>
<a href="#SAB">SAB</a>
 - Swap A register with B register. Always done full width, no
				flags set.
			</li>
<li>
<a href="#SAX">SAX</a>
 - Swap AC with X register. Always done full width, no flags set.
			</li>
<li>
<a href="#SAY">SAY</a>
 - Swap AC with Y register. Always done full width, no flags set.
			</li>
<li>
<a href="#SBC">SBC</a>
 - Substract content of memory location from accumulator</li>
<li>
<a href="#SBE">SBE</a>
 - Subtract value from E register</li>
<li>
<a href="#SBI">SBI</a>
 - Subtract immediate value from a memory location</li>
<li>
<a href="#SBQ">SBQ</a>
 - Subtract immediate value from a register</li>
<li>
<a href="#SCC">SCC</a>
 - Skip on carry clear - skip next opcode when C flag is cleared</li>
<li>
<a href="#SCS">SCS</a>
 - Skip on carry set - skip next opcode when C flag is set</li>
<li>
<a href="#SEC">SEC</a>
 - Set the C flag</li>
<li>
<a href="#SED">SED</a>
 - Set the decimal (D) flag</li>
<li>
<a href="#SEI">SEI</a>
 - Set the interrupt (I) flag</li>
<li>
<a href="#SEQ">SEQ</a>
 - Skip on equal - skip next opcode when Z flag is set</li>
<li>
<a href="#SMB#">SMB#</a>
 - Set memory bit</li>
<li>
<a href="#SMI">SMI</a>
 - Skip on minus - skip next opcode when N flag is set</li>
<li>
<a href="#SNE">SNE</a>
 - Skip on not equal - skip next opcode when Z flag is cleared</li>
<li>
<a href="#SPL">SPL</a>
 - Skip on plus - skip next opcode when N flag is cleared</li>
<li>
<a href="#STA">STA</a>
 - Store the content of the accumulator into a memory location
			</li>
<li>
<a href="#STI">STI</a>
 - Store immediate byte value into a memory location</li>
<li>
<a href="#STX">STX</a>
 - Store the content of the X register to memory.</li>
<li>
<a href="#STY">STY</a>
 - Store the content of the Y register to memory.</li>
<li>
<a href="#STZ">STZ</a>
 - Store zero into a memory location</li>
<li>
<a href="#SUB">SUB</a>
 - Substract content of memory location from accumulator without
				using the carry flag as input
			</li>
<li>
<a href="#SVC">SVC</a>
 - Skip on overflow clear - skip next opcode when V flag is cleared</li>
<li>
<a href="#SVS">SVS</a>
 - Skip on overflow set - skip next opcode when V flag is set</li>
<li>
<a href="#SWP">SWP</a>
 - swap upper and lower half of the operand
			</li>
<li>
<a href="#SXY">SXY</a>
 - Swap X with Y register. Always done full width, no flags set.
			</li>
<li>
<a href="#SXZ">SXZ</a>
 - Swap X with Z register. Always done full width, no flags set.
			</li>
<li>
<a href="#TAB">TAB</a>
 - Transfer AC to B register</li>
<li>
<a href="#TAX">TAX</a>
 - Transfer the contents of accumulator into the X register</li>
<li>
<a href="#TAY">TAY</a>
 - Transfer the contents of accumulator into the Y register</li>
<li>
<a href="#TAZ">TAZ</a>
 - Transfer AC to Z Register</li>
<li>
<a href="#TEA">TEA</a>
 - Transfer E register to Accumulator</li>
<li>
<a href="#TEB">TEB</a>
 - Transfer E to B register (full width)</li>
<li>
<a href="#TMB#">TMB#</a>
 - Test memory bit</li>
<li>
<a href="#TPA">TPA</a>
 - Transfer Program counter to Accumulator</li>
<li>
<a href="#TRB">TRB</a>
 - Test and Reset Bit - AND the memory location with the
				accumulator, and set the Z flag from the result, then
				CLEAR all bits
				in the
				memory location that are set in the accumulator.
			</li>
<li>
<a href="#TRP">TRP</a>
 - Trap into 65k supervisor mode</li>
<li>
<a href="#TSB">TSB</a>
 - Test and Set Bit - AND the memory location with the
				accumulator,
				and set the Z flag from the result, then SET all
				bits in
				the
				memory location that are set in the accumulator.
			</li>
<li>
<a href="#TSX">TSX</a>
 - Transfer the contents of the stack pointer into the X register
				(Note: needs RS to keep compatibility with 6502)
			</li>
<li>
<a href="#TSY">TSY</a>
 - Transfer stack pointer to Y</li>
<li>
<a href="#TXA">TXA</a>
 - Transfer the contents of the X register into the accumulator
			</li>
<li>
<a href="#TXS">TXS</a>
 - Transfer the contents of X register into the stack pointer
				(Note: needs RS to keep compatibility with 6502)
			</li>
<li>
<a href="#TYA">TYA</a>
 - Transfer the contents of the Y register into the accumulator
			</li>
<li>
<a href="#TYS">TYS</a>
 - Transfer Y to stack pointer</li>
<li>
<a href="#TZA">TZA</a>
 - Transfer Z Register to AC</li>
</ul>
<h2>ADC</h2>
<a name="ADC"> </a><p>Add content of memory location to accumulator</p>
<table class="optable"><tr><th colspan="10">ADC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x61</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indexed with X indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x63</td><td>65k</td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indexed with X indirect 64bit</td><td></td><td></td></tr>
<tr><td></td><td>0x65</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x69</td><td></td><td>RS, LE, NF</td><td>Immediate</td><td></td><td></td></tr>
<tr><td></td><td>0x6d</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x71</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x72</td><td>cmos_indz</td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indirect 16bit indexed with Z</td><td></td><td></td></tr>
<tr><td></td><td>0x73</td><td>65k</td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indirect 64bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x75</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x77</td><td>65k</td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indirect 64bit indexed with Z</td><td></td><td></td></tr>
<tr><td></td><td>0x79</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x7d</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x69</td><td>65k</td><td>RS, LE, UM, NF</td><td>E indirect</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Add the operand to the accumulator and store back in the
					accumulator.
					Set the flags from the result. Use Decimal or
					Binary
					add depending
					on whether the
					decimal mode status bis is set or not
					respectively.
				</p><pre>
					AC, C, V &lt;= AC + Operand, C
					N &lt;= Tmp(7)
					Z &lt;=
					Z(Tmp)
				</pre><p>
					For a handling of the V-flag please see
					<a href="http://www.6502.org/tutorials/vflag.html">http://www.6502.org/tutorials/vflag.html</a>
					.
				</p><h3>65k</h3>
<p>
					The AM, OF, LE and RS prefixes are evaluated by the addressing
					modes.
					UM determines
					whether the operand is in user
					space. NF allows
					to not set the flags.
				</p><p>
					RS and LE together also determine the width of the operation.
					Note that the default is to use BYTE-wide operation
					without load
					extension.
				</p><h2>ADD</h2>
<a name="ADD"> </a><p>Add content of memory location to accumulator without using
				carry as input
			</p>
<table class="optable"><tr><th colspan="10">ADD</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x05</td><td>65k</td><td>RS, LE, NF</td><td>Immediate</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x00</td><td>65k</td><td>RS, LE, UM, NF</td><td>E indirect</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Add the operand to the accumulator and store back in the
					accumulator.
					Set the flags from the result. Use Binary
					mode add
					only.
					Do not use the Carry flag as input.
				</p><pre>
					AC, C, V &lt;= AC + Operand
					N &lt;= Tmp(7)
					Z &lt;=
					Z(Tmp)
				</pre><p>
					For a handling of the V-flag please see
					<a href="http://www.6502.org/tutorials/vflag.html">http://www.6502.org/tutorials/vflag.html</a>
					.
				</p><h3>65k</h3>
<p>
					The AM, OF, LE and RS prefixes are evaluated by the addressing
					modes.
					UM determines
					whether the operand is in user
					space. NF allows
					to not set the flags.
				</p><p>
					RS and LE together also determine the width of the operation.
					Note that the default is to use BYTE-wide operation
					without load
					extension.
				</p><h2>ADE</h2>
<a name="ADE"> </a><p>Add value to E register</p>
<table class="optable"><tr><th colspan="10">ADE</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x25</td><td>65k</td><td>RS, LE, NF</td><td>Immediate</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x24</td><td>65k</td><td>RS, NF</td><td>Accumulator</td><td></td><td></td></tr>
</table>
<h2>ADI</h2>
<a name="ADI"> </a><p>Add immediate value to a memory location</p>
<table class="optable"><tr><th colspan="10">ADI</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x45</td><td>65k</td><td>AM, OF, RS, UM, LE, NF</td><td>Immediate to Zeropage Address</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x15</td><td>65k</td><td>AM, OF, RS, UM, LE, NF</td><td>Immediate to Zeropage Address X-indexed</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x35</td><td>65k</td><td>AM, OF, RS, UM, LE, NF</td><td>Immediate to Zeropage indirect Y-indexed address</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x65</td><td>65k</td><td>AM, OF, RS, UM, LE, NF</td><td>Immediate to Absolute Address</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Add the immediate value following the opcode to the address given by the second operand. Carry is assumed cleared
				</p><pre>
					Operand &lt;= Operand + #immediate
				</pre><p>
					The AM and OF prefixes are evaluated by the addressing modes. UM determines
					whether the operand is in user
					space.
				</p><p>
					RS determines the width of the operation. 
					If a width larger than the immediate value is used, LE must be set to determine the extension type.
					Note that the default is RS=00, i.e. byte wide operation.
				</p><h2>ADQ</h2>
<a name="ADQ"> </a><p>Add immediate value to a register</p>
<table class="optable"><tr><th colspan="10">ADQ</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x55</td><td>65k</td><td>RS, LE, NF</td><td>Immediate to register</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x75</td><td>65k</td><td>RS, LE, NF</td><td>Immediate to register</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Add the immediate value following the opcode to the register given by the uppermost three bits of the immediate value. Carry is assumed cleared.
				</p><p>
					The following table details the register selection from the uppermost three bits of the immediate value:
				</p><table><tr><th>Value</th><td>Register</td></tr><tr><td>000</td><td>A</td></tr><tr><td>001</td><td>B</td></tr><tr><td>010</td><td>E</td></tr><tr><td>011</td><td>reserved</td></tr><tr><td>100</td><td>X</td></tr><tr><td>101</td><td>Y</td></tr><tr><td>110</td><td>Z</td></tr><tr><td>111</td><td>reserved</td></tr>
				</table><pre>
					Register &lt;= Register + #immediate
				</pre><p>
					RS determines the width of the operation. 
					If a width larger than the immediate value is used, LE must be set to determine the extension type.
					Note that the default is RS=00, i.e. byte wide operation.
				</p><h2>AND</h2>
<a name="AND"> </a><p>Bitwise AND accumulator with content of memory location</p>
<table class="optable"><tr><th colspan="10">AND</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x21</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indexed with X indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x23</td><td>65k</td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indexed with X indirect 64bit</td><td></td><td></td></tr>
<tr><td></td><td>0x25</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x29</td><td></td><td>RS, LE, NF</td><td>Immediate</td><td></td><td></td></tr>
<tr><td></td><td>0x2d</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x31</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x32</td><td>cmos_indz</td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indirect 16bit indexed with Z</td><td></td><td></td></tr>
<tr><td></td><td>0x33</td><td>65k</td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indirect 64bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x35</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x37</td><td>65k</td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indirect 64bit indexed with Z</td><td></td><td></td></tr>
<tr><td></td><td>0x39</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x3d</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x29</td><td>65k</td><td>RS, LE, UM, NF</td><td>E indirect</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Bitwise AND the accumulator with the operand and store back in
					the
					accumulator.
					Set the flags from the result.
				</p><pre>
					AC &lt;= AC &amp; Operand
					N &lt;= Tmp(7)
					Z &lt;=
					Z(Tmp)
				</pre><h3>65k</h3>
<p>
					The AM, OF, LE and RS prefixes are evaluated by the addressing
					modes.
					UM determines
					whether the operand is in user
					space. NF allows
					to not set the flags.
				</p><p>
					RS and LE together also determine the width of the operation.
					Note that the default is to use BYTE-wide operation
					without load
					extension.
				</p><h2>ASL</h2>
<a name="ASL"> </a><p>Arithmetic Shift Left - shift accumulator one bit to the left,
				shifting in zero in bit 0
			</p>
<table class="optable"><tr><th colspan="10">ASL</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x06</td><td></td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x0a</td><td></td><td>RS, NF</td><td>Accumulator</td><td></td><td></td></tr>
<tr><td></td><td>0x0e</td><td></td><td>AM, OF, RS, UM, NF</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x16</td><td></td><td>AM, OF, RS, UM, NF</td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x1e</td><td></td><td>AM, OF, RS, UM, NF</td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x0f</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x0d</td><td>65k</td><td>RS, UM, NF</td><td>E indirect</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Shift the operand or accumulator left one bit (i.e. multiply by
					2).
					Shift
					in a zero from the right.
					The bit shifted
					out is moved into
					the carry flag.
					Note this opcode is a read-modify-write opcode and
					not only has
					memory-oriented
					addressing modes but can work
					on the
					accumulator alone as well.
				</p><pre>
					C &lt;= AC(7)
					AC(7-1) &lt;= AC(6-0)
					AC(0) &lt;= 0
					N
					&lt;= AC7)
					Z &lt;= Z(AC)
				</pre><h3>65k</h3>
<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					UM
					determines
					whether the operand is in user
					space. NF allows to not
					set the flags.
				</p><p>
					RS also determine the width of the operation. There is no LE
					prefix,
					as the read and write
					widths are the same.
					Note
					that the
					default is to use BYTE-wide operation without load
					extension.
				</p><h2>ASR</h2>
<a name="ASR"> </a><p>Arithmetic Shift Right - Similar to LSR, but shifts in the sign
				of the value, not zero
			</p>
<table class="optable"><tr><th colspan="10">ASR</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x06</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x0a</td><td>65k</td><td>RS, NF</td><td>Accumulator</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x0e</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x16</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x1e</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x1f</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x1d</td><td>65k</td><td>RS, UM, NF</td><td>E indirect</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Shift the operand or accumulator right one bit (i.e. divide by
					2). Shift
					in the sign (uppermost bit) from the left.
					The bit shifted
					out is moved into the carry flag.
					Note this opcode is a
					read-modify-write opcode and not only has
					memory-oriented addressing
					modes but can work
					on the accumulator alone as well.
				</p><pre>
					C &lt;= AC(0)
					AC(6-0) &lt;= AC(7-1)
					N &lt;= AC7)
					Z
					&lt;= Z(AC)
				</pre><h3>65k</h3>
<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					UM
					determines
					whether the operand is in user
					space. NF allows to not
					set the flags.
				</p><p>
					RS also determine the width of the operation. There is no LE
					prefix,
					as the read and write
					widths are the same.
					Note
					that the
					default is to use BYTE-wide operation without load
					extension.
				</p><h2>BBR#</h2>
<a name="BBR#"> </a><p>Branch on bit reset</p>
<table class="optable"><tr><th colspan="10">BBR</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>QUICK</td><td>0xf</td><td>65k</td><td>AM, OF, UM, RS</td><td>ZP with branch</td><td>#0</td><td></td></tr>
<tr><td>QUICK</td><td>0x1f</td><td>65k</td><td>AM, OF, UM, RS</td><td>ZP with branch</td><td>#1</td><td></td></tr>
<tr><td>QUICK</td><td>0x2f</td><td>65k</td><td>AM, OF, UM, RS</td><td>ZP with branch</td><td>#2</td><td></td></tr>
<tr><td>QUICK</td><td>0x3f</td><td>65k</td><td>AM, OF, UM, RS</td><td>ZP with branch</td><td>#3</td><td></td></tr>
<tr><td>QUICK</td><td>0x4f</td><td>65k</td><td>AM, OF, UM, RS</td><td>ZP with branch</td><td>#4</td><td></td></tr>
<tr><td>QUICK</td><td>0x5f</td><td>65k</td><td>AM, OF, UM, RS</td><td>ZP with branch</td><td>#5</td><td></td></tr>
<tr><td>QUICK</td><td>0x6f</td><td>65k</td><td>AM, OF, UM, RS</td><td>ZP with branch</td><td>#6</td><td></td></tr>
<tr><td>QUICK</td><td>0x7f</td><td>65k</td><td>AM, OF, UM, RS</td><td>ZP with branch</td><td>#7</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Examine the operand value, and check the given bit. If the bit is cleared, branch to the given (relative)
					address.
				</p><h2>BBS#</h2>
<a name="BBS#"> </a><p>Branch on bit set</p>
<table class="optable"><tr><th colspan="10">BBS</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>QUICK</td><td>0x8f</td><td>65k</td><td>AM, OF, UM, RS</td><td>ZP with branch</td><td>#0</td><td></td></tr>
<tr><td>QUICK</td><td>0x9f</td><td>65k</td><td>AM, OF, UM, RS</td><td>ZP with branch</td><td>#1</td><td></td></tr>
<tr><td>QUICK</td><td>0xaf</td><td>65k</td><td>AM, OF, UM, RS</td><td>ZP with branch</td><td>#2</td><td></td></tr>
<tr><td>QUICK</td><td>0xbf</td><td>65k</td><td>AM, OF, UM, RS</td><td>ZP with branch</td><td>#3</td><td></td></tr>
<tr><td>QUICK</td><td>0xcf</td><td>65k</td><td>AM, OF, UM, RS</td><td>ZP with branch</td><td>#4</td><td></td></tr>
<tr><td>QUICK</td><td>0xdf</td><td>65k</td><td>AM, OF, UM, RS</td><td>ZP with branch</td><td>#5</td><td></td></tr>
<tr><td>QUICK</td><td>0xef</td><td>65k</td><td>AM, OF, UM, RS</td><td>ZP with branch</td><td>#6</td><td></td></tr>
<tr><td>QUICK</td><td>0xff</td><td>65k</td><td>AM, OF, UM, RS</td><td>ZP with branch</td><td>#7</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Examine the operand value, and check the given bit. If the bit is set, branch to the given (relative) address.
				</p><h2>BCC</h2>
<a name="BCC"> </a><p>Synonyms: BLT</p>
<p>Branch on carry clear - take branch when C flag is cleared
			</p>
<table class="optable"><tr><th colspan="10">BCC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x90</td><td></td><td>RS</td><td>Relative</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					carry status flag is clear. After a CMP this is a
					synonym for "less
					than".
					The parameter is
					a signed 8-bit value, i.e.
					jump distances can be from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand when N=1 else NextPC
				</pre><h3>65k</h3>
<p>The RS prefix determines the width of the parameter, the default
					is 8-bit.
					With a 16-bit parameter the jump
					distances can be from
					-32768 to +32767
					and so on.
				</p><h2>BCN</h2>
<a name="BCN"> </a><p>Bit Count: counts 1-bits in AC or in given location, stores
				number of 1-bits back in AC
			</p>
<table class="optable"><tr><th colspan="10">BCN</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0xb4</td><td>65k</td><td>RS, NF</td><td>Accumulator</td><td></td><td></td></tr>
</table>
<h2>BCS</h2>
<a name="BCS"> </a><p>Synonyms: BGE</p>
<p>Branch on carry set - take branch when C flag is set</p>
<table class="optable"><tr><th colspan="10">BCS</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xB0</td><td></td><td>RS</td><td>Relative</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					carry status flag is set. After a CMP this is a
					synonym for "greater or
					equal".
					The
					parameter is a signed 8-bit
					value, i.e. jump distances can be from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand when N=1 else NextPC
				</pre><h3>65k</h3>
<p>The RS prefix determines the width of the parameter, the default
					is 8-bit.
					With a 16-bit parameter the jump
					distances can be from
					-32768 to +32767
					and so on.
				</p><h2>BEQ</h2>
<a name="BEQ"> </a><p>Branch on equal - take branch when Z flag is set</p>
<table class="optable"><tr><th colspan="10">BEQ</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xf0</td><td></td><td>RS</td><td>Relative</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					zero status flag is set.
					The parameter is a signed
					8-bit value, i.e. jump distances can be
					from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand when N=1 else NextPC
				</pre><h3>65k</h3>
<p>The RS prefix determines the width of the parameter, the default
					is 8-bit.
					With a 16-bit parameter the jump
					distances can be from
					-32768 to +32767
					and so on.
				</p><h2>BEV</h2>
<a name="BEV"> </a><p>Branch on even</p>
<table class="optable"><tr><th colspan="10">BEV</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x10</td><td>65k</td><td>RS</td><td>Relative</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					if the odd
					status flag is
					set.
					The parameter is a signed 8-bit value, i.e. jump
					distances can be from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand when O=0 else NextPC
				</pre><h3>65k</h3>
<p>The RS prefix determines the width of the parameter, the default
					is 8-bit.
					With a 16-bit parameter the jump
					distances can be from
					-32768 to +32767
					and so on.
				</p><h2>BGES</h2>
<a name="BGES"> </a><p>Branch on signed greater or equal than</p>
<table class="optable"><tr><th colspan="10">BGES</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x70</td><td>65k</td><td>RS</td><td>Relative</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					if the
					signed greater or
					equal status flag G is set.
					The parameter is a
					signed 8-bit value, i.e. jump distances can be
					from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand when G=1 else NextPC
				</pre><h3>65k</h3>
<p>The RS prefix determines the width of the parameter, the default
					is 8-bit.
					With a 16-bit parameter the jump
					distances can be from
					-32768 to +32767
					and so on.
				</p><h2>BGT</h2>
<a name="BGT"> </a><p>Synonyms: (SEQ BCS)</p>
<p>Branch if greater - take branch when C flag is set but Z flag
				is
				clear
			</p>
<h3>Description</h3>
<p>
					Execute a branch given the
					condition that the
					carry status flag is set and the zero status flag
					is not set.
					Synonym to "SEQ BCS", i.e. branch on carry set, skipped if zero is set. 
				</p><h2>BGTS</h2>
<a name="BGTS"> </a><p>Synonyms: (SEQ BGES)</p>
<p>Branch if greater - take branch when signed greater or equal G
				flag is set but Z flag is clear
			</p>
<h3>Description</h3>
<p>
					Execute a branch given the
					condition that the
					signed greater status flag is set and the zero
					status flag is not set.
					Synonym to "SEQ BGES", i.e. branch on signed greater set, skipped if zero is set. 
				</p><h2>BIT</h2>
<a name="BIT"> </a><p>Bitwise test with accumulator - AND the memory location with
				the
				accumulator, and set N (=bit 7), V (=bit 7), Z
				(iff all bits
				zero) flags from the result. In case of the accumulator addressing,
				simply
				set the flags from the
				accumulator
			</p>
<table class="optable"><tr><th colspan="10">BIT</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x24</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x2c</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x34</td><td>cmos</td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x3c</td><td>cmos</td><td>AM, OF, RS, LE, UM, NF</td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x89</td><td>cmos</td><td>RS, LE, NF</td><td>Immediate</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x89</td><td>65k</td><td>RS, LE, UM, NF</td><td>E indirect</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x34</td><td>65k</td><td>RS, NF</td><td>Accumulator</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Read the operand and set the N and V flags from the value (from
					the
					highest and next-to-highest bit respectively).
					Then take the
					operand, and AND it with the accumulator and evaluate the
					Z-flag.
				</p><pre>
					N &lt;= Operand(7)
					V &lt;= Operand(6)
					Tmp &lt;=
					Operand &amp; AC
					Z &lt;= Z(Tmp)
				</pre><h3>65k</h3>
<p>
					The AM, OF, LE and RS prefixes are evaluated by the addressing
					modes.
					The UM prefix determines whether the
					operand
					resides in user
					space or not.
				</p><p>
					The NF prefix allows to implement a read-modify-write AND of a
					memory
					location (without the usual and/store
					sequence) - without
					setting a flag though.
				</p><h2>BLE</h2>
<a name="BLE"> </a><p>Branch if less or equal - take branch when C flag is clear or Z
				flag is set
			</p>
<table class="optable"><tr><th colspan="10">BLE</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x90</td><td>65k</td><td>RS</td><td>Relative</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					carry status flag is clear or the zero status flag
					is set.
					The parameter is a signed 8-bit
					value, i.e. jump distances
					can be from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand when (N=1 and Z=0) else NextPC
				</pre><h3>65k</h3>
<p>The RS prefix determines the width of the parameter, the default
					is 8-bit.
					With a 16-bit parameter the jump
					distances can be from
					-32768 to +32767
					and so on.
				</p><h2>BLES</h2>
<a name="BLES"> </a><p>Branch if less or equal - take branch when signed greater or
				equal flag G is clear or Z flag is set
			</p>
<table class="optable"><tr><th colspan="10">BLES</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0xD0</td><td>65k</td><td>RS</td><td>Relative</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					signed greater status flag is clear or the zero
					status flag is set.
					The parameter is a
					signed 8-bit value, i.e. jump
					distances can be from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand when (G=0 or Z=1) else NextPC
				</pre><h3>65k</h3>
<p>The RS prefix determines the width of the parameter, the default
					is 8-bit.
					With a 16-bit parameter the jump
					distances can be from
					-32768 to +32767
					and so on.
				</p><h2>BLTS</h2>
<a name="BLTS"> </a><p>Branch on signed less than</p>
<table class="optable"><tr><th colspan="10">BLTS</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x50</td><td>65k</td><td>RS</td><td>Relative</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					if the
					signed greater
					status or equal flag is not set.
					The parameter is a
					signed 8-bit value, i.e. jump distances can
					be from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand when G=0 else NextPC
				</pre><h3>65k</h3>
<p>The RS prefix determines the width of the parameter, the default
					is 8-bit.
					With a 16-bit parameter the jump
					distances can be from
					-32768 to +32767
					and so on.
				</p><h2>BMI</h2>
<a name="BMI"> </a><p>Branch on minus - take branch when N flag is set</p>
<table class="optable"><tr><th colspan="10">BMI</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x30</td><td></td><td>RS</td><td>Relative</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					negative status flag is set.
					The parameter is a
					signed 8-bit value, i.e. jump distances can
					be from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand when N=1 else NextPC
				</pre><h3>65k</h3>
<p>The RS prefix determines the width of the parameter, the default
					is 8-bit.
					With a 16-bit parameter the jump
					distances can be from
					-32768 to +32767
					and so on.
				</p><h2>BNE</h2>
<a name="BNE"> </a><p>Branch on not equal - take branch when Z flag is cleared</p>
<table class="optable"><tr><th colspan="10">BNE</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xD0</td><td></td><td>RS</td><td>Relative</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					zero status flag is clear.
					The parameter is a
					signed 8-bit value, i.e. jump distances can
					be from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand when N=1 else NextPC
				</pre><h3>65k</h3>
<p>The RS prefix determines the width of the parameter, the default
					is 8-bit.
					With a 16-bit parameter the jump
					distances can be from
					-32768 to +32767
					and so on.
				</p><h2>BOD</h2>
<a name="BOD"> </a><p>Branch on odd</p>
<table class="optable"><tr><th colspan="10">BOD</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x30</td><td>65k</td><td>RS</td><td>Relative</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					if the odd
					status flag is
					set.
					The parameter is a signed 8-bit value, i.e. jump
					distances can be from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand when O=1 else NextPC
				</pre><h3>65k</h3>
<p>The RS prefix determines the width of the parameter, the default
					is 8-bit.
					With a 16-bit parameter the jump
					distances can be from
					-32768 to +32767
					and so on.
				</p><h2>BPL</h2>
<a name="BPL"> </a><p>Branch on plus - take branch when N flag is cleared</p>
<table class="optable"><tr><th colspan="10">BPL</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x10</td><td></td><td>RS</td><td>Relative</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					negative status flag is clear.
					The parameter is a
					signed 8-bit value, i.e. jump distances
					can be from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand when N=1 else NextPC
				</pre><h3>65k</h3>
<p>The RS prefix determines the width of the parameter, the default
					is 8-bit.
					With a 16-bit parameter the jump
					distances can be from
					-32768 to +32767
					and so on.
				</p><h2>BRA</h2>
<a name="BRA"> </a><p>Synonyms: BRU</p>
<p>Branch always - branch independent from any flags</p>
<table class="optable"><tr><th colspan="10">BRA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x80</td><td>cmos</td><td>RS</td><td>Relative</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch (always) to the address given by adding the parameter to
					the
					address of the
					next operation (after the branch
					opcode).
					The
					parameter is a signed 8-bit value, i.e. jump distances can be from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand
				</pre><h3>65k</h3>
<p>The RS prefix determines the width of the parameter, the default
					is 8-bit.
					With a 16-bit parameter the jump
					distances can be from
					-32768 to +32767
					and so on.
				</p><h2>BRK</h2>
<a name="BRK"> </a><p>Starts the break routine.</p>
<table class="optable"><tr><th colspan="10">BRK</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x00</td><td></td><td>RS</td><td>Immediate</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					The BRK opcode is used to jump to the BRK vector. It pushes the
					return address and the status on the stack, then
					reads the BRK
					vector
					(doubling as IRQ vector) and jumps there.
				</p><p>
					Please note that the address put on the stack is the address of
					the next
					instruction. And the BRK opcode is using
					the immediate
					addressing
					mode
					(although the MOS manual does not state it). Thus the
					address put on the
					stack is two
					bytes behind the address of the BRK!
				</p><p>
					Before storing the status on the stack, the opcode sets the
					I-flag to
					avoid recursive calling of the interrupt
					routine.
				</p><p>
					When storing the status on the stack, the B-flag is set to
					indicate
					that
					the shared IRQ/BRK vector has been called
					from a BRK
					and not an IRQ.
				</p><pre>
					Stack(SP--) &lt;= > NextPC
					Stack(SP--) &lt;= &lt;
					NextPC
					Stack(SP--) &lt;= Status | B | I
					PC
					&lt;= ($FFFE)
				</pre><h3>65k</h3>
<p>
					On the 65k, the RS prefix determines the size of the immediate
					operand,
					so that the return address that is pushed
					onto the stack
					depends on
					it.
				</p><p>
					As opposed to the IRQ, the BRK opcode stays in the user resp.
					hypervisor mode
					where it is executed.
				</p><p>
					In hypervisor mode, once the processor configuration register for
					abort vector table is set,
					the BRK vector is
					taken from the abort
					vector table. For details see
					the interrupt handling
					description.
				</p><p>
					In user mode the BRK always uses the standard two-byte $FFFE IRQ
					vector, sign-expanded to
					full address length.
				</p><h2>BSR</h2>
<a name="BSR"> </a><p>Branch subroutine - similar to JSR, but use relative addressing
				similar to branch opcodes
			</p>
<table class="optable"><tr><th colspan="10">BSR</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x82</td><td>65k</td><td>AM, RS</td><td>Relative (BSR)</td><td></td><td></td></tr>
<tr><td></td><td>0x44</td><td>65k</td><td>AM, RS</td><td>Relative 16bit (BSR)</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by the operand as computed similar to
					the
					branch opcodes.
					Store the return address (-1)
					on the stack to
					prepare for the RTS
					opcode.
				</p><pre>
					Stack(SP--) &lt;= > NextPC-1
					Stack(SP--) &lt;=
					&lt; NextPC-1
					PC &lt;= NextPC + Operand
				</pre><h3>65k</h3>
<p>
					The AM prefix is evaluated by the relative addressing modes. Note
					that
					the RS prefix is
					used to determine the return
					address size on
					the stack, so it cannot be
					used as parameter width
					selector. Thus
					there are two opcodes to define 8-bit
					or 16-bit parameter
					width,
					using the AM
					prefix to make that 32- or 64-bit respectively.
				</p><p>
					Note that the UM prefix is not supported.
				</p><p>
					If the operand is not wide enough as required for an address, it
					is
					sign-extended.
				</p><p>
					The RS prefix determines the width of the return address put on
					the
					stack. Note that the
					BYTE width prefix denotes
					the natural width
					of the processor
					(respectively its current mode). This
					is the
					default.
				</p><p>
					The stack pointer used is the stack pointer of the current mode.
				</p><h2>BSW</h2>
<a name="BSW"> </a><p>Bit Swap: exchanges bit 0 with bit W-1, bit 1 with bit W-2 and
				so on.
			</p>
<table class="optable"><tr><th colspan="10">BSW</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0xf4</td><td>65k</td><td>RS, NF</td><td>Accumulator</td><td></td><td></td></tr>
</table>
<h2>BVC</h2>
<a name="BVC"> </a><p>Branch on overflow clear - take branch when V flag is cleared
			</p>
<table class="optable"><tr><th colspan="10">BVC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x50</td><td></td><td>RS</td><td>Relative</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					overflow status flag is clear.
					The parameter is a
					signed 8-bit value, i.e. jump distances
					can be from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand when N=1 else NextPC
				</pre><h3>65k</h3>
<p>The RS prefix determines the width of the parameter, the default
					is 8-bit.
					With a 16-bit parameter the jump
					distances can be from
					-32768 to +32767
					and so on.
				</p><h2>BVS</h2>
<a name="BVS"> </a><p>Branch on overflow set - take branch when V flag is set</p>
<table class="optable"><tr><th colspan="10">BVS</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x70</td><td></td><td>RS</td><td>Relative</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					overflow status flag is set.
					The parameter is a
					signed 8-bit value, i.e. jump distances can
					be from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand when N=1 else NextPC
				</pre><h3>65k</h3>
<p>The RS prefix determines the width of the parameter, the default
					is 8-bit.
					With a 16-bit parameter the jump
					distances can be from
					-32768 to +32767
					and so on.
				</p><h2>CLC</h2>
<a name="CLC"> </a><p>Clear the C flag</p>
<table class="optable"><tr><th colspan="10">CLC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x18</td><td></td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Clear the carry status flag.
				</p><h2>CLD</h2>
<a name="CLD"> </a><p>Clear the decimal (D) flag</p>
<table class="optable"><tr><th colspan="10">CLD</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xd8</td><td></td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Clear the decimal mode status flag.
				</p><h2>CLI</h2>
<a name="CLI"> </a><p>Clear the interrupt (I) flag</p>
<table class="optable"><tr><th colspan="10">CLI</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x58</td><td></td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Clear the interrupt status flag.
				</p><h3>65k</h3>
<p>
					Note that the interrupt handling is much more sophisticated in
					the 65k.
					In hypervisor mode setting the interrupt
					status flag
					disables all
					interrupts except the non-maskable interrupt.
					In user
					mode setting the interrupt status flag
					disables all "user
					level
					interrupts", but hypervisor interrupts
					are served. The interrupt
					level for user level
					interrupts can be
					configured in a configuration
					register.
				</p><h2>CLV</h2>
<a name="CLV"> </a><p>Clear the overflow (V) flag</p>
<table class="optable"><tr><th colspan="10">CLV</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xb8</td><td></td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Clear the overflow status flag.
				</p><h2>CMP</h2>
<a name="CMP"> </a><p>Compare accumulator with content of memory location</p>
<table class="optable"><tr><th colspan="10">CMP</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xc1</td><td></td><td>AM, OF, RS, UM, LE</td><td>Zeropage indexed with X indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0xc3</td><td>65k</td><td>AM, OF, RS, UM, LE</td><td>Zeropage indexed with X indirect 64bit</td><td></td><td></td></tr>
<tr><td></td><td>0xc5</td><td></td><td>AM, OF, RS, UM, LE</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0xc9</td><td></td><td>RS, LE</td><td>Immediate</td><td></td><td></td></tr>
<tr><td></td><td>0xcd</td><td></td><td>AM, OF, RS, UM, LE</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0xd1</td><td></td><td>AM, OF, RS, UM, LE</td><td>Zeropage indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0xd2</td><td>cmos_indz</td><td>AM, OF, RS, UM, LE</td><td>Zeropage indirect 16bit indexed with Z</td><td></td><td></td></tr>
<tr><td></td><td>0xd3</td><td>65k</td><td>AM, OF, RS, UM, LE</td><td>Zeropage indirect 64bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0xd7</td><td>65k</td><td>AM, OF, RS, UM, LE</td><td>Zeropage indirect 64bit indexed with Z</td><td></td><td></td></tr>
<tr><td></td><td>0xd5</td><td></td><td>AM, OF, RS, UM, LE</td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0xd9</td><td></td><td>AM, OF, RS, UM, LE</td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0xdd</td><td></td><td>AM, OF, RS, UM, LE</td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xc9</td><td>65k</td><td>RS, UM, LE</td><td>E indirect</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Compare the operand with the accumulator and set the flags
					appropriately.
					I.e. substract the operand from AC with
					an
					implicitely set carry in
					binary mode (even if
					decimal mode status bit
					is set), and set the flags from the result.
				</p><pre>
					Tmp, C &lt;= Y - Operand, C=1
					N &lt;= Tmp(7)
					Z &lt;=
					Z(Tmp)
				</pre><h3>65k</h3>
<p>
					The AM, OF, LE and RS prefixes are evaluated by the addressing
					modes.
					UM determines
					whether the operand is in user
					space.
				</p><p>
					Note that the default is to use BYTE-wide operation without load
					extension.
				</p><h2>CPX</h2>
<a name="CPX"> </a><p>Compare X register with content of memory location</p>
<table class="optable"><tr><th colspan="10">CPX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xe0</td><td></td><td>RS, LE</td><td>Immediate</td><td></td><td></td></tr>
<tr><td></td><td>0xe4</td><td></td><td>AM, OF, RS, UM, LE</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0xec</td><td></td><td>AM, OF, RS, UM, LE</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xe0</td><td>65k</td><td>RS, UM, LE</td><td>E indirect</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Compare the operand with the X register and set the flags
					appropriately.
					I.e. substract the operand from X with an
					implicitly
					set carry in
					binary mode (even if
					decimal mode status bit is set),
					and set the flags from the result.
				</p><pre>
					Tmp, C &lt;= X - Operand, C=1
					N &lt;= Tmp(7)
					Z &lt;=
					Z(Tmp)
				</pre><h3>65k</h3>
<p>
					The AM, OF, LE and RS prefixes are evaluated by the addressing
					modes.
					UM determines
					whether the operand is in user
					space.
				</p><p>
					Note that the default is to use BYTE-wide operation without load
					extension.
				</p><h2>CPY</h2>
<a name="CPY"> </a><p>Compare Y register with content of memory location</p>
<table class="optable"><tr><th colspan="10">CPY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xc0</td><td></td><td>RS, LE</td><td>Immediate</td><td></td><td></td></tr>
<tr><td></td><td>0xc4</td><td></td><td>AM, OF, RS, UM, LE</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0xcc</td><td></td><td>AM, OF, RS, UM, LE</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xc0</td><td>65k</td><td>RS, UM, LE</td><td>E indirect</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Compare the operand with the Y register and set the flags
					appropriately.
					I.e. substract the operand from Y with an
					implicitly
					set carry in
					binary mode (even if
					decimal mode status bit is set),
					and set the flags from the result.
				</p><pre>
					Tmp, C &lt;= Y - Operand, C=1
					N &lt;= Tmp(7)
					Z &lt;=
					Z(Tmp)
				</pre><h3>65k</h3>
<p>
					The AM, OF, LE and RS prefixes are evaluated by the addressing
					modes.
					UM determines
					whether the operand is in user
					space.
				</p><p>
					Note that the default is to use BYTE-wide operation without load
					extension.
				</p><h2>CPZ</h2>
<a name="CPZ"> </a><p>Compare Z register with content of memory location</p>
<table class="optable"><tr><th colspan="10">CPZ</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0xd9</td><td>65k</td><td>RS, LE</td><td>Immediate</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xe6</td><td>65k</td><td>AM, OF, RS, UM, LE</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xdc</td><td>65k</td><td>AM, OF, RS, UM, LE</td><td>Absolute 16bit</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Compare the operand with the Z register and set the flags
					appropriately.
					I.e. substract the operand from Z with an
					implicitly
					set carry in
					binary mode (even if
					decimal mode status bit is set),
					and set the flags from the result.
				</p><pre>
					Tmp, C &lt;= Z - Operand, C=1
					N &lt;= Tmp(7)
					Z &lt;=
					Z(Tmp)
				</pre><h3>65k</h3>
<p>
					The AM, OF, LE and RS prefixes are evaluated by the addressing
					modes.
					UM determines
					whether the operand is in user
					space.
				</p><p>
					Note that the default is to use BYTE-wide operation without load
					extension.
				</p><h2>CSW</h2>
<a name="CSW"> </a><p>Compare and SWap - compare memory with AC, and if matches, set to value from XR. AC is loaded with the value from the memory location.
			</p>
<table class="optable"><tr><th colspan="10">CSW</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0xcc</td><td>65k</td><td>UM, RS</td><td>E indirect</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xc6</td><td>65k</td><td>UM, RS, AM</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xd6</td><td>65k</td><td>UM, RS, AM</td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xc1</td><td>65k</td><td>UM, RS, AM</td><td>Zeropage indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xde</td><td>65k</td><td>UM, RS, AM</td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
</table>
<h2>DAD</h2>
<a name="DAD"> </a><p>Decimal adjust of a normal ADC of two BCD numbers.</p>
<table class="optable"><tr><th colspan="10">DAD</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x1a</td><td>65k</td><td>RS, NF</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>Adjust the result of an ADC operation to BCD format. For example
					adding $14 and $08 with ADC (and C=0) gives $1c
					in normal mode.
					As
					an addition of two BCD numbers this should be $22 instead. DAD
					adjusts the non-BCD result back into
					a BCD result.
					DAD only works on
					the accumulator, i.e. takes the value from there and
					stores the
					result there.
					Set the
					flags from the result. The decimal flag is
					ignored. C is set
					when the decimal adjust overflows. V is not
					affected.
				</p><pre>
					AC, C &lt;= DecimalAdjustAdd(AC)
					N &lt;= Tmp(7)
					Z &lt;= Z(Tmp)
				</pre><h2>DAS</h2>
<a name="DAS"> </a><p>Decimal adjust of a normal SBC of two BCD numbers.</p>
<table class="optable"><tr><th colspan="10">DAS</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x3a</td><td>65k</td><td>RS, NF</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>Adjust the result of an SBC operation to BCD format. For example
					substracting $08 from $24 with SBC (and C=1)
					gives $1c in normal
					mode.
					As a substraction of two BCD numbers this should be $16
					instead. DAD
					adjusts the non-BCD
					result back into a BCD result.
					DAD
					only works on the accumulator, i.e. takes the value from there and
					stores the
					result there.
					Set the flags from the result. The decimal
					flag is ignored. C is set
					when the decimal adjust overflows.
					V is
					not affected.
				</p><pre>
					AC, C &lt;= DecimalAdjustSub(AC)
					N &lt;= Tmp(7)
					Z &lt;= Z(Tmp)
				</pre><h2>DEC</h2>
<a name="DEC"> </a><p>Decrement the content of a memory location by one</p>
<table class="optable"><tr><th colspan="10">DEC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xc6</td><td></td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x3a</td><td>cmos</td><td>RS, NF</td><td>Accumulator</td><td></td><td></td></tr>
<tr><td></td><td>0xce</td><td></td><td>AM, OF, RS, UM, NF</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0xd6</td><td></td><td>AM, OF, RS, UM, NF</td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0xde</td><td></td><td>AM, OF, RS, UM, NF</td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xcf</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xcd</td><td>65k</td><td>RS, UM, NF</td><td>E indirect</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Decrement the operand by one, i.e. binary substract one.
					Note this
					opcode is a read-modify-write opcode and not
					only has
					memory-oriented addressing modes but can work
					on the accumulator
					alone as well.
				</p><pre>
					Operand &lt;= Operand - 1
					N &lt;= OperandC7)
					Z &lt;=
					Z(AC)
				</pre><h3>65k</h3>
<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					UM
					determines
					whether the operand is in user
					space. NF allows to not
					set the flags.
				</p><p>
					RS also determine the width of the operation. There is no LE
					prefix,
					as the read and write
					widths are the same.
					Note
					that the
					default is to use BYTE-wide operation without load
					extension.
				</p><h2>DEX</h2>
<a name="DEX"> </a><p>Decrement the content of the X register by one</p>
<table class="optable"><tr><th colspan="10">DEX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xca</td><td></td><td>RS, NF</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Decrement the X register by one (binary).
				</p><pre>
					X &lt;= X-1
				</pre><h3>65k</h3>
<p>
					The RS prefix determines the width of the operation. The NF flag
					allows
					to perform the operation
					without setting
					flags.
				</p><h2>DEY</h2>
<a name="DEY"> </a><p>Decrement the Y register by one</p>
<table class="optable"><tr><th colspan="10">DEY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x88</td><td></td><td>RS, NF</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Decrement the Y register by one (binary).
				</p><pre>
					Y &lt;= Y-1
				</pre><h3>65k</h3>
<p>
					The RS prefix determines the width of the operation. The NF flag
					allows
					to perform the operation
					without setting
					flags.
				</p><h2>DEZ</h2>
<a name="DEZ"> </a><p>Decrement Z register</p>
<table class="optable"><tr><th colspan="10">DEZ</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x38</td><td>cmos_indz</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h2>EOR</h2>
<a name="EOR"> </a><p>Bitwise Exclusive-OR accumulator with content of memory
				location
			</p>
<table class="optable"><tr><th colspan="10">EOR</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x41</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indexed with X indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x43</td><td>65k</td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indexed with X indirect 64bit</td><td></td><td></td></tr>
<tr><td></td><td>0x45</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x49</td><td></td><td>RS, LE, NF</td><td>Immediate</td><td></td><td></td></tr>
<tr><td></td><td>0x4d</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x51</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x52</td><td>cmos_indz</td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indirect 16bit indexed with Z</td><td></td><td></td></tr>
<tr><td></td><td>0x53</td><td>65k</td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indirect 64bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x55</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x57</td><td>65k</td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indirect 64bit indexed with Z</td><td></td><td></td></tr>
<tr><td></td><td>0x59</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x5d</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x49</td><td>65k</td><td>RS, LE, UM, NF</td><td>E indirect</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Bitwise Exclusive-OR the accumulator with the operand and store
					back in
					the
					accumulator.
					Set the flags from the
					result.
				</p><pre>
					AC &lt;= AC ^ Operand
					N &lt;= Tmp(7)
					Z &lt;= Z(Tmp)
				</pre><h3>65k</h3>
<p>
					The AM, OF, LE and RS prefixes are evaluated by the addressing
					modes.
					UM determines
					whether the operand is in user
					space. NF allows
					to not set the flags.
				</p><p>
					RS and LE together also determine the width of the operation.
					Note that the default is to use BYTE-wide operation
					without load
					extension.
				</p><h2>EXT</h2>
<a name="EXT"> </a><p>Extend a value in AC from RS to the full size. Setting LE
				defines the type of extension.
			</p>
<table class="optable"><tr><th colspan="10">EXT</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0xc4</td><td>65k</td><td>RS, NF</td><td>Accumulator</td><td></td><td></td></tr>
</table>
<h2>INC</h2>
<a name="INC"> </a><p>Increment the content of a memory location by one</p>
<table class="optable"><tr><th colspan="10">INC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xe6</td><td></td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x1a</td><td>cmos</td><td>RS, NF</td><td>Accumulator</td><td></td><td></td></tr>
<tr><td></td><td>0xee</td><td></td><td>AM, OF, RS, UM, NF</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0xf6</td><td></td><td>AM, OF, RS, UM, NF</td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0xfe</td><td></td><td>AM, OF, RS, UM, NF</td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xef</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xed</td><td>65k</td><td>RS, UM, NF</td><td>E indirect</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Increment the operand by one, i.e. binary add one.
					Note this
					opcode is a read-modify-write opcode and not only has
					memory-oriented addressing modes but can work
					on the accumulator
					alone as well.
				</p><pre>
					Operand &lt;= Operand + 1
					N &lt;= OperandC7)
					Z &lt;=
					Z(AC)
				</pre><h3>65k</h3>
<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					UM
					determines
					whether the operand is in user
					space. NF allows to not
					set the flags.
				</p><p>
					RS also determine the width of the operation. There is no LE
					prefix,
					as the read and write
					widths are the same.
					Note
					that the
					default is to use BYTE-wide operation without load
					extension.
				</p><h2>INV</h2>
<a name="INV"> </a><p>Invert AC, i.e. set AC to the 1s-complement of AC</p>
<table class="optable"><tr><th colspan="10">INV</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x54</td><td>65k</td><td>RS, NF</td><td>Accumulator</td><td></td><td></td></tr>
</table>
<h2>INX</h2>
<a name="INX"> </a><p>Increment the content of the X register by one</p>
<table class="optable"><tr><th colspan="10">INX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xe8</td><td></td><td>RS, NF</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Increment the X register by one (binary).
				</p><pre>
					X &lt;= X+1
				</pre><h3>65k</h3>
<p>
					The RS prefix determines the width of the operation. The NF flag
					allows
					to perform the operation
					without setting
					flags.
				</p><h2>INY</h2>
<a name="INY"> </a><p>Increment the content of the Y register by one</p>
<table class="optable"><tr><th colspan="10">INY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xc8</td><td></td><td>RS, NF</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Increment the Y register by one (binary).
				</p><pre>
					Y &lt;= Y+1
				</pre><h3>65k</h3>
<p>
					The RS prefix determines the width of the operation. The NF flag
					allows
					to perform the operation
					without setting
					flags.
				</p><h2>INZ</h2>
<a name="INZ"> </a><p>Increment Z register</p>
<table class="optable"><tr><th colspan="10">INZ</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x18</td><td>cmos_indz</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h2>JMP</h2>
<a name="JMP"> </a><p>Jump to new code address</p>
<table class="optable"><tr><th colspan="10">JMP</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x07</td><td>65k</td><td>AM, OF, UM, LE</td><td>Absolute indirect 64bit</td><td></td><td></td></tr>
<tr><td></td><td>0x27</td><td>65k</td><td>AM, OF, UM, LE</td><td>Absolute indexed with X indirect 64bit</td><td></td><td></td></tr>
<tr><td></td><td>0x4c</td><td></td><td>AM, OF, UM, LE</td><td>Address</td><td></td><td></td></tr>
<tr><td></td><td>0x6c</td><td></td><td>AM, OF, UM, LE</td><td>Absolute indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x7c</td><td>cmos</td><td>AM, OF, UM, LE</td><td>Absolute indexed with X indirect 16bit</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x4c</td><td>65k</td><td>UM, LE</td><td>E indirect</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x6c</td><td>65k</td><td>AM, OF, UM, LE</td><td>Address Long</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Jump to the address given by the operand (as computed depending
					on the
					respective addressing mode).
				</p><pre>
					PC &lt;= Operand
				</pre><h3>65k</h3>
<p>The AM, OF, LE and UM prefixes are evaluated by the addressing
					modes.
					Note that if UM is set, then the processor
					jumps into user
					mode.
				<pre>
					Status |= U when UM is set
				</pre>
				</p><p>
					If the operand is not as wide as required for an address, it is
					sign-extended.
				</p><h2>JSR</h2>
<a name="JSR"> </a><p>Jump subroutine - jump to a new code location, save return
				address on stack for RTS
			</p>
<table class="optable"><tr><th colspan="10">JSR</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x20</td><td></td><td>AM, OF, RS, LE</td><td>Address</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x5c</td><td>65k</td><td>AM, OF, RS, LE</td><td>Address Long</td><td></td><td></td></tr>
<tr><td></td><td>0xdc</td><td>65k</td><td>AM, OF, RS, LE</td><td>Absolute indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0xfc</td><td>65k</td><td>AM, OF, RS, LE</td><td>Absolute indexed with X indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x87</td><td>65k</td><td>AM, OF, RS, LE</td><td>Absolute indirect 64bit</td><td></td><td></td></tr>
<tr><td></td><td>0xa7</td><td>65k</td><td>AM, OF, RS, LE</td><td>Absolute indexed with X indirect 64bit</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x20</td><td>65k</td><td>RS, LE</td><td>E indirect</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Jump to the address given by the operand (as computed depending
					on the
					respective addressing mode) and
					store the
					return address (-1)
					on the stack to prepare for the RTS opcode
				</p><pre>
					Stack(SP--) &lt;= > NextPC-1
					Stack(SP--) &lt;=
					&lt; NextPC-1
					PC &lt;= Operand
				</pre><h3>65k</h3>
<p>
					The AM, OF, and LE prefixes are evaluated by the addressing
					modes.
					Note that the UM prefix is not supported.
				</p><p>
					If the operand is not wide enough as required for an address, it
					is
					sign-extended.
				</p><p>
					The RS prefix determines the width of the return address put on
					the
					stack. Note that the
					BYTE width prefix denotes
					the natural width
					of the processor
					(respectively its current mode).
				</p><p>
					The stack pointer used is the stack pointer of the current mode.
				</p><h2>LDA</h2>
<a name="LDA"> </a><p>Load accumulator</p>
<table class="optable"><tr><th colspan="10">LDA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x02</td><td>65k</td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x42</td><td>65k</td><td>AM, OF, RS, LE, UM, NF</td><td>Absolute indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x47</td><td>65k</td><td>AM, OF, RS, LE, UM, NF</td><td>Absolute indirect 64bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x62</td><td>65k</td><td>AM, OF, RS, LE, UM, NF</td><td>Absolute indexed with X indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x67</td><td>65k</td><td>AM, OF, RS, LE, UM, NF</td><td>Absolute indexed with X indirect 64bit</td><td></td><td></td></tr>
<tr><td></td><td>0xa1</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indexed with X indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0xa3</td><td>65k</td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indexed with X indirect 64bit</td><td></td><td></td></tr>
<tr><td></td><td>0xa5</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0xa9</td><td></td><td>RS, LE, NF</td><td>Immediate</td><td></td><td></td></tr>
<tr><td></td><td>0xad</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0xb1</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0xb2</td><td>cmos_indz</td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indirect 16bit indexed with Z</td><td></td><td></td></tr>
<tr><td></td><td>0xb3</td><td>65k</td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indirect 64bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0xb5</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0xb7</td><td>65k</td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indirect 64bit indexed with Z</td><td></td><td></td></tr>
<tr><td></td><td>0xb9</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0xbd</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xa9</td><td>65k</td><td>RS, LE, UM, NF</td><td>E indirect</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x81</td><td>65k</td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indirect 16bit indexed with byte offset</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x41</td><td>65k</td><td>AM, OF, RS, LE, UM, NF</td><td>Absolute indirect 16bit indexed with byte offset</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x82</td><td>65k</td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indirect 64bit indexed with byte offset</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x42</td><td>65k</td><td>AM, OF, RS, LE, UM, NF</td><td>Absolute indirect 64bit indexed with byte offset</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Read the operand and store it in the Accumulator. Set the flags
					appropriately.
				</p><pre>
					N &lt;= Operand(7)
					Z &lt;= Z(Operand)
					Y &lt;= Operand
				</pre><h3>65k</h3>
<p>
					The AM, OF, LE and RS prefixes are evaluated by the addressing
					modes.
					The UM prefix determines whether the
					operand
					resides in user
					space or not.
				</p><p>
					Note that the default load extension is "zero-extended", to "not
					surprise" programmers.
				</p><p>
					The NF prefix lets the flags unmodified.
				</p><h2>LDB</h2>
<a name="LDB"> </a><p>Load B with an immediate value</p>
<table class="optable"><tr><th colspan="10">LDB</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x59</td><td>65k</td><td>RS, LE, NF</td><td>Immediate</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Read the operand and store it in the B register. Set the flags
					appropriately.
				</p><pre>
					N &lt;= Operand(7)
					Z &lt;= Z(Operand)
					B &lt;= Operand
				</pre><h3>65k</h3>
<p>
					The LE and RS prefixes are evaluated by the addressing modes.
				</p><p>
					Note that the default load extension is "sign-extended".
				</p><p>
					The NF prefix lets the flags unmodified.
				</p><h2>LDE</h2>
<a name="LDE"> </a><p>Load E with an immediate value</p>
<table class="optable"><tr><th colspan="10">LDE</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x39</td><td>65k</td><td>RS, LE, NF</td><td>Immediate</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Read the operand and store it in the E register. Set the flags
					appropriately.
				</p><pre>
					N &lt;= Operand(7)
					Z &lt;= Z(Operand)
					E &lt;= Operand
				</pre><h3>65k</h3>
<p>
					The LE and RS prefixes are evaluated by the addressing modes.
				</p><p>
					Note that the default load extension is "sign-extended".
				</p><p>
					The NF prefix lets the flags unmodified.
				</p><h2>LDX</h2>
<a name="LDX"> </a><p>Load X register</p>
<table class="optable"><tr><th colspan="10">LDX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xa2</td><td></td><td>RS, LE, NF</td><td>Immediate</td><td></td><td></td></tr>
<tr><td></td><td>0xa6</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0xae</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0xb6</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0xbe</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xad</td><td>65k</td><td>RS, LE, UM, NF</td><td>E indirect</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Read the operand and store it in the X register. Set the flags
					appropriately.
				</p><pre>
					N &lt;= Operand(7)
					Z &lt;= Z(Operand)
					X &lt;= Operand
				</pre><h3>65k</h3>
<p>
					The AM, OF, LE and RS prefixes are evaluated by the addressing
					modes.
					The UM prefix determines whether the
					operand
					resides in user
					space or not.
				</p><p>
					Note that the default load extension is "zero-extended", to "not
					surprise" programmers.
				</p><p>
					The NF prefix lets the flags unmodified.
				</p><h2>LDY</h2>
<a name="LDY"> </a><p>Load Y register</p>
<table class="optable"><tr><th colspan="10">LDY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xa0</td><td></td><td>RS, LE, NF</td><td>Immediate</td><td></td><td></td></tr>
<tr><td></td><td>0xa4</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0xac</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0xb4</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0xbc</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xa0</td><td>65k</td><td>RS, LE, UM, NF</td><td>E indirect</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Read the operand and store it in the Y register. Set the flags
					appropriately.
				</p><pre>
					N &lt;= Operand(7)
					Z &lt;= Z(Operand)
					Y &lt;= Operand
				</pre><h3>65k</h3>
<p>
					The AM, OF, LE and RS prefixes are evaluated by the addressing
					modes.
					The UM prefix determines whether the
					operand
					resides in user
					space or not.
				</p><p>
					Note that the default load extension is "zero-extended", to "not
					surprise" programmers.
				</p><p>
					The NF prefix lets the flags unmodified.
				</p><h2>LDZ</h2>
<a name="LDZ"> </a><p>Load Z register with a value</p>
<table class="optable"><tr><th colspan="10">LDZ</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x99</td><td>cmos_indz</td><td></td><td>Immediate</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xbc</td><td>cmos_indz</td><td></td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xac</td><td>cmos_indz</td><td></td><td>Absolute 16bit</td><td></td><td></td></tr>
</table>
<h2>LEA</h2>
<a name="LEA"> </a><p>Load Effective Address: compute the effective address and store
				it in the E (effective Address) register (always
				full width)
			</p>
<table class="optable"><tr><th colspan="10">LEA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0xf6</td><td>65k</td><td>AM, OF, UM, NF</td><td>Zeropage indexed with Y</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x61</td><td>65k</td><td>AM, OF, UM, NF</td><td>Absolute indirect 64bit indexed with Y</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x71</td><td>65k</td><td>AM, OF, UM, NF</td><td>Absolute indexed with X indirect 64bit</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x21</td><td>65k</td><td>AM, OF, UM, NF</td><td>Absolute indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x31</td><td>65k</td><td>AM, OF, UM, NF</td><td>Absolute indexed with X indirect 16bit</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x11</td><td>65k</td><td>AM, OF, UM, NF</td><td>Relative</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xa1</td><td>65k</td><td>AM, OF, UM, NF</td><td>Zeropage indexed with X indirect 16bit</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x46</td><td>65k</td><td>AM, OF, UM, NF</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xae</td><td>65k</td><td>AM, OF, UM, NF</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xb1</td><td>65k</td><td>AM, OF, UM, NF</td><td>Zeropage indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xb2</td><td>65k</td><td>AM, OF, UM, NF</td><td>Zeropage indirect 16bit indexed with Z</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x32</td><td>65k</td><td>AM, OF, UM, NF</td><td>Absolute indirect 16bit</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xf2</td><td>65k</td><td>AM, OF, UM, NF</td><td>Zeropage indirect 64bit indexed with Z</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x72</td><td>65k</td><td>AM, OF, UM, NF</td><td>Absolute indirect 64bit</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x56</td><td>65k</td><td>AM, OF, UM, NF</td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xbf</td><td>65k</td><td>AM, OF, UM, NF</td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xbe</td><td>65k</td><td>AM, OF, UM, NF</td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x12</td><td>65k</td><td>AM, OF, UM, NF</td><td>Relative 16bit</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xe1</td><td>65k</td><td>AM, OF, UM, NF</td><td>Zeropage indirect 64bit indexed with Y</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xf1</td><td>65k</td><td>AM, OF, UM, NF</td><td>Zeropage indexed with X indirect 64bit</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xa2</td><td>65k</td><td>AM, OF, UM, NF</td><td>Zeropage indirect 16bit indexed with byte offset</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xe2</td><td>65k</td><td>AM, OF, UM, NF</td><td>Zeropage indirect 64bit indexed with byte offset</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x22</td><td>65k</td><td>AM, OF, UM, NF</td><td>Absolute indirect 16bit indexed with byte offset</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x62</td><td>65k</td><td>AM, OF, UM, NF</td><td>Absolute indirect 64bit indexed with byte offset</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Load the effective address given by the addressing mode into the
					E
					register (without accessing
					the memory pointed to
					by the
					parameter).
				</p><pre>
					E &lt;= EffectiveAddress
				</pre><h3>65k</h3>
<p>
					The value stored in E is always in the natural (full) width of
					the
					processor.
				</p><p>
					The AM and OF prefixes are interpreted as usually when computing
					the
					address.
				</p><p>
					The memory and stack pointers used are the current ones when the
					user
					mode prefix is not set.
					When the user mode
					prefix is set in
					hypervisor mode, the memory and
					stack pointer is that of the
					user
					mode. When set in user mode an ABORT
					is triggered.
				</p><p>
					With this approach you can use this in trap handling:
				</p><pre>
					LEA.U S,$08 ; load user space address of offset 8 on the user
					mode stack
					LDA.U (E) ; load the value from user
					space
				</pre><h2>LSR</h2>
<a name="LSR"> </a><p>Logical Shift Right - shift accumulator one bit to the right,
				shifting in zero in the highest bit
			</p>
<table class="optable"><tr><th colspan="10">LSR</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x46</td><td></td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x4a</td><td></td><td>RS, NF</td><td>Accumulator</td><td></td><td></td></tr>
<tr><td></td><td>0x4e</td><td></td><td>AM, OF, RS, UM, NF</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x56</td><td></td><td>AM, OF, RS, UM, NF</td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x5e</td><td></td><td>AM, OF, RS, UM, NF</td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x4f</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x4d</td><td>65k</td><td>RS, UM, NF</td><td>E indirect</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Shift the operand or accumulator right one bit (i.e. divide by
					2). Shift
					in a zero from the left.
					The bit shifted
					out is moved into
					the carry flag.
					Note this opcode is a read-modify-write opcode and
					not only has
					memory-oriented
					addressing modes but can work
					on the
					accumulator alone as well.
				</p><pre>
					C &lt;= AC(0)
					AC(6-0) &lt;= AC(7-1)
					AC(7) &lt;= 0
					N
					&lt;= AC7)
					Z &lt;= Z(AC)
				</pre><h3>65k</h3>
<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					UM
					determines
					whether the operand is in user
					space. NF allows to not
					set the flags.
				</p><p>
					RS also determine the width of the operation. There is no LE
					prefix,
					as the read and write
					widths are the same.
					Note
					that the
					default is to use BYTE-wide operation without load
					extension.
				</p><h2>NEG</h2>
<a name="NEG"> </a><p>negate AC, i.e. set AC to the 2s-complement of AC</p>
<table class="optable"><tr><th colspan="10">NEG</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0xd4</td><td>65k</td><td>RS, NF</td><td>Accumulator</td><td></td><td></td></tr>
</table>
<h2>NOP</h2>
<a name="NOP"> </a><p>No operation</p>
<table class="optable"><tr><th colspan="10">NOP</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xea</td><td></td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					No Operation.
				</p><h2>ORA</h2>
<a name="ORA"> </a><p>Bitwise OR accumulator with content of memory location</p>
<table class="optable"><tr><th colspan="10">ORA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x01</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indexed with X indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x03</td><td>65k</td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indexed with X indirect 64bit</td><td></td><td></td></tr>
<tr><td></td><td>0x05</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x09</td><td></td><td>RS, LE, NF</td><td>Immediate</td><td></td><td></td></tr>
<tr><td></td><td>0x0d</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x11</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x12</td><td>cmos_indz</td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indirect 16bit indexed with Z</td><td></td><td></td></tr>
<tr><td></td><td>0x13</td><td>65k</td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indirect 64bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x15</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x17</td><td>65k</td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indirect 64bit indexed with Z</td><td></td><td></td></tr>
<tr><td></td><td>0x19</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x1d</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x09</td><td>65k</td><td>RS, LE, UM, NF</td><td>E indirect</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Bitwise OR the accumulator with the operand and store back in the
					accumulator.
					Set the flags from the result.
				</p><pre>
					AC &lt;= AC | Operand
					N &lt;= Tmp(7)
					Z &lt;= Z(Tmp)
				</pre><h3>65k</h3>
<p>
					The AM, OF, LE and RS prefixes are evaluated by the addressing
					modes.
					UM determines
					whether the operand is in user
					space. NF allows
					to not set the flags.
				</p><p>
					RS and LE together also determine the width of the operation.
					Note that the default is to use BYTE-wide operation
					without load
					extension.
				</p><h2>PHA</h2>
<a name="PHA"> </a><p>Push contents of the accumulator onto the stack</p>
<table class="optable"><tr><th colspan="10">PHA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x48</td><td></td><td>RS, UM</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Push the content of the accumulator on the stack.
				</p><pre>
					Stack(SP--) &lt;= A
				</pre><h3>65k</h3>
<p>
					The RS prefix determines the width of the accumulator value as
					written
					on the stack.
				</p><p>
					The stack pointer used is the one of the current stack if the UM
					prefix
					is not set.
					If UM is set and the opcode is
					executed in
					hypervisor mode, the stack
					pointer used is the
					user mode stack
					pointer and the value is stored in user mode
					memory. If
					executed in
					user mode with UM set an ABORT exception is triggered.
				</p><h2>PHB</h2>
<a name="PHB"> </a><p>Push B onto stack (full width)</p>
<table class="optable"><tr><th colspan="10">PHB</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x48</td><td>65k</td><td>UM</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Push the content of the B register on the stack.
				</p><pre>
					Stack(SP--) &lt;= B
				</pre><h3>65k</h3>
<p>
					The value stored is always in the natural width of the processor
					(mode).
				</p><p>
					The stack pointer used is the one of the current stack if the UM
					prefix
					is not set.
					If UM is set and the opcode is
					executed in
					hypervisor mode, the stack
					pointer used is the
					user mode stack
					pointer and the value is stored in user mode
					memory. If
					executed in
					user mode with UM set an ABORT exception is triggered.
				</p><h2>PHE</h2>
<a name="PHE"> </a><p>Push E onto stack (always full width)</p>
<table class="optable"><tr><th colspan="10">PHE</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x08</td><td>65k</td><td>UM</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Push the content of the E register on the stack.
				</p><pre>
					Stack(SP--) &lt;= E
				</pre><h3>65k</h3>
<p>
					The value stored is always in the natural width of the processor
					(mode).
				</p><p>
					The stack pointer used is the one of the current stack if the UM
					prefix
					is not set.
					If UM is set and the opcode is
					executed in
					hypervisor mode, the stack
					pointer used is the
					user mode stack
					pointer and the value is stored in user mode
					memory. If
					executed in
					user mode with UM set an ABORT exception is triggered.
				</p><h2>PHI</h2>
<a name="PHI"> </a><p>Push immediate value onto the stack</p>
<table class="optable"><tr><th colspan="10">PHI</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0xd2</td><td>65k</td><td>RS, LE</td><td>Immediate</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Push the immediate value following the opcode on the stack.
				</p><pre>
					Stack(SP--) &lt;= #operand
				</pre><p>
					The RS prefix determines the width of the value as
					written on the stack.
					If LE is set, then RS determines the width of the operand following the opcode, 
					the value is then pushed in full register width after Load Expansion.
				</p><p>
					The stack pointer used is the one of the current stack if the UM
					prefix
					is not set.
					If UM is set and the opcode is
					executed in
					hypervisor mode, the stack
					pointer used is the
					user mode stack
					pointer and the value is stored in user mode
					memory. If
					executed in
					user mode with UM set an ABORT exception is triggered.
				</p><h2>PHM</h2>
<a name="PHM"> </a><p>Push contents of multiple registers onto the stack</p>
<table class="optable"><tr><th colspan="10">PHM</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x44</td><td>65k</td><td>RS, UM</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Push the content of multiple registers on the stack.  
				</p><pre>
					Stack(SP--) &lt;= A
					Stack(SP--) &lt;= B
					Stack(SP--) &lt;= E
					Stack(SP--) &lt;= X
					Stack(SP--) &lt;= Y
					Stack(SP--) &lt;= Z
				</pre><p>
					The RS prefix determines the width of the accumulator value as
					written
					on the stack.
				</p><p>
					The stack pointer used is the one of the current stack if the UM
					prefix
					is not set.
					If UM is set and the opcode is
					executed in
					hypervisor mode, the stack
					pointer used is the
					user mode stack
					pointer and the value is stored in user mode
					memory. If
					executed in
					user mode with UM set an ABORT exception is triggered.
				</p><h2>PHP</h2>
<a name="PHP"> </a><p>Push processor status register onto the stack</p>
<table class="optable"><tr><th colspan="10">PHP</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x08</td><td></td><td>UM, RS</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Push the standard status register on the stack.
				</p><pre>
					Stack(SP--) &lt;= Status
				</pre><h3>65k</h3>
<p>
					The stack pointer used is the one of the current stack if the UM
					prefix
					is not set.
					If UM is set and the opcode is
					executed in
					hypervisor mode, the stack
					pointer used is the
					user mode stack
					pointer and the value is stored in user mode
					memory. If
					executed in
					user mode with UM set an ABORT exception is triggered.
				</p><p>
					The not-extended bit is set (so the status is compatible with the
					6502
					and would denote a
					standard stack frame) as
					long as RS is 00.
				</p><p>
					If RS indicates a word-wide push, the G and OE flags of the
					extended
					status registers are
					pushed (with all other
					bits zero)
					before the standard status register.
					The
					standard status
					register has
					the not-extended bit cleared in this
					case.
				</p><p>
					RS set to long or quad lengths are illegal and trap into an
					ABORT.
				</p><h2>PHX</h2>
<a name="PHX"> </a><p>Push contents of the X register onto the stack</p>
<table class="optable"><tr><th colspan="10">PHX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xda</td><td>cmos</td><td>RS, UM</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Push the content of the X register on the stack.
				</p><pre>
					Stack(SP--) &lt;= X
				</pre><h3>65k</h3>
<p>
					The RS prefix determines the width of the accumulator value as
					written
					on the stack.
				</p><p>
					The stack pointer used is the one of the current stack if the UM
					prefix
					is not set.
					If UM is set and the opcode is
					executed in
					hypervisor mode, the stack
					pointer used is the
					user mode stack
					pointer and the value is stored in user mode
					memory. If
					executed in
					user mode with UM set an ABORT exception is triggered.
				</p><h2>PHY</h2>
<a name="PHY"> </a><p>Push contents of the Y register onto the stack</p>
<table class="optable"><tr><th colspan="10">PHY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x5a</td><td>cmos</td><td>RS, UM</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Push the content of the Y register on the stack.
				</p><pre>
					Stack(SP--) &lt;= Y
				</pre><h3>65k</h3>
<p>
					The RS prefix determines the width of the accumulator value as
					written
					on the stack.
				</p><p>
					The stack pointer used is the one of the current stack if the UM
					prefix
					is not set.
					If UM is set and the opcode is
					executed in
					hypervisor mode, the stack
					pointer used is the
					user mode stack
					pointer and the value is stored in user mode
					memory. If
					executed in
					user mode with UM set an ABORT exception is triggered.
				</p><h2>PHZ</h2>
<a name="PHZ"> </a><p>Push Z Register onto stack</p>
<table class="optable"><tr><th colspan="10">PHZ</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x5a</td><td>cmos_indz</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h2>PLA</h2>
<a name="PLA"> </a><p>Pull the contents of the accumulator from the stack</p>
<table class="optable"><tr><th colspan="10">PLA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x68</td><td></td><td>RS, LE, UM, NF</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Pull the value of the accumulator from the stack.
				</p><pre>
					A &lt;= Stack(++SP)
				</pre><h3>65k</h3>
<p>
					The RS prefix determines the width of the accumulator value as
					written
					on the stack.
				</p><p>
					The stack pointer used is the one of the current stack if the UM
					prefix
					is not set.
					If UM is set and the opcode is
					executed in
					hypervisor mode, the stack
					pointer used is the
					user mode stack
					pointer and the value is stored in user mode
					memory. If
					executed in
					user mode with UM set an ABORT exception is triggered.
				</p><h2>PLB</h2>
<a name="PLB"> </a><p>Pull B from stack (full width)</p>
<table class="optable"><tr><th colspan="10">PLB</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x68</td><td>65k</td><td>UM, NF</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Pull the value of the B register from the stack.
				</p><pre>
					B &lt;= Stack(++SP)
				</pre><h3>65k</h3>
<p>
					The value retrieved is always in the natural width of the
					processor
					(mode).
				</p><p>
					The stack pointer used is the one of the current stack if the UM
					prefix
					is not set.
					If UM is set and the opcode is
					executed in
					hypervisor mode, the stack
					pointer used is the
					user mode stack
					pointer and the value is stored in user mode
					memory. If
					executed in
					user mode with UM set an ABORT exception is triggered.
				</p><h2>PLE</h2>
<a name="PLE"> </a><p>Pull E from stack (full width)</p>
<table class="optable"><tr><th colspan="10">PLE</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x28</td><td>65k</td><td>UM, NF</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Pull the value of the E register from the stack.
				</p><pre>
					E &lt;= Stack(++SP)
				</pre><h3>65k</h3>
<p>
					The value retrieved is always in the natural width of the
					processor
					(mode).
				</p><p>
					The stack pointer used is the one of the current stack if the UM
					prefix
					is not set.
					If UM is set and the opcode is
					executed in
					hypervisor mode, the stack
					pointer used is the
					user mode stack
					pointer and the value is stored in user mode
					memory. If
					executed in
					user mode with UM set an ABORT exception is triggered.
				</p><h2>PLM</h2>
<a name="PLM"> </a><p>Pull contents of multiple registers from the stack</p>
<table class="optable"><tr><th colspan="10">PLM</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x64</td><td>65k</td><td>RS, UM</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Push the content of multiple registers on the stack.  
				</p><pre>
					Z &lt;= Stack(++SP)
					Y &lt;= Stack(++SP)
					X &lt;= Stack(++SP)
					E &lt;= Stack(++SP)
					B &lt;= Stack(++SP)
					A &lt;= Stack(++SP)
				</pre><p>
					The RS prefix determines the width of the accumulator value as
					written
					on the stack.
				</p><p>
					The stack pointer used is the one of the current stack if the UM
					prefix
					is not set.
					If UM is set and the opcode is
					executed in
					hypervisor mode, the stack
					pointer used is the
					user mode stack
					pointer and the value is read from user mode
					memory. If
					executed in
					user mode with UM set an ABORT exception is triggered.
				</p><h2>PLP</h2>
<a name="PLP"> </a><p>Pull processor status register from the stack</p>
<table class="optable"><tr><th colspan="10">PLP</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x28</td><td></td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Pull the standard status register on the stack.
				</p><pre>
					Status &lt;= Stack(++SP)
				</pre><h3>65k</h3>
<p>
					The stack pointer used is the one of the current stack if the UM
					prefix
					is not set.
					If UM is set and the opcode is
					executed in
					hypervisor mode, the stack
					pointer used is the
					user mode stack
					pointer and the value is stored in user mode
					memory. If
					executed in
					user mode with UM set an ABORT exception is triggered.
				</p><p>
					When the status register has bit 5 (the not-extended bit) set,
					then PLP
					reads the standard
					status register only.
				</p><p>
					When the status register has bit 5 cleared, it reads a second
					byte from
					the stack and
					restores the G and OE flags
					from that byte
					into the extended status
					register.
					(Note that this introduces a
					slight incompatibility with the 6502. So
					this behaviour may change
					to require the RS width set to word.)
				</p><h2>PLX</h2>
<a name="PLX"> </a><p>Pull the contents of the X register from the stack</p>
<table class="optable"><tr><th colspan="10">PLX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xfa</td><td>cmos</td><td>RS, LE, UM, NF</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Pull the value of the X register from the stack.
				</p><pre>
					X &lt;= Stack(++SP)
				</pre><h3>65k</h3>
<p>
					The RS prefix determines the width of the accumulator value as
					written
					on the stack.
				</p><p>
					The stack pointer used is the one of the current stack if the UM
					prefix
					is not set.
					If UM is set and the opcode is
					executed in
					hypervisor mode, the stack
					pointer used is the
					user mode stack
					pointer and the value is stored in user mode
					memory. If
					executed in
					user mode with UM set an ABORT exception is triggered.
				</p><h2>PLY</h2>
<a name="PLY"> </a><p>Pull the contents of the Y register from the stack</p>
<table class="optable"><tr><th colspan="10">PLY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x7a</td><td>cmos</td><td>RS, LE, UM, NF</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Pull the value of the Y register from the stack.
				</p><pre>
					Y &lt;= Stack(++SP)
				</pre><h3>65k</h3>
<p>
					The RS prefix determines the width of the accumulator value as
					written
					on the stack.
				</p><p>
					The stack pointer used is the one of the current stack if the UM
					prefix
					is not set.
					If UM is set and the opcode is
					executed in
					hypervisor mode, the stack
					pointer used is the
					user mode stack
					pointer and the value is stored in user mode
					memory. If
					executed in
					user mode with UM set an ABORT exception is triggered.
				</p><h2>PLZ</h2>
<a name="PLZ"> </a><p>Pull Z Register from stack</p>
<table class="optable"><tr><th colspan="10">PLZ</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x7a</td><td>cmos_indz</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h2>PRB</h2>
<a name="PRB"> </a><p>Push and Replace Base register: Push base offset register to
				the
				stack, then transfer E-register to the base
				register
			</p>
<table class="optable"><tr><th colspan="10">PRB</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x58</td><td>65k</td><td>UM, NF</td><td>Implied</td><td></td><td></td></tr>
</table>
<h2>RDL</h2>
<a name="RDL"> </a><p>Rotate Direct Left - similar to ROL, but do not shift in carry,
				but the highest bit of the original value
			</p>
<table class="optable"><tr><th colspan="10">RDL</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x26</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x2a</td><td>65k</td><td>RS, NF</td><td>Accumulator</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x2e</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x36</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x3e</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x3f</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x3d</td><td>65k</td><td>RS, UM, NF</td><td>E indirect</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Shift the operand or accumulator left one bit (i.e. multiply by
					2).
					Shift
					in the sign (uppermost bit) of
					the original
					value from the
					right.
					The bit shifted is also moved into the carry flag.
					Note this
					opcode is a read-modify-write opcode
					and not only has
					memory-oriented addressing modes but can work
					on the accumulator
					alone as well.
				</p><pre>
					C &lt;= AC(7)
					AC(7-1) &lt;= AC(6-0)
					AC(0) &lt;= C
					N
					&lt;= AC7)
					Z &lt;= Z(AC)
				</pre><h3>65k</h3>
<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					UM
					determines
					whether the operand is in user
					space. NF allows to not
					set the flags.
				</p><p>
					RS also determine the width of the operation. There is no LE prefix,
					as the read and write widths are the same.
					Note that the default is to use BYTE-wide operation without load
					extension.
				</p><h2>RDL#</h2>
<a name="RDL#"> </a><p>Rotate Direct Left - similar to ROL, but do not shift in carry,
				but the highest bit of the original value
			</p>
<table class="optable"><tr><th colspan="10">RDL</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>QUICK</td><td>0x8</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#1</td><td></td></tr>
<tr><td>QUICK</td><td>0x18</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#2</td><td></td></tr>
<tr><td>QUICK</td><td>0x28</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#3</td><td></td></tr>
<tr><td>QUICK</td><td>0x38</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#4</td><td></td></tr>
<tr><td>QUICK</td><td>0x48</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#5</td><td></td></tr>
<tr><td>QUICK</td><td>0x58</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#6</td><td></td></tr>
<tr><td>QUICK</td><td>0x68</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#7</td><td></td></tr>
<tr><td>QUICK</td><td>0x78</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#8</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Shift the operand or accumulator left one bit (i.e. multiply by
					2).
					Shift
					in the sign (uppermost bit) of
					the original
					value from the
					right.
					The bit shifted is also moved into the carry flag.
					Note this
					opcode is a read-modify-write opcode
					and not only has
					memory-oriented addressing modes but can work
					on the accumulator
					alone as well.
				</p><pre>
					C &lt;= AC(7)
					AC(7-1) &lt;= AC(6-0)
					AC(0) &lt;= C
					N
					&lt;= AC7)
					Z &lt;= Z(AC)
				</pre><h3>65k</h3>
<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					UM
					determines
					whether the operand is in user
					space. NF allows to not
					set the flags.
				</p><p>
					RS also determine the width of the operation. There is no LE prefix,
					as the read and write widths are the same.
					Note that the default is to use BYTE-wide operation without load
					extension.
				</p><h2>RDR</h2>
<a name="RDR"> </a><p>Rotate Direct Right - similar to ROR, but do not shift in
				carry,
				but the lowest bit of the original value
			</p>
<table class="optable"><tr><th colspan="10">RDR</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x66</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x6a</td><td>65k</td><td>RS, NF</td><td>Accumulator</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x6e</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x76</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x7e</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x7f</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x7d</td><td>65k</td><td>RS, UM, NF</td><td>E indirect</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Shift the operand or accumulator right one bit (i.e. divide by
					2). Shift
					in bit 0 (lowermost bit) of
					the original
					value from the
					left.
					The bit shifted is also moved into the carry flag.
					Note this
					opcode is a read-modify-write opcode
					and not only has
					memory-oriented addressing modes but can work
					on the accumulator
					alone as well.
				</p><pre>
					C &lt;= AC(0)
					AC(6-0) &lt;= AC(7-1)
					AC(7) &lt;= C
					N
					&lt;= AC7)
					Z &lt;= Z(AC)
				</pre><h3>65k</h3>
<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					UM
					determines
					whether the operand is in user
					space. NF allows to not
					set the flags.
				</p><p>
					RS also determine the width of the operation. There is no LE
					prefix,
					as the read and write
					widths are the same.
					Note
					that the
					default is to use BYTE-wide operation without load
					extension.
				</p><h2>RDR#</h2>
<a name="RDR#"> </a><p>Rotate Direct Right - similar to ROR, but do not shift in
				carry,
				but the lowest bit of the original value
			</p>
<table class="optable"><tr><th colspan="10">RDR</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>QUICK</td><td>0x88</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#1</td><td></td></tr>
<tr><td>QUICK</td><td>0x98</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#2</td><td></td></tr>
<tr><td>QUICK</td><td>0xa8</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#3</td><td></td></tr>
<tr><td>QUICK</td><td>0xb8</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#4</td><td></td></tr>
<tr><td>QUICK</td><td>0xc8</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#5</td><td></td></tr>
<tr><td>QUICK</td><td>0xd8</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#6</td><td></td></tr>
<tr><td>QUICK</td><td>0xe8</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#7</td><td></td></tr>
<tr><td>QUICK</td><td>0xf8</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#8</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Shift the operand or accumulator right one bit (i.e. divide by
					2). Shift
					in bit 0 (lowermost bit) of
					the original
					value from the
					left.
					The bit shifted is also moved into the carry flag.
					Note this
					opcode is a read-modify-write opcode
					and not only has
					memory-oriented addressing modes but can work
					on the accumulator
					alone as well.
				</p><pre>
					C &lt;= AC(0)
					AC(6-0) &lt;= AC(7-1)
					AC(7) &lt;= C
					N
					&lt;= AC7)
					Z &lt;= Z(AC)
				</pre><h3>65k</h3>
<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					UM
					determines
					whether the operand is in user
					space. NF allows to not
					set the flags.
				</p><p>
					RS also determine the width of the operation. There is no LE
					prefix,
					as the read and write
					widths are the same.
					Note
					that the
					default is to use BYTE-wide operation without load
					extension.
				</p><h2>RMB#</h2>
<a name="RMB#"> </a><p>Reset memory bit</p>
<table class="optable"><tr><th colspan="10">RMB</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>QUICK</td><td>0x7</td><td>65k</td><td></td><td>Zeropage</td><td>#0</td><td></td></tr>
<tr><td>QUICK</td><td>0x17</td><td>65k</td><td></td><td>Zeropage</td><td>#1</td><td></td></tr>
<tr><td>QUICK</td><td>0x27</td><td>65k</td><td></td><td>Zeropage</td><td>#2</td><td></td></tr>
<tr><td>QUICK</td><td>0x37</td><td>65k</td><td></td><td>Zeropage</td><td>#3</td><td></td></tr>
<tr><td>QUICK</td><td>0x47</td><td>65k</td><td></td><td>Zeropage</td><td>#4</td><td></td></tr>
<tr><td>QUICK</td><td>0x57</td><td>65k</td><td></td><td>Zeropage</td><td>#5</td><td></td></tr>
<tr><td>QUICK</td><td>0x67</td><td>65k</td><td></td><td>Zeropage</td><td>#6</td><td></td></tr>
<tr><td>QUICK</td><td>0x77</td><td>65k</td><td></td><td>Zeropage</td><td>#7</td><td></td></tr>
<tr><td>QUICK</td><td>0x6</td><td>65k</td><td></td><td>Absolute 16bit</td><td>#0</td><td></td></tr>
<tr><td>QUICK</td><td>0x16</td><td>65k</td><td></td><td>Absolute 16bit</td><td>#1</td><td></td></tr>
<tr><td>QUICK</td><td>0x26</td><td>65k</td><td></td><td>Absolute 16bit</td><td>#2</td><td></td></tr>
<tr><td>QUICK</td><td>0x36</td><td>65k</td><td></td><td>Absolute 16bit</td><td>#3</td><td></td></tr>
<tr><td>QUICK</td><td>0x46</td><td>65k</td><td></td><td>Absolute 16bit</td><td>#4</td><td></td></tr>
<tr><td>QUICK</td><td>0x56</td><td>65k</td><td></td><td>Absolute 16bit</td><td>#5</td><td></td></tr>
<tr><td>QUICK</td><td>0x66</td><td>65k</td><td></td><td>Absolute 16bit</td><td>#6</td><td></td></tr>
<tr><td>QUICK</td><td>0x76</td><td>65k</td><td></td><td>Absolute 16bit</td><td>#7</td><td></td></tr>
<tr><td>QUICK</td><td>0x5</td><td>65k</td><td></td><td>Zeropage indexed with X</td><td>#0</td><td></td></tr>
<tr><td>QUICK</td><td>0x15</td><td>65k</td><td></td><td>Zeropage indexed with X</td><td>#1</td><td></td></tr>
<tr><td>QUICK</td><td>0x25</td><td>65k</td><td></td><td>Zeropage indexed with X</td><td>#2</td><td></td></tr>
<tr><td>QUICK</td><td>0x35</td><td>65k</td><td></td><td>Zeropage indexed with X</td><td>#3</td><td></td></tr>
<tr><td>QUICK</td><td>0x45</td><td>65k</td><td></td><td>Zeropage indexed with X</td><td>#4</td><td></td></tr>
<tr><td>QUICK</td><td>0x55</td><td>65k</td><td></td><td>Zeropage indexed with X</td><td>#5</td><td></td></tr>
<tr><td>QUICK</td><td>0x65</td><td>65k</td><td></td><td>Zeropage indexed with X</td><td>#6</td><td></td></tr>
<tr><td>QUICK</td><td>0x75</td><td>65k</td><td></td><td>Zeropage indexed with X</td><td>#7</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Examine the operand value, and clear the given bit in it.
					The Z status register bit is set to the previous value of the memory bit.
				</p><h2>ROL</h2>
<a name="ROL"> </a><p>Rotate Left - shift accumulator one bit to the left, shifting
				in
				the carry flag in bit 0, and shifting the
				highest bit into the
				carry flag instead.
			</p>
<table class="optable"><tr><th colspan="10">ROL</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x26</td><td></td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x2a</td><td></td><td>RS, NF</td><td>Accumulator</td><td></td><td></td></tr>
<tr><td></td><td>0x2e</td><td></td><td>AM, OF, RS, UM, NF</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x36</td><td></td><td>AM, OF, RS, UM, NF</td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x3e</td><td></td><td>AM, OF, RS, UM, NF</td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x2f</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x2d</td><td>65k</td><td>RS, UM, NF</td><td>E indirect</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Shift the operand or accumulator left one bit (i.e. multiply by
					2).
					Shift
					in the carry flag from the right.
					The bit
					shifted out is
					moved into the carry flag.
					Note this opcode is a read-modify-write
					opcode and not only has
					memory-oriented addressing modes but can
					work
					on the accumulator alone as well.
				</p><pre>
					Tmp &lt;= AC(7)
					AC(7-1) &lt;= AC(6-0)
					AC(0) &lt;= C
					C
					&lt;= Tmp
					N &lt;= AC7)
					Z &lt;= Z(AC)
				</pre><h3>65k</h3>
<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					UM
					determines
					whether the operand is in user
					space. NF allows to not
					set the flags.
				</p><p>
					RS also determine the width of the operation. There is no LE
					prefix,
					as the read and write
					widths are the same.
					Note
					that the
					default is to use BYTE-wide operation without load
					extension.
				</p><h2>ROL#</h2>
<a name="ROL#"> </a><p>Rotate Left - shift accumulator one bit to the left, shifting
				in
				the carry flag in bit 0, and shifting the
				highest bit into the
				carry flag instead.
			</p>
<table class="optable"><tr><th colspan="10">ROL</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>QUICK</td><td>0x9</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#1</td><td></td></tr>
<tr><td>QUICK</td><td>0x19</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#2</td><td></td></tr>
<tr><td>QUICK</td><td>0x29</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#3</td><td></td></tr>
<tr><td>QUICK</td><td>0x39</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#4</td><td></td></tr>
<tr><td>QUICK</td><td>0x49</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#5</td><td></td></tr>
<tr><td>QUICK</td><td>0x59</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#6</td><td></td></tr>
<tr><td>QUICK</td><td>0x69</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#7</td><td></td></tr>
<tr><td>QUICK</td><td>0x79</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#8</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Shift the operand or accumulator left one bit (i.e. multiply by
					2).
					Shift
					in the carry flag from the right.
					The bit
					shifted out is
					moved into the carry flag.
					Note this opcode is a read-modify-write
					opcode and not only has
					memory-oriented addressing modes but can
					work
					on the accumulator alone as well.
				</p><pre>
					Tmp &lt;= AC(7)
					AC(7-1) &lt;= AC(6-0)
					AC(0) &lt;= C
					C
					&lt;= Tmp
					N &lt;= AC7)
					Z &lt;= Z(AC)
				</pre><h3>65k</h3>
<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					UM
					determines
					whether the operand is in user
					space. NF allows to not
					set the flags.
				</p><p>
					RS also determine the width of the operation. There is no LE
					prefix,
					as the read and write
					widths are the same.
					Note
					that the
					default is to use BYTE-wide operation without load
					extension.
				</p><h2>ROR</h2>
<a name="ROR"> </a><p>Rotate Right - shift accumulator one bit to the right, shifting
				in the carry flag in the highest bit, and
				shifting
				bit 0 into the
				carry flag instead.
			</p>
<table class="optable"><tr><th colspan="10">ROR</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x66</td><td>ror</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x6a</td><td>ror</td><td>RS, NF</td><td>Accumulator</td><td></td><td></td></tr>
<tr><td></td><td>0x6e</td><td>ror</td><td>AM, OF, RS, UM, NF</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x76</td><td>ror</td><td>AM, OF, RS, UM, NF</td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x7e</td><td>ror</td><td>AM, OF, RS, UM, NF</td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x6f</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x6d</td><td>65k</td><td>RS, UM, NF</td><td>E indirect</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Shift the operand or accumulator right one bit (i.e. divide by
					2). Shift
					in the carry flag from the left.
					The bit
					shifted out is
					moved into the carry flag.
					Note this opcode is a read-modify-write
					opcode and not only has
					memory-oriented addressing modes but can
					work
					on the accumulator alone as well.
				</p><pre>
					Tmp &lt;= AC(0)
					AC(6-0) &lt;= AC(7-1)
					AC(7) &lt;= C
					C
					&lt;= Tmp
					N &lt;= AC7)
					Z &lt;= Z(AC)
				</pre><h3>65k</h3>
<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					UM
					determines
					whether the operand is in user
					space. NF allows to not
					set the flags.
				</p><p>
					RS also determine the width of the operation. There is no LE
					prefix,
					as the read and write
					widths are the same.
					Note
					that the
					default is to use BYTE-wide operation without load
					extension.
				</p><h2>ROR#</h2>
<a name="ROR#"> </a><p>Rotate Right - shift accumulator one bit to the right, shifting
				in the carry flag in the highest bit, and
				shifting
				bit 0 into the
				carry flag instead.
			</p>
<table class="optable"><tr><th colspan="10">ROR</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>QUICK</td><td>0x89</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#1</td><td></td></tr>
<tr><td>QUICK</td><td>0x99</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#2</td><td></td></tr>
<tr><td>QUICK</td><td>0xa9</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#3</td><td></td></tr>
<tr><td>QUICK</td><td>0xb9</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#4</td><td></td></tr>
<tr><td>QUICK</td><td>0xc9</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#5</td><td></td></tr>
<tr><td>QUICK</td><td>0xd9</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#6</td><td></td></tr>
<tr><td>QUICK</td><td>0xe9</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#7</td><td></td></tr>
<tr><td>QUICK</td><td>0xf9</td><td>65k</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td>#8</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Shift the operand or accumulator right one bit (i.e. divide by
					2). Shift
					in the carry flag from the left.
					The bit
					shifted out is
					moved into the carry flag.
					Note this opcode is a read-modify-write
					opcode and not only has
					memory-oriented addressing modes but can
					work
					on the accumulator alone as well.
				</p><pre>
					Tmp &lt;= AC(0)
					AC(6-0) &lt;= AC(7-1)
					AC(7) &lt;= C
					C
					&lt;= Tmp
					N &lt;= AC7)
					Z &lt;= Z(AC)
				</pre><h3>65k</h3>
<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					UM
					determines
					whether the operand is in user
					space. NF allows to not
					set the flags.
				</p><p>
					RS also determine the width of the operation. There is no LE
					prefix,
					as the read and write
					widths are the same.
					Note
					that the
					default is to use BYTE-wide operation without load
					extension.
				</p><h2>RTI</h2>
<a name="RTI"> </a><p>Return from interrupt</p>
<table class="optable"><tr><th colspan="10">RTI</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x40</td><td></td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Returns from an interrupt or a BRK opcode handling. It first
					pulls the
					status register from the stack, then
					takes
					the return
					address from the stack, increment it by one, and
					continue at the new
					address.
				</p><pre>
					Status &lt;= Stack(++SP) -- bit 5=1
					Tmp(0-7) &lt;=
					Stack(++SP)
					Tmp(8-15) &lt;= Stack(++SP)
					PC &lt;=
					Tmp;
				</pre><h3>65k</h3>
<p>
					The RTI prefix first reads the status from the current stack. If
					the
					"Not extended" flag is set
					(bit 5 is always 1
					in the 6502 status
					register, so here it is used as
					"not extended" flag), then
					the normal
					handling as described above
					takes place.
				</p><p>
					If the "not extended" flag is clear, i.e. an extended stack frame
					is
					used:
				</p><pre>
					Status &lt;= Stack(++SP) -- bit 5=0
					ExtStatus &lt;=
					Stack(++SP)
					Tmp(0-7) &lt;= Stack(++SP)
					Tmp(8-15)
					&lt;=
					Stack(++SP)
					...
					PC &lt;= Tmp;
				</pre><p>
					Here the extended status byte is pulled from the stack after the
					standard status. In this extended status
					there are
					two bit that
					determine the size of the return address
					following
					on the stack.
					So
					the return address can be 16-, 32- or
					64-bit. Note that the "00"
					designation (otherwise used for BYTE width)
					maps to the natural
					address width of the
					processor executing the code.
				</p><p>
					Also the user mode bit is stored in the extended stack frame. If
					the
					user mode bit is the same as the
					current mode,
					the execution
					continues in that mode.
					If the RTI code is executed in the
					supervisor mode, and the user mode
					bit is set,
					then the
					return
					address is interpreted as user mode address, and the execution
					continues in the
					user mode. If RTI is
					executed in user mode, and the
					user mode bit is
					clear (i.e. hypervisor mode),
					and ABORT sequence is
					triggered.
				</p><p>
					Note that the "natural" address width is taken from the target
					environment in case the process jumps
					from
					hypervisor to user mode.
				</p><p>
					If the operand is not wide enough as required for an address, it
					is
					sign-extended.
				</p><h2>RTS</h2>
<a name="RTS"> </a><p>Return from subroutine - read return address from stack</p>
<table class="optable"><tr><th colspan="10">RTS</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x60</td><td></td><td>RS</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Take the return address from the stack, increment it by one, and
					continue at the new address.
				</p><pre>
					Tmp(0-7) &lt;= Stack(++SP)
					Tmp(8-15) &lt;= Stack(++SP)
					PC &lt;= Tmp + 1;
				</pre><h3>65k</h3>
<p>
					The RS prefix determines the width of the return address read
					from the
					stack. Note that the
					BYTE width prefix
					denotes the natural
					width of the processor
					(respectively its current mode). This
					is the
					default.
				</p><p>
					If the operand is not wide enough as required for an address, it
					is
					extended with the
					rest of the current PC. This
					is to support
					running "narrow" code within
					a e.g. a 64k window
					in a wide system.
				</p><p>
					The stack pointer used is the stack pointer of the current mode.
				</p><h2>RTU</h2>
<a name="RTU"> </a><p>Return from trap handler.</p>
<table class="optable"><tr><th colspan="10">RTU</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>SYS</td><td>0x60</td><td>65k</td><td></td><td>Immediate</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Return from trap handling. Reads the extended status byte and the
					return
					address from hypervisor stack,
					then jumps
					to the return
					address.
				</p><pre>
					&lt;Tmp &lt;= Stack(++SP)
					>Tmp &lt;= Stack(++SP)
					Tmp &lt;= Tmp+1
					PC &lt;= Tmp;
					ExtStatus
					&lt;= Stack(++SP)
				</pre><h3>65k</h3>
<p>
					The extended status byte contains the width bits for the return
					address
					as well as the user mode bit
					from where the
					trap came. In RTU
					the user mode bit is restored, so the
					RTU opcode can return to
					user
					as well as hypervisor mode.
				</p><p>
					The stack pointer used is that of the hypervisor stack.
				</p><p>
					Note for future expansions the RS prefix may extend the number of
					traps
					to word, or even wider widths.
				</p><p>
					When executed in user mode, this opcode triggers an ABORT
					exception.
				</p><h2>SAB</h2>
<a name="SAB"> </a><p>Swap A register with B register. Always done full width, no
				flags set.
			</p>
<table class="optable"><tr><th colspan="10">SAB</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0xa8</td><td>65k</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h2>SAX</h2>
<a name="SAX"> </a><p>Swap AC with X register. Always done full width, no flags set.
			</p>
<table class="optable"><tr><th colspan="10">SAX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x88</td><td>65k</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h2>SAY</h2>
<a name="SAY"> </a><p>Swap AC with Y register. Always done full width, no flags set.
			</p>
<table class="optable"><tr><th colspan="10">SAY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0xda</td><td>65k</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h2>SBC</h2>
<a name="SBC"> </a><p>Substract content of memory location from accumulator</p>
<table class="optable"><tr><th colspan="10">SBC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xe1</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indexed with X indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0xe3</td><td>65k</td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indexed with X indirect 64bit</td><td></td><td></td></tr>
<tr><td></td><td>0xe5</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0xe9</td><td></td><td>RS, LE, NF</td><td>Immediate</td><td></td><td></td></tr>
<tr><td></td><td>0xed</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0xf1</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0xf2</td><td>cmos_indz</td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indirect 16bit indexed with Z</td><td></td><td></td></tr>
<tr><td></td><td>0xf3</td><td>65k</td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indirect 64bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0xf5</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0xf7</td><td>65k</td><td>AM, OF, RS, LE, UM, NF</td><td>Zeropage indirect 64bit indexed with Z</td><td></td><td></td></tr>
<tr><td></td><td>0xf9</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0xfd</td><td></td><td>AM, OF, RS, LE, UM, NF</td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xe9</td><td>65k</td><td>RS, LE, UM, NF</td><td>E indirect</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Substract the operand from the accumulator and store back in the
					accumulator.
					Set the flags from the result. Use
					Decimal or Binary
					add depending
					on whether the
					decimal mode status bis is set or not
					respectively. C status flag is
					used
					as borrow.
				</p><pre>
					AC, C, V &lt;= AC - Operand, C
					N &lt;= Tmp(7)
					Z &lt;=
					Z(Tmp)
				</pre><p>
					For a handling of the V-flag please see
					<a href="http://www.6502.org/tutorials/vflag.html">http://www.6502.org/tutorials/vflag.html</a>
					.
				</p><h3>65k</h3>
<p>
					The AM, OF, LE and RS prefixes are evaluated by the addressing
					modes.
					UM determines
					whether the operand is in user
					space. NF allows
					to not set the flags.
				</p><p>
					RS and LE together also determine the width of the operation.
					Note that the default is to use BYTE-wide operation
					without load
					extension.
				</p><h2>SBE</h2>
<a name="SBE"> </a><p>Subtract value from E register</p>
<table class="optable"><tr><th colspan="10">SBE</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0xa5</td><td>65k</td><td>RS, LE, NF</td><td>Immediate</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xa4</td><td>65k</td><td>RS, NF</td><td>Accumulator</td><td></td><td></td></tr>
</table>
<h2>SBI</h2>
<a name="SBI"> </a><p>Subtract immediate value from a memory location</p>
<table class="optable"><tr><th colspan="10">SBI</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0xc5</td><td>65k</td><td>AM, OF, RS, UM, LE, NF</td><td>Immediate to Zeropage Address</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x95</td><td>65k</td><td>AM, OF, RS, UM, LE, NF</td><td>Immediate to Zeropage Address X-indexed</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xb5</td><td>65k</td><td>AM, OF, RS, UM, LE, NF</td><td>Immediate to Zeropage indirect Y-indexed address</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xe5</td><td>65k</td><td>AM, OF, RS, UM, LE, NF</td><td>Immediate to Absolute Address</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Subtract the immediate value following the opcode to the address given by the second operand. Carry is assumed set.
				</p><pre>
					Operand &lt;= Operand - #immediate
				</pre><p>
					The AM and OF prefixes are evaluated by the addressing modes. UM determines
					whether the operand is in user
					space.
				</p><p>
					RS determines the width of the operation. 
					If a width larger than the immediate value is used, LE must be set to determine the extension type.
					Note that the default is RS=00, i.e. byte wide operation.
				</p><h2>SBQ</h2>
<a name="SBQ"> </a><p>Subtract immediate value from a register</p>
<table class="optable"><tr><th colspan="10">SBQ</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0xd5</td><td>65k</td><td>RS, LE, NF</td><td>Immediate to register</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xf5</td><td>65k</td><td>RS, LE, NF</td><td>Immediate to register</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Subtract the immediate value following the opcode from the register given by the uppermost three bits of the immediate value. Carry is assumed cleared.
				</p><p>
					The following table details the register selection from the uppermost three bits of the immediate value:
				</p><table><tr><th>Value</th><td>Register</td></tr><tr><td>000</td><td>A</td></tr><tr><td>001</td><td>B</td></tr><tr><td>010</td><td>E</td></tr><tr><td>011</td><td>reserved</td></tr><tr><td>100</td><td>X</td></tr><tr><td>101</td><td>Y</td></tr><tr><td>110</td><td>Z</td></tr><tr><td>111</td><td>reserved</td></tr>
				</table><pre>
					Register &lt;= Register - #immediate
				</pre><p>
					RS determines the width of the operation. 
					If a width larger than the immediate value is used, LE must be set to determine the extension type.
					Note that the default is RS=00, i.e. byte wide operation.
				</p><h2>SCC</h2>
<a name="SCC"> </a><p>Skip on carry clear - skip next opcode when C flag is cleared</p>
<table class="optable"><tr><th colspan="10">SCC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x9f</td><td>65k</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Skip the
					next operation (after the skip opcode)
					given the
					condition that
					the
					carry status flag is cleared.
				</p><h2>SCS</h2>
<a name="SCS"> </a><p>Synonyms: SGE</p>
<p>Skip on carry set - skip next opcode when C flag is set</p>
<table class="optable"><tr><th colspan="10">SCS</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xbf</td><td>65k</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Skip the
					next operation (after the skip opcode)
					given the
					condition that
					the
					carry status flag is set.
				</p><h2>SEC</h2>
<a name="SEC"> </a><p>Set the C flag</p>
<table class="optable"><tr><th colspan="10">SEC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x38</td><td></td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Set the carry status flag.
				</p><h2>SED</h2>
<a name="SED"> </a><p>Set the decimal (D) flag</p>
<table class="optable"><tr><th colspan="10">SED</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xf8</td><td>bcd</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Set the decimal mode status flag.
				</p><h2>SEI</h2>
<a name="SEI"> </a><p>Set the interrupt (I) flag</p>
<table class="optable"><tr><th colspan="10">SEI</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x78</td><td></td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Set the interrupt status flag.
				</p><h3>65k</h3>
<p>
					Note that the interrupt handling is much more sophisticated in
					the 65k.
					In hypervisor mode setting the interrupt
					status flag
					disables all
					interrupts except the non-maskable interrupt.
					In user
					mode setting the interrupt status flag
					disables all "user
					level
					interrupts", but hypervisor interrupts
					are served. The interrupt
					level for user level
					interrupts can be
					configured in a configuration
					register.
				</p><h2>SEQ</h2>
<a name="SEQ"> </a><p>Skip on equal - skip next opcode when Z flag is set</p>
<table class="optable"><tr><th colspan="10">SEQ</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xff</td><td>65k</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Skip the
					next operation (after the skip opcode)
					given the
					condition that
					the
					zero status flag is set.
				</p><h2>SMB#</h2>
<a name="SMB#"> </a><p>Set memory bit</p>
<table class="optable"><tr><th colspan="10">SMB</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>QUICK</td><td>0x87</td><td>65k</td><td></td><td>Zeropage</td><td>#0</td><td></td></tr>
<tr><td>QUICK</td><td>0x97</td><td>65k</td><td></td><td>Zeropage</td><td>#1</td><td></td></tr>
<tr><td>QUICK</td><td>0xa7</td><td>65k</td><td></td><td>Zeropage</td><td>#2</td><td></td></tr>
<tr><td>QUICK</td><td>0xb7</td><td>65k</td><td></td><td>Zeropage</td><td>#3</td><td></td></tr>
<tr><td>QUICK</td><td>0xc7</td><td>65k</td><td></td><td>Zeropage</td><td>#4</td><td></td></tr>
<tr><td>QUICK</td><td>0xd7</td><td>65k</td><td></td><td>Zeropage</td><td>#5</td><td></td></tr>
<tr><td>QUICK</td><td>0xe7</td><td>65k</td><td></td><td>Zeropage</td><td>#6</td><td></td></tr>
<tr><td>QUICK</td><td>0xf7</td><td>65k</td><td></td><td>Zeropage</td><td>#7</td><td></td></tr>
<tr><td>QUICK</td><td>0x86</td><td>65k</td><td></td><td>Absolute 16bit</td><td>#0</td><td></td></tr>
<tr><td>QUICK</td><td>0x96</td><td>65k</td><td></td><td>Absolute 16bit</td><td>#1</td><td></td></tr>
<tr><td>QUICK</td><td>0xa6</td><td>65k</td><td></td><td>Absolute 16bit</td><td>#2</td><td></td></tr>
<tr><td>QUICK</td><td>0xb6</td><td>65k</td><td></td><td>Absolute 16bit</td><td>#3</td><td></td></tr>
<tr><td>QUICK</td><td>0xc6</td><td>65k</td><td></td><td>Absolute 16bit</td><td>#4</td><td></td></tr>
<tr><td>QUICK</td><td>0xd6</td><td>65k</td><td></td><td>Absolute 16bit</td><td>#5</td><td></td></tr>
<tr><td>QUICK</td><td>0xe6</td><td>65k</td><td></td><td>Absolute 16bit</td><td>#6</td><td></td></tr>
<tr><td>QUICK</td><td>0xf6</td><td>65k</td><td></td><td>Absolute 16bit</td><td>#7</td><td></td></tr>
<tr><td>QUICK</td><td>0x85</td><td>65k</td><td></td><td>Zeropage indexed with X</td><td>#0</td><td></td></tr>
<tr><td>QUICK</td><td>0x95</td><td>65k</td><td></td><td>Zeropage indexed with X</td><td>#1</td><td></td></tr>
<tr><td>QUICK</td><td>0xa5</td><td>65k</td><td></td><td>Zeropage indexed with X</td><td>#2</td><td></td></tr>
<tr><td>QUICK</td><td>0xb5</td><td>65k</td><td></td><td>Zeropage indexed with X</td><td>#3</td><td></td></tr>
<tr><td>QUICK</td><td>0xc5</td><td>65k</td><td></td><td>Zeropage indexed with X</td><td>#4</td><td></td></tr>
<tr><td>QUICK</td><td>0xd5</td><td>65k</td><td></td><td>Zeropage indexed with X</td><td>#5</td><td></td></tr>
<tr><td>QUICK</td><td>0xe5</td><td>65k</td><td></td><td>Zeropage indexed with X</td><td>#6</td><td></td></tr>
<tr><td>QUICK</td><td>0xf5</td><td>65k</td><td></td><td>Zeropage indexed with X</td><td>#7</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Examine the operand value, and set the given bit in it.
					The Z status register bit is set to the previous value of the memory bit.
				</p><h2>SMI</h2>
<a name="SMI"> </a><p>Skip on minus - skip next opcode when N flag is set</p>
<table class="optable"><tr><th colspan="10">SMI</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x3f</td><td>65k</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Skip the
					next operation (after the skip opcode)
					given the
					condition that
					the
					negative status flag is set.
				</p><h2>SNE</h2>
<a name="SNE"> </a><p>Skip on not equal - skip next opcode when Z flag is cleared</p>
<table class="optable"><tr><th colspan="10">SNE</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xdf</td><td>65k</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Skip the
					next operation (after the skip opcode)
					given the
					condition that
					the
					zero status flag is cleared.
				</p><h2>SPL</h2>
<a name="SPL"> </a><p>Skip on plus - skip next opcode when N flag is cleared</p>
<table class="optable"><tr><th colspan="10">SPL</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x1f</td><td>65k</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Skip the
					next operation (after the skip opcode)
					given the
					condition that
					the
					negative status flag is clear.
				</p><h2>STA</h2>
<a name="STA"> </a><p>Store the content of the accumulator into a memory location
			</p>
<table class="optable"><tr><th colspan="10">STA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x22</td><td>65k</td><td>AM, OF, RS, UM</td><td>Zeropage indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x81</td><td></td><td>AM, OF, RS, UM</td><td>Zeropage indexed with X indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x83</td><td>65k</td><td>AM, OF, RS, UM</td><td>Zeropage indexed with X indirect 64bit</td><td></td><td></td></tr>
<tr><td></td><td>0x85</td><td></td><td>AM, OF, RS, UM</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x8d</td><td></td><td>AM, OF, RS, UM</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x91</td><td></td><td>AM, OF, RS, UM</td><td>Zeropage indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x92</td><td>cmos_indz</td><td>AM, OF, RS, UM</td><td>Zeropage indirect 16bit indexed with Z</td><td></td><td></td></tr>
<tr><td></td><td>0x93</td><td>65k</td><td>AM, OF, RS, UM</td><td>Zeropage indirect 64bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x95</td><td></td><td>AM, OF, RS, UM</td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x97</td><td>65k</td><td>AM, OF, RS, UM</td><td>Zeropage indirect 64bit indexed with Z</td><td></td><td></td></tr>
<tr><td></td><td>0x99</td><td></td><td>AM, OF, RS, UM</td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x9d</td><td></td><td>AM, OF, RS, UM</td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0xc2</td><td>65k</td><td>AM, OF, RS, UM</td><td>Absolute indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0xc7</td><td>65k</td><td>AM, OF, RS, UM</td><td>Absolute indirect 64bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0xe2</td><td>65k</td><td>AM, OF, RS, UM</td><td>Absolute indexed with X indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0xe7</td><td>65k</td><td>AM, OF, RS, UM</td><td>Absolute indexed with X indirect 64bit</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x8d</td><td>65k</td><td>RS, UM</td><td>E indirect</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x91</td><td>65k</td><td>AM, OF, RS, UM</td><td>Zeropage indirect 16bit indexed with byte offset</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x51</td><td>65k</td><td>AM, OF, RS, UM</td><td>Absolute indirect 16bit indexed with byte offset</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x92</td><td>65k</td><td>AM, OF, RS, UM</td><td>Zeropage indirect 64bit indexed with byte offset</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x52</td><td>65k</td><td>AM, OF, RS, UM</td><td>Absolute indirect 64bit indexed with byte offset</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Store the accumulator into the address given by the operand.
				</p><pre>
					Operand &lt;= A
				</pre><h3>65k</h3>
<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					UM
					determines
					whether the operand is in user
					space.
				</p><p>
					RS also determine the width of the operation.
					Note that the
					default is to use BYTE-wide operation without load
					extension.
				</p><h2>STI</h2>
<a name="STI"> </a><p>Store immediate byte value into a memory location</p>
<table class="optable"><tr><th colspan="10">STI</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0xd1</td><td>65k</td><td>AM, OF, RS, UM, LE</td><td>Immediate to Zeropage Address</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x01</td><td>65k</td><td>AM, OF, RS, UM, LE</td><td>Immediate to Absolute Address</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Store the immediate byte value following the opcode into the address given by the second operand.
				</p><pre>
					Operand &lt;= #immediate
				</pre><p>
					The AM and OF prefixes are evaluated by the addressing modes. UM determines
					whether the operand is in user
					space.
				</p><p>
					RS determines the width of the operation. 
					If a width larger than the immediate value is used, LE must be set to determine the extension type.
					Note that the default is RS=00, i.e. byte wide operation.
				</p><h2>STX</h2>
<a name="STX"> </a><p>Store the content of the X register to memory.</p>
<table class="optable"><tr><th colspan="10">STX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x86</td><td></td><td>AM, OF, RS, UM</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x8e</td><td></td><td>AM, OF, RS, UM</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x96</td><td></td><td>AM, OF, RS, UM</td><td>Zeropage indexed with Y</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0xaf</td><td>65k</td><td>AM, OF, RS, UM</td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x9d</td><td>65k</td><td>RS, UM</td><td>E indirect</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Store the content of the X register into the address given by the
					operand.
				</p><pre>
					Operand &lt;= A
				</pre><h3>65k</h3>
<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					UM
					determines
					whether the operand is in user
					space.
				</p><p>
					RS also determine the width of the operation.
					Note that the
					default is to use BYTE-wide operation without load
					extension.
				</p><h2>STY</h2>
<a name="STY"> </a><p>Store the content of the Y register to memory.</p>
<table class="optable"><tr><th colspan="10">STY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x84</td><td></td><td>AM, OF, RS, UM</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x8c</td><td></td><td>AM, OF, RS, UM</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x94</td><td></td><td>AM, OF, RS, UM</td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x8f</td><td>65k</td><td>AM, OF, RS, UM</td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x8c</td><td>65k</td><td>RS, UM</td><td>E indirect</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Store the content of the Y register into the address given by the
					operand.
				</p><pre>
					Operand &lt;= A
				</pre><h3>65k</h3>
<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					UM
					determines
					whether the operand is in user
					space.
				</p><p>
					RS also determine the width of the operation.
					Note that the
					default is to use BYTE-wide operation without load
					extension.
				</p><h2>STZ</h2>
<a name="STZ"> </a><p>Store zero into a memory location</p>
<table class="optable"><tr><th colspan="10">STZ</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x64</td><td>cmos</td><td>AM, OF, RS, UM</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x74</td><td>cmos</td><td>AM, OF, RS, UM</td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x9c</td><td>cmos</td><td>AM, OF, RS, UM</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x9e</td><td>cmos</td><td>AM, OF, RS, UM</td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x9e</td><td>65k</td><td>AM, OF, RS, UM</td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x9c</td><td>65k</td><td>RS, UM</td><td>E indirect</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Store zero into the address given by the operand.
				</p><pre>
					Operand &lt;= 0
				</pre><h3>65k</h3>
<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					UM
					determines
					whether the operand is in user
					space.
				</p><p>
					RS also determine the width of the operation.
					Note that the
					default is to use BYTE-wide operation without load
					extension.
				</p><h2>SUB</h2>
<a name="SUB"> </a><p>Substract content of memory location from accumulator without
				using the carry flag as input
			</p>
<table class="optable"><tr><th colspan="10">SUB</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x85</td><td>65k</td><td>RS, LE, NF</td><td>Immediate</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x80</td><td>65k</td><td>RS, LE, UM, NF</td><td>E indirect</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Substract the operand from the accumulator and store back in the
					accumulator.
					Set the flags from the result. Use
					Binary mode add
					only. C status
					flag is not used as
					input, but set as borrow from the
					result.
				</p><pre>
					AC, C, V &lt;= AC - Operand
					N &lt;= Tmp(7)
					Z &lt;=
					Z(Tmp)
				</pre><p>
					For a handling of the V-flag please see
					<a href="http://www.6502.org/tutorials/vflag.html">http://www.6502.org/tutorials/vflag.html</a>
					.
				</p><h3>65k</h3>
<p>
					The AM, OF, LE and RS prefixes are evaluated by the addressing
					modes.
					UM determines
					whether the operand is in user
					space. NF allows
					to not set the flags.
				</p><p>
					RS and LE together also determine the width of the operation.
					Note that the default is to use BYTE-wide operation
					without load
					extension.
				</p><h2>SVC</h2>
<a name="SVC"> </a><p>Skip on overflow clear - skip next opcode when V flag is cleared</p>
<table class="optable"><tr><th colspan="10">SVC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x5f</td><td>65k</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Skip the
					next operation (after the skip opcode)
					given the
					condition that
					the
					overflow status flag is cleared.
				</p><h2>SVS</h2>
<a name="SVS"> </a><p>Skip on overflow set - skip next opcode when V flag is set</p>
<table class="optable"><tr><th colspan="10">SVS</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x7f</td><td>65k</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Skip the
					next operation (after the skip opcode)
					given the
					condition that
					the
					overflow status flag is set.
				</p><h2>SWP</h2>
<a name="SWP"> </a><p>swap upper and lower half of the operand
			</p>
<table class="optable"><tr><th colspan="10">SWP</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0xe4</td><td>65k</td><td>RS, NF</td><td>Accumulator</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Swap upper and lower part nibble / byte / word / long word of a
					byte / word / long / quad (longlong) operand in
					Accumulator
				</p><h2>SXY</h2>
<a name="SXY"> </a><p>Swap X with Y register. Always done full width, no flags set.
			</p>
<table class="optable"><tr><th colspan="10">SXY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x98</td><td>65k</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h2>SXZ</h2>
<a name="SXZ"> </a><p>Swap X with Z register. Always done full width, no flags set.
			</p>
<table class="optable"><tr><th colspan="10">SXZ</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0xb8</td><td>65k</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h2>TAB</h2>
<a name="TAB"> </a><p>Transfer AC to B register</p>
<table class="optable"><tr><th colspan="10">TAB</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0xe8</td><td>65k</td><td>NF, LE, RS</td><td>Implied</td><td></td><td></td></tr>
</table>
<h2>TAX</h2>
<a name="TAX"> </a><p>Transfer the contents of accumulator into the X register</p>
<table class="optable"><tr><th colspan="10">TAX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xaa</td><td></td><td>RS, LE, NF</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the accumulator to the X register
				</p><pre>
					X &lt;= A
				</pre><h3>65k</h3>
<p>
					The RS and LE prefixes determines the width of the operation. LE
					determines how to extend the value
					loaded to the
					full (natural)
					width. The NF flag allows to perform the
					operation
					without setting
					flags.
				</p><h2>TAY</h2>
<a name="TAY"> </a><p>Transfer the contents of accumulator into the Y register</p>
<table class="optable"><tr><th colspan="10">TAY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xa8</td><td></td><td>RS, LE, NF</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the accumulator to the Y register
				</p><pre>
					Y &lt;= A
				</pre><h3>65k</h3>
<p>
					The RS and LE prefixes determines the width of the operation. LE
					determines how to extend the value
					loaded to the
					full (natural)
					width. The NF flag allows to perform the
					operation
					without setting
					flags.
				</p><h2>TAZ</h2>
<a name="TAZ"> </a><p>Transfer AC to Z Register</p>
<table class="optable"><tr><th colspan="10">TAZ</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0xaa</td><td>cmos_indz</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h2>TEA</h2>
<a name="TEA"> </a><p>Transfer E register to Accumulator</p>
<table class="optable"><tr><th colspan="10">TEA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0xd8</td><td>65k</td><td>NF</td><td>Implied</td><td></td><td></td></tr>
</table>
<h2>TEB</h2>
<a name="TEB"> </a><p>Transfer E to B register (full width)</p>
<table class="optable"><tr><th colspan="10">TEB</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0xea</td><td>65k</td><td>NF</td><td>Implied</td><td></td><td></td></tr>
</table>
<h2>TMB#</h2>
<a name="TMB#"> </a><p>Test memory bit</p>
<table class="optable"><tr><th colspan="10">TMB</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>QUICK</td><td>0x3</td><td>65k</td><td>AM, OF, UM</td><td>Zeropage</td><td>#0</td><td></td></tr>
<tr><td>QUICK</td><td>0x13</td><td>65k</td><td>AM, OF, UM</td><td>Zeropage</td><td>#1</td><td></td></tr>
<tr><td>QUICK</td><td>0x23</td><td>65k</td><td>AM, OF, UM</td><td>Zeropage</td><td>#2</td><td></td></tr>
<tr><td>QUICK</td><td>0x33</td><td>65k</td><td>AM, OF, UM</td><td>Zeropage</td><td>#3</td><td></td></tr>
<tr><td>QUICK</td><td>0x43</td><td>65k</td><td>AM, OF, UM</td><td>Zeropage</td><td>#4</td><td></td></tr>
<tr><td>QUICK</td><td>0x53</td><td>65k</td><td>AM, OF, UM</td><td>Zeropage</td><td>#5</td><td></td></tr>
<tr><td>QUICK</td><td>0x63</td><td>65k</td><td>AM, OF, UM</td><td>Zeropage</td><td>#6</td><td></td></tr>
<tr><td>QUICK</td><td>0x73</td><td>65k</td><td>AM, OF, UM</td><td>Zeropage</td><td>#7</td><td></td></tr>
<tr><td>QUICK</td><td>0x2</td><td>65k</td><td>AM, OF, UM</td><td>Absolute 16bit</td><td>#0</td><td></td></tr>
<tr><td>QUICK</td><td>0x12</td><td>65k</td><td>AM, OF, UM</td><td>Absolute 16bit</td><td>#1</td><td></td></tr>
<tr><td>QUICK</td><td>0x22</td><td>65k</td><td>AM, OF, UM</td><td>Absolute 16bit</td><td>#2</td><td></td></tr>
<tr><td>QUICK</td><td>0x32</td><td>65k</td><td>AM, OF, UM</td><td>Absolute 16bit</td><td>#3</td><td></td></tr>
<tr><td>QUICK</td><td>0x42</td><td>65k</td><td>AM, OF, UM</td><td>Absolute 16bit</td><td>#4</td><td></td></tr>
<tr><td>QUICK</td><td>0x52</td><td>65k</td><td>AM, OF, UM</td><td>Absolute 16bit</td><td>#5</td><td></td></tr>
<tr><td>QUICK</td><td>0x62</td><td>65k</td><td>AM, OF, UM</td><td>Absolute 16bit</td><td>#6</td><td></td></tr>
<tr><td>QUICK</td><td>0x72</td><td>65k</td><td>AM, OF, UM</td><td>Absolute 16bit</td><td>#7</td><td></td></tr>
<tr><td>QUICK</td><td>0x1</td><td>65k</td><td>AM, OF, UM</td><td>Zeropage indexed with X</td><td>#0</td><td></td></tr>
<tr><td>QUICK</td><td>0x11</td><td>65k</td><td>AM, OF, UM</td><td>Zeropage indexed with X</td><td>#1</td><td></td></tr>
<tr><td>QUICK</td><td>0x21</td><td>65k</td><td>AM, OF, UM</td><td>Zeropage indexed with X</td><td>#2</td><td></td></tr>
<tr><td>QUICK</td><td>0x31</td><td>65k</td><td>AM, OF, UM</td><td>Zeropage indexed with X</td><td>#3</td><td></td></tr>
<tr><td>QUICK</td><td>0x41</td><td>65k</td><td>AM, OF, UM</td><td>Zeropage indexed with X</td><td>#4</td><td></td></tr>
<tr><td>QUICK</td><td>0x51</td><td>65k</td><td>AM, OF, UM</td><td>Zeropage indexed with X</td><td>#5</td><td></td></tr>
<tr><td>QUICK</td><td>0x61</td><td>65k</td><td>AM, OF, UM</td><td>Zeropage indexed with X</td><td>#6</td><td></td></tr>
<tr><td>QUICK</td><td>0x71</td><td>65k</td><td>AM, OF, UM</td><td>Zeropage indexed with X</td><td>#7</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Examine the operand value, and set the Z status register bit from the memory value.
				</p><h2>TPA</h2>
<a name="TPA"> </a><p>Transfer Program counter to Accumulator</p>
<table class="optable"><tr><th colspan="10">TPA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0xc8</td><td>65k</td><td>NF</td><td>Implied</td><td></td><td></td></tr>
</table>
<h2>TRB</h2>
<a name="TRB"> </a><p>Test and Reset Bit - AND the memory location with the
				accumulator, and set the Z flag from the result, then
				CLEAR all bits
				in the
				memory location that are set in the accumulator.
			</p>
<table class="optable"><tr><th colspan="10">TRB</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x14</td><td>cmos</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x1c</td><td>cmos</td><td>AM, OF, RS, UM, NF</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x1c</td><td>65k</td><td>RS, UM, NF</td><td>E indirect</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Take the operand, and AND it with the accumulator and evaluate
					the
					Z-flag. Then clear all bits in the operand
					that
					are set in the
					accumulator (basically AND with the inverse of the
					accumulator),
					and
					store the value back.
				</p><p>
					The use case for this opcode is the synchronization between
					processes
					and implements a variant of the
					"test-and-clear"
					primitive. Thus this is a Read-Modify-Write operation and will
					trigger a
					Memory-Lock between the read
					and write
					to make that
					operation atomic.
				</p><pre>
					Tmp &lt;= operand &amp; AC
					Z &lt;= Z(Tmp)
					operand
					&lt; operand | AC
				</pre><h3>65k</h3>
<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					The
					UM prefix determines whether the
					operand
					resides in user space or
					not.
				</p><p>
					The NF prefix allows to implement a read-modify-write AND of a
					memory
					location (without the usual and/store
					sequence) - without
					setting a flag though.
				</p><h2>TRP</h2>
<a name="TRP"> </a><p>Trap into 65k supervisor mode</p>
<table class="optable"><tr><th colspan="10">TRP</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xf4</td><td>65k</td><td></td><td>Immediate</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Trap into supervisor mode. Pushes the return address and the
					extended
					status byte
					on the hypervisor stack and jumps
					into
					hypervisor mode,
					using the appropriate trap vector. To return from
					the trap, the RTU
					operations is used.
					For
					compatibility with RTS, the
					return address minus one is stored on
					the stack.
				</p><pre>
					Stack(SP--) &lt;= > NextPC-1
					Stack(SP--) &lt;=
					&lt; NextPC-1
					Stack(SP--) &lt;= ExtStatus
					PC
					&lt;=
					TrapVector(Operand)
				</pre><h3>65k</h3>
<p>
					The address put on the stack always has the natural width of the
					processor.
					Currently no further prefix is
					supported.
					The stack
					pointer used is that of the hypervisor stack.
				</p><p>
					This opcode can be used in user mode as well as in hypervisor
					mode. The
					extended status byte
					contains the user mode
					bit, so that
					the RTU opcode knows whether to return
					to user mode or
					hypervisor
					mode.
				</p><p>
					The extendend status byte also contains width bits that store the
					width
					of the return
					address on stack. BYTE is not
					used, but the real
					width is stored with the
					width bits.
				</p><p>
					Note for future expansions the RS prefix may extend the trap
					number
					(the
					immediate operand)
					to word, or even wider
					widths.
				</p><h2>TSB</h2>
<a name="TSB"> </a><p>Test and Set Bit - AND the memory location with the
				accumulator,
				and set the Z flag from the result, then SET all
				bits in
				the
				memory location that are set in the accumulator.
			</p>
<table class="optable"><tr><th colspan="10">TSB</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x04</td><td>cmos</td><td>AM, OF, RS, UM, NF</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x0c</td><td>cmos</td><td>AM, OF, RS, UM, NF</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td>EXT</td><td>0x0c</td><td>65k</td><td>RS, UM, NF</td><td>E indirect</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Take the operand, and AND it with the accumulator and evaluate
					the
					Z-flag. Then OR the operand with the accumulator
					and store the
					value back.
				</p><p>
					The use case for this opcode is the synchronization between
					processes
					and implements a variant of the
					"test-and-set"
					primitive.
					Thus this is a Read-Modify-Write operation and will trigger a
					Memory-Lock between the read
					and write
					to make that operation
					atomic.
				</p><pre>
					Tmp &lt;= operand &amp; AC
					Z &lt;= Z(Tmp)
					operand
					&lt; operand | AC
				</pre><h3>65k</h3>
<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					The
					UM prefix determines whether the
					operand
					resides in user space or
					not.
				</p><p>
					The NF prefix allows to implement a read-modify-write OR of a
					memory
					location (without the usual or/store
					sequence)
					- without
					setting a flag though.
				</p><h2>TSX</h2>
<a name="TSX"> </a><p>Transfer the contents of the stack pointer into the X register
				(Note: needs RS to keep compatibility with 6502)
			</p>
<table class="optable"><tr><th colspan="10">TSX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xba</td><td></td><td>UM, NF, RS, LE</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the stack pointer to the X register
				</p><pre>
					X &lt;= S
				</pre><h3>65k</h3>
<p>
					The RS and LE prefixes determines the width of the operation. LE
					determines how to extend the value
					loaded to the
					full (natural)
					width. The NF flag allows to perform the
					operation
					without setting
					flags.
				</p><p>
					The stack pointer used is the current stack pointer. If the user
					mode
					bit is set in hypervisor mode,
					the stack
					pointer used is the
					user mode stack pointer. If the user
					mode
					bit is set in user mode,
					an
					ABORT exception is triggered.
				</p><h2>TSY</h2>
<a name="TSY"> </a><p>Transfer stack pointer to Y</p>
<table class="optable"><tr><th colspan="10">TSY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0xba</td><td>65k</td><td>NF, UM, RS, LE</td><td>Implied</td><td></td><td></td></tr>
</table>
<h2>TXA</h2>
<a name="TXA"> </a><p>Transfer the contents of the X register into the accumulator
			</p>
<table class="optable"><tr><th colspan="10">TXA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x8a</td><td></td><td>RS, LE, NF</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the X register to the accumulator
				</p><pre>
					A &lt;= X
				</pre><h3>65k</h3>
<p>
					The RS and LE prefixes determines the width of the operation. LE
					determines how to extend the value
					loaded to the
					full (natural)
					width. The NF flag allows to perform the
					operation
					without setting
					flags.
				</p><h2>TXS</h2>
<a name="TXS"> </a><p>Transfer the contents of X register into the stack pointer
				(Note: needs RS to keep compatibility with 6502)
			</p>
<table class="optable"><tr><th colspan="10">TXS</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x9a</td><td></td><td>RS, LE, UM</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the X register to the stack pointer.
				</p><pre>
					S &lt;= X
				</pre><h3>65k</h3>
<p>
					The RS and LE prefixes determines the width of the operation. LE
					determines how to extend the value
					loaded to the
					full (natural)
					width. The NF flag allows to perform the
					operation
					without setting
					flags.
				</p><p>
					The stack pointer used is the current stack pointer. If the user
					mode
					bit is set in hypervisor mode,
					the stack
					pointer used is the
					user mode stack pointer. If the user
					mode
					bit is set in user mode,
					an
					ABORT exception is triggered.
				</p><h2>TYA</h2>
<a name="TYA"> </a><p>Transfer the contents of the Y register into the accumulator
			</p>
<table class="optable"><tr><th colspan="10">TYA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x98</td><td></td><td>RS, LE, NF</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the Y register to the accumulator
				</p><pre>
					A &lt;= Y
				</pre><h3>65k</h3>
<p>
					The RS and LE prefixes determines the width of the operation. LE
					determines how to extend the value
					loaded to the
					full (natural)
					width. The NF flag allows to perform the
					operation
					without setting
					flags.
				</p><h2>TYS</h2>
<a name="TYS"> </a><p>Transfer Y to stack pointer</p>
<table class="optable"><tr><th colspan="10">TYS</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x9a</td><td>65k</td><td>LE, RS, UM</td><td>Implied</td><td></td><td></td></tr>
</table>
<h2>TZA</h2>
<a name="TZA"> </a><p>Transfer Z Register to AC</p>
<table class="optable"><tr><th colspan="10">TZA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Prefixes</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td>EXT</td><td>0x8a</td><td>cmos_indz</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
  </div><div class="h2"><div class="h2h"><div class="h2t"></div><h2>Disclaimer</h2><div class="toplink"><a href="#top">Top</a></div></div><div class="h2c">
All Copyrights are acknowledged.
The information here is provided under the terms as described
in <a href="af65002front.html#lic">the license section</a>.
    </div></div><hr />
Last updated 2012-04-23.
  </div></div><div id="footer"></div></div></body></html> 

