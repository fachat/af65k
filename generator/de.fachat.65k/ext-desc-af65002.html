<ul>
<li>
<a href="af65002opdesc.html#ADB">ADB: </a>
Add value to B register</li>
<li>
<a href="af65002opdesc.html#ADD">ADD: </a>
Add content of memory location to accumulator without using
				carry as input
			</li>
<li>
<a href="af65002opdesc.html#ADE">ADE: </a>
Add value to E register</li>
<li>
<a href="af65002opdesc.html#ADS">ADS: </a>
Add value to stack pointer</li>
<li>
<a href="af65002opdesc.html#ASR">ASR: </a>
Arithmetic Shift Right - Similar to LSR, but shifts in the sign
				of the value, not zero
			</li>
<li>
<a href="af65002opdesc.html#BCN">BCN: </a>
Bit Count: counts 1-bits in AC or in given location, stores
				number of 1-bits back in AC
			</li>
<li>
<a href="af65002opdesc.html#BEV">BEV: </a>
Branch on even</li>
<li>
<a href="af65002opdesc.html#BGES">BGES: </a>
Branch on signed greater or equal than</li>
<li>
<a href="af65002opdesc.html#BGT">BGT: </a>
Branch if greater - take branch when C flag is set but Z flag
				is
				clear
			</li>
<li>
<a href="af65002opdesc.html#BGTS">BGTS: </a>
Branch if greater - take branch when signed greater or equal G
				flag is set but Z flag is clear
			</li>
<li>
<a href="af65002opdesc.html#BLE">BLE: </a>
Branch if less or equal - take branch when C flag is clear or Z
				flag is set
			</li>
<li>
<a href="af65002opdesc.html#BLES">BLES: </a>
Branch if less or equal - take branch when signed greater or
				equal flag G is clear or Z flag is set
			</li>
<li>
<a href="af65002opdesc.html#BLTS">BLTS: </a>
Branch on signed less than</li>
<li>
<a href="af65002opdesc.html#BOD">BOD: </a>
Branch on odd</li>
<li>
<a href="af65002opdesc.html#BSW">BSW: </a>
Bit Swap: exchanges bit 0 with bit W-1, bit 1 with bit W-2 and
				so on.
			</li>
<li>
<a href="af65002opdesc.html#DAD">DAD: </a>
Decimal adjust of a normal ADC of two BCD numbers.</li>
<li>
<a href="af65002opdesc.html#DAS">DAS: </a>
Decimal adjust of a normal SBC of two BCD numbers.</li>
<li>
<a href="af65002opdesc.html#EXT">EXT: </a>
Extend a value in AC from RS to the full size. Setting LE
				defines the type of extension.
			</li>
<li>
<a href="af65002opdesc.html#FIL">FIL: </a>
Fill a memory area of size AC at address XR with a value from
				YR
			</li>
<li>
<a href="af65002opdesc.html#HBC">HBC: </a>
Highest Bit Clear: Determines the number of the highest bit
				that
				is set to zero.
			</li>
<li>
<a href="af65002opdesc.html#HBS">HBS: </a>
Highest Bit Set: Determines the number of the highest bit that
				is set to one.
			</li>
<li>
<a href="af65002opdesc.html#INV">INV: </a>
invert AC, i.e. set AC to the 2s-complement of AC</li>
<li>
<a href="af65002opdesc.html#LDB">LDB: </a>
Load B with an immediate value</li>
<li>
<a href="af65002opdesc.html#LDE">LDE: </a>
Load E with an immediate value</li>
<li>
<a href="af65002opdesc.html#LEA">LEA: </a>
Load Effective Address: compute the effective address and store
				it in the E (effective Address) register (always full width)
			</li>
<li>
<a href="af65002opdesc.html#LLA">LLA: </a>
Load linked AC - load the content from a memory location into
				accumulator, optimistic-locking the address for SCA
			</li>
<li>
<a href="af65002opdesc.html#MVN">MVN: </a>
Move block of data of size AC from XR to YR, count addresses
				down. All registers full size, interruptable
			</li>
<li>
<a href="af65002opdesc.html#MVP">MVP: </a>
Move block of data of size AC from XR to YR, count addresses
				down. All registers full size, interruptable
			</li>
<li>
<a href="af65002opdesc.html#PEA">PEA: </a>
Push Effective Address: compute the effective address and push
				it onto the stack (always full width)
			</li>
<li>
<a href="af65002opdesc.html#PHB">PHB: </a>
Push B onto stack (full width)</li>
<li>
<a href="af65002opdesc.html#PHE">PHE: </a>
Push E onto stack (always full width)</li>
<li>
<a href="af65002opdesc.html#PLB">PLB: </a>
Pull E from stack (full width)</li>
<li>
<a href="af65002opdesc.html#PLE">PLE: </a>
Pull E from stack (full width)</li>
<li>
<a href="af65002opdesc.html#PLL">PLL: </a>
Pull the contents of all registers from the stack</li>
<li>
<a href="af65002opdesc.html#PRB">PRB: </a>
Push and Replace Base register: Push base offset register to
				the
				stack, then transfer accumulator to the base register
			</li>
<li>
<a href="af65002opdesc.html#PSH">PSH: </a>
Push contents of all registers (A, X, Y, B, E) onto the stack
			</li>
<li>
<a href="af65002opdesc.html#RDL">RDL: </a>
Rotate Direct Left - similar to ROL, but do not shift in carry,
				but the highest bit of the original value
			</li>
<li>
<a href="af65002opdesc.html#RDR">RDR: </a>
Rotate Direct Right - similar to ROR, but do not shift in
				carry,
				but the lowest bit of the original value
			</li>
<li>
<a href="af65002opdesc.html#RMB">RMB: </a>
Read memory barrier: invalidates cache content (globally, or
				for
				a specific, given location)
			</li>
<li>
<a href="af65002opdesc.html#ROR">ROR: </a>
Rotate Right - shift accumulator one bit to the right, shifting
				in the carry flag in the highest bit, and shifting
				bit 0 into the
				carry flag instead.
			</li>
<li>
<a href="af65002opdesc.html#SAB">SAB: </a>
Swap A register with B register. Always done full width, no
				flags set.
			</li>
<li>
<a href="af65002opdesc.html#SAE">SAE: </a>
Swap AC with E register. Always done full width, no flags set.
			</li>
<li>
<a href="af65002opdesc.html#SAX">SAX: </a>
Swap AC with X register. Always done full width, no flags set.
			</li>
<li>
<a href="af65002opdesc.html#SAY">SAY: </a>
Swap AC with Y register. Always done full width, no flags set.
			</li>
<li>
<a href="af65002opdesc.html#SBB">SBB: </a>
Substract value from B register</li>
<li>
<a href="af65002opdesc.html#SBE">SBE: </a>
Add value to E register</li>
<li>
<a href="af65002opdesc.html#SBS">SBS: </a>
Substract value from stack pointer</li>
<li>
<a href="af65002opdesc.html#SCA">SCA: </a>
Store conditional - store the contents of AC into a memory
				location, if location has not been accessed since
				LLA with same
				address (and no other LLA in same thread)
			</li>
<li>
<a href="af65002opdesc.html#SEB">SEB: </a>
Swap E register with B register. Always done full width, no
				flags set.
			</li>
<li>
<a href="af65002opdesc.html#STZ">STZ: </a>
Store zero into a memory location</li>
<li>
<a href="af65002opdesc.html#SUB">SUB: </a>
Substract content of memory location from accumulator without
				using the carry flag as input
			</li>
<li>
<a href="af65002opdesc.html#SWP">SWP: </a>
swap upper and lower part nibble / byte / word / long word of a
				byte / word / long / quad (longlong) operand in Accumulator
			</li>
<li>
<a href="af65002opdesc.html#SXY">SXY: </a>
Swap X with Y register. Always done full width, no flags set.
			</li>
<li>
<a href="af65002opdesc.html#TAB">TAB: </a>
Transfer AC to B register</li>
<li>
<a href="af65002opdesc.html#TAE">TAE: </a>
Transfer AC to E register</li>
<li>
<a href="af65002opdesc.html#TBA">TBA: </a>
Transfer base register B to Accumulator</li>
<li>
<a href="af65002opdesc.html#TBE">TBE: </a>
Transfer content of B register into E register (full width)
			</li>
<li>
<a href="af65002opdesc.html#TEA">TEA: </a>
Transfer E register to Accumulator</li>
<li>
<a href="af65002opdesc.html#TEB">TEB: </a>
Transfer E to B register (full width)</li>
<li>
<a href="af65002opdesc.html#TPA">TPA: </a>
Transfer Program counter to Accumulator</li>
<li>
<a href="af65002opdesc.html#TRB">TRB: </a>
Test and Reset Bit - AND the memory location with the
				accumulator, and set the Z flag from the result, then CLEAR all bits
				in the
				memory location that are set in the accumulator.
			</li>
<li>
<a href="af65002opdesc.html#TSB">TSB: </a>
Test and Set Bit - AND the memory location with the
				accumulator,
				and set the Z flag from the result, then SET all bits in
				the
				memory location that are set in the accumulator.
			</li>
<li>
<a href="af65002opdesc.html#TSY">TSY: </a>
Transfer stack pointer to Y</li>
<li>
<a href="af65002opdesc.html#TYS">TYS: </a>
Transfer Y to stack pointer</li>
<li>
<a href="af65002opdesc.html#WMB">WMB: </a>
Write memory barrier: flushes dirty caches (globally, or for a
				specific, given location)
			</li>
</ul>
