<h2>List of operations</h2>
<ul>
<li>
<a href="#ADC">ADC</a>
 - Add content of memory location to accumulator</li>
<li>
<a href="#ALR">ALR</a>
 - AND the content of AC with an immediate value, then LSR the result; this opcode is undocumented.</li>
<li>
<a href="#ANC">ANC</a>
 - AND the content of the AC with an immediate value and move bit 7 into the carry flag; this opcode is
				undocumented.
			</li>
<li>
<a href="#AND">AND</a>
 - Bitwise AND accumulator with content of memory location</li>
<li>
<a href="#ANE">ANE</a>
 - Mostly transfer the value of XR to AC, then AND AC with an immediate value; this opcode is undocumented.</li>
<li>
<a href="#ARR">ARR</a>
 - Weird combination of AND and ROR; this
				opcode is undocumented.
			</li>
<li>
<a href="#ASL">ASL</a>
 - Arithmetic Shift Left - shift accumulator one bit to the left,
				shifting in zero in bit 0
			</li>
<li>
<a href="#ASO">ASO</a>
 - ASL operand and OR with AC; this opcode is undocumented.</li>
<li>
<a href="#BCC">BCC</a>
 - Branch on carry clear - take branch when C flag is cleared
			</li>
<li>
<a href="#BCS">BCS</a>
 - Branch on carry set - take branch when C flag is set</li>
<li>
<a href="#BEQ">BEQ</a>
 - Branch on equal - take branch when Z flag is set</li>
<li>
<a href="#BIT">BIT</a>
 - Bitwise test with accumulator - AND the memory location with
				the
				accumulator, and set N (=bit 7), V (=bit 7), Z
				(iff all bits
				zero) flags from the result. In case of the accumulator addressing,
				simply
				set the flags from the
				accumulator
			</li>
<li>
<a href="#BMI">BMI</a>
 - Branch on minus - take branch when N flag is set</li>
<li>
<a href="#BNE">BNE</a>
 - Branch on not equal - take branch when Z flag is cleared</li>
<li>
<a href="#BPL">BPL</a>
 - Branch on plus - take branch when N flag is cleared</li>
<li>
<a href="#BRK">BRK</a>
 - Starts the break routine.</li>
<li>
<a href="#BVC">BVC</a>
 - Branch on overflow clear - take branch when V flag is cleared
			</li>
<li>
<a href="#BVS">BVS</a>
 - Branch on overflow set - take branch when V flag is set</li>
<li>
<a href="#CLC">CLC</a>
 - Clear the C flag</li>
<li>
<a href="#CLD">CLD</a>
 - Clear the decimal (D) flag</li>
<li>
<a href="#CLI">CLI</a>
 - Clear the interrupt (I) flag</li>
<li>
<a href="#CLV">CLV</a>
 - Clear the overflow (V) flag</li>
<li>
<a href="#CMP">CMP</a>
 - Compare accumulator with content of memory location</li>
<li>
<a href="#CPX">CPX</a>
 - Compare X register with content of memory location</li>
<li>
<a href="#CPY">CPY</a>
 - Compare Y register with content of memory location</li>
<li>
<a href="#DCM">DCM</a>
 - DEC the content of a memory location, then CMP the result with AC; this opcode is undocumented.</li>
<li>
<a href="#DEC">DEC</a>
 - Decrement the content of a memory location by one</li>
<li>
<a href="#DEX">DEX</a>
 - Decrement the content of the X register by one</li>
<li>
<a href="#DEY">DEY</a>
 - Decrement the Y register by one</li>
<li>
<a href="#EOR">EOR</a>
 - Bitwise Exclusive-OR accumulator with content of memory
				location
			</li>
<li>
<a href="#HLT">HLT</a>
 - Crash the processor.</li>
<li>
<a href="#INC">INC</a>
 - Increment the content of a memory location by one</li>
<li>
<a href="#INS">INS</a>
 - INC the content of a memory location, then SBC the result from AC; this opcode is undocumented.</li>
<li>
<a href="#INX">INX</a>
 - Increment the content of the X register by one</li>
<li>
<a href="#INY">INY</a>
 - Increment the content of the Y register by one</li>
<li>
<a href="#JMP">JMP</a>
 - Jump to new code address</li>
<li>
<a href="#JSR">JSR</a>
 - Jump subroutine - jump to a new code location, save return
				address on stack for RTS
			</li>
<li>
<a href="#LAS">LAS</a>
 - AND the content of the memory location with the stack pointer and store in AC, XR, and the stack pointer; this
				opcode is undocumented.
			</li>
<li>
<a href="#LAX">LAX</a>
 - Load both AC and XR with the contents loaded from memory; this opcode is undocumented.</li>
<li>
<a href="#LDA">LDA</a>
 - Load accumulator</li>
<li>
<a href="#LDX">LDX</a>
 - Load X register</li>
<li>
<a href="#LDY">LDY</a>
 - Load Y register</li>
<li>
<a href="#LSE">LSE</a>
 - LSR operand and EOR with AC; this opcode is undocumented.</li>
<li>
<a href="#LSR">LSR</a>
 - Logical Shift Right - shift accumulator one bit to the right,
				shifting in zero in the highest bit
			</li>
<li>
<a href="#LXA">LXA</a>
 - OR the AC with #$EE, AND the result with an immediate value and store the result in AC and XR; this opcode is
				undocumented.
			</li>
<li>
<a href="#NOP">NOP</a>
 - No operation</li>
<li>
<a href="#ORA">ORA</a>
 - Bitwise OR accumulator with content of memory location</li>
<li>
<a href="#PHA">PHA</a>
 - Push contents of the accumulator onto the stack</li>
<li>
<a href="#PHP">PHP</a>
 - Push processor status register onto the stack</li>
<li>
<a href="#PLA">PLA</a>
 - Pull the contents of the accumulator from the stack</li>
<li>
<a href="#PLP">PLP</a>
 - Pull processor status register from the stack</li>
<li>
<a href="#RLA">RLA</a>
 - ROL operand and AND with AC; this opcode is undocumented.</li>
<li>
<a href="#ROL">ROL</a>
 - Rotate Left - shift accumulator one bit to the left, shifting
				in
				the carry flag in bit 0, and shifting the
				highest bit into the
				carry flag instead.
			</li>
<li>
<a href="#ROR">ROR</a>
 - Rotate Right - shift accumulator one bit to the right, shifting
				in the carry flag in the highest bit, and
				shifting
				bit 0 into the
				carry flag instead.
			</li>
<li>
<a href="#RRA">RRA</a>
 - ROR operand and ADC with AC; this opcode is undocumented.</li>
<li>
<a href="#RTI">RTI</a>
 - Return from interrupt</li>
<li>
<a href="#RTS">RTS</a>
 - Return from subroutine - read return address from stack</li>
<li>
<a href="#SAX">SAX</a>
 - Store the result of X AND A in the given address, without changing flags; this opcode is undocumented.</li>
<li>
<a href="#SBC">SBC</a>
 - Substract content of memory location from accumulator</li>
<li>
<a href="#SBX">SBX</a>
 - AND the AC and XR registers, substract an immediate value from that and store the result in XR. ; this opcode
				is undocumented.
			</li>
<li>
<a href="#SEC">SEC</a>
 - Set the C flag</li>
<li>
<a href="#SED">SED</a>
 - Set the decimal (D) flag</li>
<li>
<a href="#SEI">SEI</a>
 - Set the interrupt (I) flag</li>
<li>
<a href="#SHA">SHA</a>
 - AND the content of the AC, XR registers with the high address byte plus one and store in memory; this opcode is
				undocumented.
			</li>
<li>
<a href="#SHS">SHS</a>
 - AND the AC and XR registers, transfer the result to the stack pointer; this opcode is undocumented.</li>
<li>
<a href="#SHX">SHX</a>
 - AND the content of the XR registers with the high address byte plus one and store in memory; this opcode is
				undocumented.
			</li>
<li>
<a href="#SHY">SHY</a>
 - AND the content of the YR registers with the high address byte plus one and store in memory; this opcode is
				undocumented.
			</li>
<li>
<a href="#STA">STA</a>
 - Store the content of the accumulator into a memory location
			</li>
<li>
<a href="#STX">STX</a>
 - Store the content of the X register to memory.</li>
<li>
<a href="#STY">STY</a>
 - Store the content of the Y register to memory.</li>
<li>
<a href="#TAX">TAX</a>
 - Transfer the contents of accumulator into the X register</li>
<li>
<a href="#TAY">TAY</a>
 - Transfer the contents of accumulator into the Y register</li>
<li>
<a href="#TSX">TSX</a>
 - Transfer the contents of the stack pointer into the X register
				(Note: needs RS to keep compatibility with 6502)
			</li>
<li>
<a href="#TXA">TXA</a>
 - Transfer the contents of the X register into the accumulator
			</li>
<li>
<a href="#TXS">TXS</a>
 - Transfer the contents of X register into the stack pointer
				(Note: needs RS to keep compatibility with 6502)
			</li>
<li>
<a href="#TYA">TYA</a>
 - Transfer the contents of the Y register into the accumulator
			</li>
</ul>
<h2>ADC</h2>
<a name="ADC"> </a><p>Add content of memory location to accumulator</p>
<table class="optable"><tr><th colspan="10">ADC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x61</td><td></td><td>Zeropage indexed with X indirect 16bit</td><td></td></tr>
<tr><td></td><td>0x65</td><td></td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0x69</td><td></td><td>Immediate</td><td></td></tr>
<tr><td></td><td>0x6d</td><td></td><td>Absolute 16bit</td><td></td></tr>
<tr><td></td><td>0x71</td><td></td><td>Zeropage indirect 16bit indexed with Y</td><td></td></tr>
<tr><td></td><td>0x75</td><td></td><td>Zeropage indexed with X</td><td></td></tr>
<tr><td></td><td>0x79</td><td></td><td>Absolute 16bit indexed with Y</td><td></td></tr>
<tr><td></td><td>0x7d</td><td></td><td>Absolute 16bit indexed with X</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Add the operand to the accumulator and store back in the
					accumulator.
					Set the flags from the result. Use Decimal or
					Binary
					add depending
					on whether the
					decimal mode status bis is set or not
					respectively.
				</p><pre>
					AC, C, V &lt;= AC + Operand, C
					N &lt;= Tmp(7)
					Z &lt;=
					Z(Tmp)
				</pre><p>
					For a handling of the V-flag please see
					<a href="http://www.6502.org/tutorials/vflag.html">http://www.6502.org/tutorials/vflag.html</a>
					.
				</p><h2>ALR</h2>
<a name="ALR"> </a><p>AND the content of AC with an immediate value, then LSR the result; this opcode is undocumented.</p>
<table class="optable"><tr><th colspan="10">ALR</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x4b</td><td>undoc</td><td>Immediate</td><td></td></tr>
</table>
<h2>ANC</h2>
<a name="ANC"> </a><p>AND the content of the AC with an immediate value and move bit 7 into the carry flag; this opcode is
				undocumented.
			</p>
<table class="optable"><tr><th colspan="10">ANC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x0b</td><td>undoc</td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0x2b</td><td>undoc</td><td>Zeropage</td><td></td></tr>
</table>
<h2>AND</h2>
<a name="AND"> </a><p>Bitwise AND accumulator with content of memory location</p>
<table class="optable"><tr><th colspan="10">AND</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x21</td><td></td><td>Zeropage indexed with X indirect 16bit</td><td></td></tr>
<tr><td></td><td>0x25</td><td></td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0x29</td><td></td><td>Immediate</td><td></td></tr>
<tr><td></td><td>0x2d</td><td></td><td>Absolute 16bit</td><td></td></tr>
<tr><td></td><td>0x31</td><td></td><td>Zeropage indirect 16bit indexed with Y</td><td></td></tr>
<tr><td></td><td>0x35</td><td></td><td>Zeropage indexed with X</td><td></td></tr>
<tr><td></td><td>0x39</td><td></td><td>Absolute 16bit indexed with Y</td><td></td></tr>
<tr><td></td><td>0x3d</td><td></td><td>Absolute 16bit indexed with X</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Bitwise AND the accumulator with the operand and store back in
					the
					accumulator.
					Set the flags from the result.
				</p><pre>
					AC &lt;= AC &amp; Operand
					N &lt;= Tmp(7)
					Z &lt;=
					Z(Tmp)
				</pre><h2>ANE</h2>
<a name="ANE"> </a><p>Mostly transfer the value of XR to AC, then AND AC with an immediate value; this opcode is undocumented.</p>
<table class="optable"><tr><th colspan="10">ANE</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x8b</td><td>undoc</td><td>Immediate</td><td></td></tr>
</table>
<h3>Description</h3>
<pre>
					A = (A | #$EE) & X & #byte
					same as
					A = ((A & #$11 & X) | (#$EE & X)) & #byte
				</pre><p>
					The internal parameter $11 may occasionally be $10, $01, or even $00 in real systems. This may depend
					on the state
					of the data left on the external data bus. See "64doc.txt"
				</p><h2>ARR</h2>
<a name="ARR"> </a><p>Weird combination of AND and ROR; this
				opcode is undocumented.
			</p>
<table class="optable"><tr><th colspan="10">ARR</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x6b</td><td>undoc</td><td>Absolute 16bit indexed with Y</td><td></td></tr>
</table>
<h3>Description</h3>
<p>This operation is not the harmless combination of AND and ROR: it affects the V-flag and has
					a specific decimal mode. See 64doc.txt for more details.
				</p><h2>ASL</h2>
<a name="ASL"> </a><p>Arithmetic Shift Left - shift accumulator one bit to the left,
				shifting in zero in bit 0
			</p>
<table class="optable"><tr><th colspan="10">ASL</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x06</td><td></td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0x0a</td><td></td><td>Accumulator</td><td></td></tr>
<tr><td></td><td>0x0e</td><td></td><td>Absolute 16bit</td><td></td></tr>
<tr><td></td><td>0x16</td><td></td><td>Zeropage indexed with X</td><td></td></tr>
<tr><td></td><td>0x1e</td><td></td><td>Absolute 16bit indexed with X</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Shift the operand or accumulator left one bit (i.e. multiply by
					2).
					Shift
					in a zero from the right.
					The bit shifted
					out is moved into
					the carry flag.
					Note this opcode is a read-modify-write opcode and
					not only has
					memory-oriented
					addressing modes but can work
					on the
					accumulator alone as well.
				</p><pre>
					C &lt;= AC(7)
					AC(7-1) &lt;= AC(6-0)
					AC(0) &lt;= 0
					N
					&lt;= AC7)
					Z &lt;= Z(AC)
				</pre><h2>ASO</h2>
<a name="ASO"> </a><p>Synonyms: SLO</p>
<p>ASL operand and OR with AC; this opcode is undocumented.</p>
<table class="optable"><tr><th colspan="10">ASO</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x0f</td><td>undoc</td><td>Absolute 16bit</td><td></td></tr>
<tr><td></td><td>0x1f</td><td>undoc</td><td>Absolute 16bit indexed with X</td><td></td></tr>
<tr><td></td><td>0x1b</td><td>undoc</td><td>Absolute 16bit indexed with Y</td><td></td></tr>
<tr><td></td><td>0x07</td><td>undoc</td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0x17</td><td>undoc</td><td>Zeropage indexed with X</td><td></td></tr>
<tr><td></td><td>0x03</td><td>undoc</td><td>Zeropage indexed with X indirect 16bit</td><td></td></tr>
<tr><td></td><td>0x13</td><td>undoc</td><td>Zeropage indirect 16bit indexed with Y</td><td></td></tr>
</table>
<h2>BCC</h2>
<a name="BCC"> </a><p>Synonyms: BLT</p>
<p>Branch on carry clear - take branch when C flag is cleared
			</p>
<table class="optable"><tr><th colspan="10">BCC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x90</td><td></td><td>Relative</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					carry status flag is clear. After a CMP this is a
					synonym for "less
					than".
					The parameter is
					a signed 8-bit value, i.e.
					jump distances can be from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand when N=1 else NextPC
				</pre><h2>BCS</h2>
<a name="BCS"> </a><p>Synonyms: BGE</p>
<p>Branch on carry set - take branch when C flag is set</p>
<table class="optable"><tr><th colspan="10">BCS</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0xB0</td><td></td><td>Relative</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					carry status flag is set. After a CMP this is a
					synonym for "greater or
					equal".
					The
					parameter is a signed 8-bit
					value, i.e. jump distances can be from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand when N=1 else NextPC
				</pre><h2>BEQ</h2>
<a name="BEQ"> </a><p>Branch on equal - take branch when Z flag is set</p>
<table class="optable"><tr><th colspan="10">BEQ</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0xf0</td><td></td><td>Relative</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					zero status flag is set.
					The parameter is a signed
					8-bit value, i.e. jump distances can be
					from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand when N=1 else NextPC
				</pre><h2>BIT</h2>
<a name="BIT"> </a><p>Bitwise test with accumulator - AND the memory location with
				the
				accumulator, and set N (=bit 7), V (=bit 7), Z
				(iff all bits
				zero) flags from the result. In case of the accumulator addressing,
				simply
				set the flags from the
				accumulator
			</p>
<table class="optable"><tr><th colspan="10">BIT</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x24</td><td></td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0x2c</td><td></td><td>Absolute 16bit</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Read the operand and set the N and V flags from the value (from
					the
					highest and next-to-highest bit respectively).
					Then take the
					operand, and AND it with the accumulator and evaluate the
					Z-flag.
				</p><pre>
					N &lt;= Operand(7)
					V &lt;= Operand(6)
					Tmp &lt;=
					Operand &amp; AC
					Z &lt;= Z(Tmp)
				</pre><h2>BMI</h2>
<a name="BMI"> </a><p>Branch on minus - take branch when N flag is set</p>
<table class="optable"><tr><th colspan="10">BMI</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x30</td><td></td><td>Relative</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					negative status flag is set.
					The parameter is a
					signed 8-bit value, i.e. jump distances can
					be from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand when N=1 else NextPC
				</pre><h2>BNE</h2>
<a name="BNE"> </a><p>Branch on not equal - take branch when Z flag is cleared</p>
<table class="optable"><tr><th colspan="10">BNE</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0xD0</td><td></td><td>Relative</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					zero status flag is clear.
					The parameter is a
					signed 8-bit value, i.e. jump distances can
					be from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand when N=1 else NextPC
				</pre><h2>BPL</h2>
<a name="BPL"> </a><p>Branch on plus - take branch when N flag is cleared</p>
<table class="optable"><tr><th colspan="10">BPL</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x10</td><td></td><td>Relative</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					negative status flag is clear.
					The parameter is a
					signed 8-bit value, i.e. jump distances
					can be from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand when N=1 else NextPC
				</pre><h2>BRK</h2>
<a name="BRK"> </a><p>Starts the break routine.</p>
<table class="optable"><tr><th colspan="10">BRK</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x00</td><td></td><td>Immediate</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					The BRK opcode is used to jump to the BRK vector. It pushes the
					return address and the status on the stack, then
					reads the BRK
					vector
					(doubling as IRQ vector) and jumps there.
				</p><p>
					Please note that the address put on the stack is the address of
					the next
					instruction. And the BRK opcode is using
					the immediate
					addressing
					mode
					(although the MOS manual does not state it). Thus the
					address put on the
					stack is two
					bytes behind the address of the BRK!
				</p><p>
					Before storing the status on the stack, the opcode sets the
					I-flag to
					avoid recursive calling of the interrupt
					routine.
				</p><p>
					When storing the status on the stack, the B-flag is set to
					indicate
					that
					the shared IRQ/BRK vector has been called
					from a BRK
					and not an IRQ.
				</p><pre>
					Stack(SP--) &lt;= > NextPC
					Stack(SP--) &lt;= &lt;
					NextPC
					Stack(SP--) &lt;= Status | B | I
					PC
					&lt;= ($FFFE)
				</pre><h2>BVC</h2>
<a name="BVC"> </a><p>Branch on overflow clear - take branch when V flag is cleared
			</p>
<table class="optable"><tr><th colspan="10">BVC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x50</td><td></td><td>Relative</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					overflow status flag is clear.
					The parameter is a
					signed 8-bit value, i.e. jump distances
					can be from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand when N=1 else NextPC
				</pre><h2>BVS</h2>
<a name="BVS"> </a><p>Branch on overflow set - take branch when V flag is set</p>
<table class="optable"><tr><th colspan="10">BVS</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x70</td><td></td><td>Relative</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					overflow status flag is set.
					The parameter is a
					signed 8-bit value, i.e. jump distances can
					be from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand when N=1 else NextPC
				</pre><h2>CLC</h2>
<a name="CLC"> </a><p>Clear the C flag</p>
<table class="optable"><tr><th colspan="10">CLC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x18</td><td></td><td>Implied</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Clear the carry status flag.
				</p><h2>CLD</h2>
<a name="CLD"> </a><p>Clear the decimal (D) flag</p>
<table class="optable"><tr><th colspan="10">CLD</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0xd8</td><td></td><td>Implied</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Clear the decimal mode status flag.
				</p><h2>CLI</h2>
<a name="CLI"> </a><p>Clear the interrupt (I) flag</p>
<table class="optable"><tr><th colspan="10">CLI</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x58</td><td></td><td>Implied</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Clear the interrupt status flag.
				</p><h2>CLV</h2>
<a name="CLV"> </a><p>Clear the overflow (V) flag</p>
<table class="optable"><tr><th colspan="10">CLV</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0xb8</td><td></td><td>Implied</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Clear the overflow status flag.
				</p><h2>CMP</h2>
<a name="CMP"> </a><p>Compare accumulator with content of memory location</p>
<table class="optable"><tr><th colspan="10">CMP</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0xc1</td><td></td><td>Zeropage indexed with X indirect 16bit</td><td></td></tr>
<tr><td></td><td>0xc5</td><td></td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0xc9</td><td></td><td>Immediate</td><td></td></tr>
<tr><td></td><td>0xcd</td><td></td><td>Absolute 16bit</td><td></td></tr>
<tr><td></td><td>0xd1</td><td></td><td>Zeropage indirect 16bit indexed with Y</td><td></td></tr>
<tr><td></td><td>0xd5</td><td></td><td>Zeropage indexed with X</td><td></td></tr>
<tr><td></td><td>0xd9</td><td></td><td>Absolute 16bit indexed with Y</td><td></td></tr>
<tr><td></td><td>0xdd</td><td></td><td>Absolute 16bit indexed with X</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Compare the operand with the accumulator and set the flags
					appropriately.
					I.e. substract the operand from AC with
					an
					implicitely set carry in
					binary mode (even if
					decimal mode status bit
					is set), and set the flags from the result.
				</p><pre>
					Tmp, C &lt;= Y - Operand, C=1
					N &lt;= Tmp(7)
					Z &lt;=
					Z(Tmp)
				</pre><h2>CPX</h2>
<a name="CPX"> </a><p>Compare X register with content of memory location</p>
<table class="optable"><tr><th colspan="10">CPX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0xe0</td><td></td><td>Immediate</td><td></td></tr>
<tr><td></td><td>0xe4</td><td></td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0xec</td><td></td><td>Absolute 16bit</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Compare the operand with the X register and set the flags
					appropriately.
					I.e. substract the operand from X with an
					implicitly
					set carry in
					binary mode (even if
					decimal mode status bit is set),
					and set the flags from the result.
				</p><pre>
					Tmp, C &lt;= X - Operand, C=1
					N &lt;= Tmp(7)
					Z &lt;=
					Z(Tmp)
				</pre><h2>CPY</h2>
<a name="CPY"> </a><p>Compare Y register with content of memory location</p>
<table class="optable"><tr><th colspan="10">CPY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0xc0</td><td></td><td>Immediate</td><td></td></tr>
<tr><td></td><td>0xc4</td><td></td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0xcc</td><td></td><td>Absolute 16bit</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Compare the operand with the Y register and set the flags
					appropriately.
					I.e. substract the operand from Y with an
					implicitly
					set carry in
					binary mode (even if
					decimal mode status bit is set),
					and set the flags from the result.
				</p><pre>
					Tmp, C &lt;= Y - Operand, C=1
					N &lt;= Tmp(7)
					Z &lt;=
					Z(Tmp)
				</pre><h2>DCM</h2>
<a name="DCM"> </a><p>Synonyms: DCP</p>
<p>DEC the content of a memory location, then CMP the result with AC; this opcode is undocumented.</p>
<table class="optable"><tr><th colspan="10">DCM</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0xcf</td><td>undoc</td><td>Absolute 16bit</td><td></td></tr>
<tr><td></td><td>0xdf</td><td>undoc</td><td>Absolute 16bit indexed with X</td><td></td></tr>
<tr><td></td><td>0xdb</td><td>undoc</td><td>Absolute 16bit indexed with Y</td><td></td></tr>
<tr><td></td><td>0xc7</td><td>undoc</td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0xd7</td><td>undoc</td><td>Zeropage indexed with X</td><td></td></tr>
<tr><td></td><td>0xc3</td><td>undoc</td><td>Zeropage indexed with X indirect 16bit</td><td></td></tr>
<tr><td></td><td>0xd3</td><td>undoc</td><td>Zeropage indirect 16bit indexed with Y</td><td></td></tr>
</table>
<h2>DEC</h2>
<a name="DEC"> </a><p>Decrement the content of a memory location by one</p>
<table class="optable"><tr><th colspan="10">DEC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0xc6</td><td></td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0xce</td><td></td><td>Absolute 16bit</td><td></td></tr>
<tr><td></td><td>0xd6</td><td></td><td>Zeropage indexed with X</td><td></td></tr>
<tr><td></td><td>0xde</td><td></td><td>Absolute 16bit indexed with X</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Decrement the operand by one, i.e. binary substract one.
					Note this
					opcode is a read-modify-write opcode and not
					only has
					memory-oriented addressing modes but can work
					on the accumulator
					alone as well.
				</p><pre>
					Operand &lt;= Operand - 1
					N &lt;= OperandC7)
					Z &lt;=
					Z(AC)
				</pre><h2>DEX</h2>
<a name="DEX"> </a><p>Decrement the content of the X register by one</p>
<table class="optable"><tr><th colspan="10">DEX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0xca</td><td></td><td>Implied</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Decrement the X register by one (binary).
				</p><pre>
					X &lt;= X-1
				</pre><h2>DEY</h2>
<a name="DEY"> </a><p>Decrement the Y register by one</p>
<table class="optable"><tr><th colspan="10">DEY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x88</td><td></td><td>Implied</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Decrement the Y register by one (binary).
				</p><pre>
					Y &lt;= Y-1
				</pre><h2>EOR</h2>
<a name="EOR"> </a><p>Bitwise Exclusive-OR accumulator with content of memory
				location
			</p>
<table class="optable"><tr><th colspan="10">EOR</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x41</td><td></td><td>Zeropage indexed with X indirect 16bit</td><td></td></tr>
<tr><td></td><td>0x45</td><td></td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0x49</td><td></td><td>Immediate</td><td></td></tr>
<tr><td></td><td>0x4d</td><td></td><td>Absolute 16bit</td><td></td></tr>
<tr><td></td><td>0x51</td><td></td><td>Zeropage indirect 16bit indexed with Y</td><td></td></tr>
<tr><td></td><td>0x55</td><td></td><td>Zeropage indexed with X</td><td></td></tr>
<tr><td></td><td>0x59</td><td></td><td>Absolute 16bit indexed with Y</td><td></td></tr>
<tr><td></td><td>0x5d</td><td></td><td>Absolute 16bit indexed with X</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Bitwise Exclusive-OR the accumulator with the operand and store
					back in
					the
					accumulator.
					Set the flags from the
					result.
				</p><pre>
					AC &lt;= AC ^ Operand
					N &lt;= Tmp(7)
					Z &lt;= Z(Tmp)
				</pre><h2>HLT</h2>
<a name="HLT"> </a><p>Crash the processor.</p>
<table class="optable"><tr><th colspan="10">HLT</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x02</td><td>undoc</td><td>Implied</td><td></td></tr>
<tr><td></td><td>0x12</td><td>undoc</td><td>Implied</td><td></td></tr>
<tr><td></td><td>0x22</td><td>undoc</td><td>Implied</td><td></td></tr>
<tr><td></td><td>0x32</td><td>undoc</td><td>Implied</td><td></td></tr>
<tr><td></td><td>0x42</td><td>undoc</td><td>Implied</td><td></td></tr>
<tr><td></td><td>0x52</td><td>undoc</td><td>Implied</td><td></td></tr>
<tr><td></td><td>0x62</td><td>undoc</td><td>Implied</td><td></td></tr>
<tr><td></td><td>0x72</td><td>undoc</td><td>Implied</td><td></td></tr>
<tr><td></td><td>0x82</td><td>undoc</td><td>Implied</td><td></td></tr>
<tr><td></td><td>0x92</td><td>undoc</td><td>Implied</td><td></td></tr>
<tr><td></td><td>0xb2</td><td>undoc</td><td>Implied</td><td></td></tr>
<tr><td></td><td>0xc2</td><td>undoc</td><td>Implied</td><td></td></tr>
<tr><td></td><td>0xd2</td><td>undoc</td><td>Implied</td><td></td></tr>
<tr><td></td><td>0xe2</td><td>undoc</td><td>Implied</td><td></td></tr>
<tr><td></td><td>0xf2</td><td>undoc</td><td>Implied</td><td></td></tr>
</table>
<h3>Description</h3>
<p>When this opcode is executed, the NMOS processor stops execution. No hardware interrupts will be
					executed also.
					This is due to the fact that the internal state engine looses its "running bit" and
					just stops running.
				</p><p>Opcodes 0x82, 0xc2 and 0xe2 are sometimes listed as "NOP, Jams rarely"</p><h2>INC</h2>
<a name="INC"> </a><p>Increment the content of a memory location by one</p>
<table class="optable"><tr><th colspan="10">INC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0xe6</td><td></td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0xee</td><td></td><td>Absolute 16bit</td><td></td></tr>
<tr><td></td><td>0xf6</td><td></td><td>Zeropage indexed with X</td><td></td></tr>
<tr><td></td><td>0xfe</td><td></td><td>Absolute 16bit indexed with X</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Increment the operand by one, i.e. binary add one.
					Note this
					opcode is a read-modify-write opcode and not only has
					memory-oriented addressing modes but can work
					on the accumulator
					alone as well.
				</p><pre>
					Operand &lt;= Operand + 1
					N &lt;= OperandC7)
					Z &lt;=
					Z(AC)
				</pre><h2>INS</h2>
<a name="INS"> </a><p>Synonyms: ISC</p>
<p>INC the content of a memory location, then SBC the result from AC; this opcode is undocumented.</p>
<table class="optable"><tr><th colspan="10">INS</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0xef</td><td>undoc</td><td>Absolute 16bit</td><td></td></tr>
<tr><td></td><td>0xff</td><td>undoc</td><td>Absolute 16bit indexed with X</td><td></td></tr>
<tr><td></td><td>0xfb</td><td>undoc</td><td>Absolute 16bit indexed with Y</td><td></td></tr>
<tr><td></td><td>0xe7</td><td>undoc</td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0xf7</td><td>undoc</td><td>Zeropage indexed with X</td><td></td></tr>
<tr><td></td><td>0xe3</td><td>undoc</td><td>Zeropage indexed with X indirect 16bit</td><td></td></tr>
<tr><td></td><td>0xf3</td><td>undoc</td><td>Zeropage indirect 16bit indexed with Y</td><td></td></tr>
</table>
<h2>INX</h2>
<a name="INX"> </a><p>Increment the content of the X register by one</p>
<table class="optable"><tr><th colspan="10">INX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0xe8</td><td></td><td>Implied</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Increment the X register by one (binary).
				</p><pre>
					X &lt;= X+1
				</pre><h2>INY</h2>
<a name="INY"> </a><p>Increment the content of the Y register by one</p>
<table class="optable"><tr><th colspan="10">INY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0xc8</td><td></td><td>Implied</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Increment the Y register by one (binary).
				</p><pre>
					Y &lt;= Y+1
				</pre><h2>JMP</h2>
<a name="JMP"> </a><p>Jump to new code address</p>
<table class="optable"><tr><th colspan="10">JMP</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x4c</td><td></td><td>Address</td><td></td></tr>
<tr><td></td><td>0x6c</td><td></td><td>Absolute indirect 16bit</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Jump to the address given by the operand (as computed depending
					on the
					respective addressing mode).
				</p><pre>
					PC &lt;= Operand
				</pre><h2>JSR</h2>
<a name="JSR"> </a><p>Jump subroutine - jump to a new code location, save return
				address on stack for RTS
			</p>
<table class="optable"><tr><th colspan="10">JSR</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x20</td><td></td><td>Address</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Jump to the address given by the operand (as computed depending
					on the
					respective addressing mode) and
					store the
					return address (-1)
					on the stack to prepare for the RTS opcode
				</p><pre>
					Stack(SP--) &lt;= > NextPC-1
					Stack(SP--) &lt;=
					&lt; NextPC-1
					PC &lt;= Operand
				</pre><h2>LAS</h2>
<a name="LAS"> </a><p>AND the content of the memory location with the stack pointer and store in AC, XR, and the stack pointer; this
				opcode is undocumented.
			</p>
<table class="optable"><tr><th colspan="10">LAS</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0xbb</td><td>undoc</td><td>Absolute 16bit indexed with Y</td><td></td></tr>
</table>
<h2>LAX</h2>
<a name="LAX"> </a><p>Load both AC and XR with the contents loaded from memory; this opcode is undocumented.</p>
<table class="optable"><tr><th colspan="10">LAX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0xaf</td><td>undoc</td><td>Absolute 16bit</td><td></td></tr>
<tr><td></td><td>0xbf</td><td>undoc</td><td>Absolute 16bit indexed with Y</td><td></td></tr>
<tr><td></td><td>0xa7</td><td>undoc</td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0xb7</td><td>undoc</td><td>Zeropage indexed with Y</td><td></td></tr>
<tr><td></td><td>0xa3</td><td>undoc</td><td>Zeropage indexed with X indirect 16bit</td><td></td></tr>
<tr><td></td><td>0xb3</td><td>undoc</td><td>Zeropage indirect 16bit indexed with Y</td><td></td></tr>
</table>
<h2>LDA</h2>
<a name="LDA"> </a><p>Load accumulator</p>
<table class="optable"><tr><th colspan="10">LDA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0xa1</td><td></td><td>Zeropage indexed with X indirect 16bit</td><td></td></tr>
<tr><td></td><td>0xa5</td><td></td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0xa9</td><td></td><td>Immediate</td><td></td></tr>
<tr><td></td><td>0xad</td><td></td><td>Absolute 16bit</td><td></td></tr>
<tr><td></td><td>0xb1</td><td></td><td>Zeropage indirect 16bit indexed with Y</td><td></td></tr>
<tr><td></td><td>0xb5</td><td></td><td>Zeropage indexed with X</td><td></td></tr>
<tr><td></td><td>0xb9</td><td></td><td>Absolute 16bit indexed with Y</td><td></td></tr>
<tr><td></td><td>0xbd</td><td></td><td>Absolute 16bit indexed with X</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Read the operand and store it in the Accumulator. Set the flags
					appropriately.
				</p><pre>
					N &lt;= Operand(7)
					Z &lt;= Z(Operand)
					Y &lt;= Operand
				</pre><h2>LDX</h2>
<a name="LDX"> </a><p>Load X register</p>
<table class="optable"><tr><th colspan="10">LDX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0xa2</td><td></td><td>Immediate</td><td></td></tr>
<tr><td></td><td>0xa6</td><td></td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0xae</td><td></td><td>Absolute 16bit</td><td></td></tr>
<tr><td></td><td>0xb6</td><td></td><td>Zeropage indexed with Y</td><td></td></tr>
<tr><td></td><td>0xbe</td><td></td><td>Absolute 16bit indexed with Y</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Read the operand and store it in the X register. Set the flags
					appropriately.
				</p><pre>
					N &lt;= Operand(7)
					Z &lt;= Z(Operand)
					X &lt;= Operand
				</pre><h2>LDY</h2>
<a name="LDY"> </a><p>Load Y register</p>
<table class="optable"><tr><th colspan="10">LDY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0xa0</td><td></td><td>Immediate</td><td></td></tr>
<tr><td></td><td>0xa4</td><td></td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0xac</td><td></td><td>Absolute 16bit</td><td></td></tr>
<tr><td></td><td>0xb4</td><td></td><td>Zeropage indexed with X</td><td></td></tr>
<tr><td></td><td>0xbc</td><td></td><td>Absolute 16bit indexed with X</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Read the operand and store it in the Y register. Set the flags
					appropriately.
				</p><pre>
					N &lt;= Operand(7)
					Z &lt;= Z(Operand)
					Y &lt;= Operand
				</pre><h2>LSE</h2>
<a name="LSE"> </a><p>Synonyms: SRE</p>
<p>LSR operand and EOR with AC; this opcode is undocumented.</p>
<table class="optable"><tr><th colspan="10">LSE</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x4f</td><td>undoc</td><td>Absolute 16bit</td><td></td></tr>
<tr><td></td><td>0x5f</td><td>undoc</td><td>Absolute 16bit indexed with X</td><td></td></tr>
<tr><td></td><td>0x5b</td><td>undoc</td><td>Absolute 16bit indexed with Y</td><td></td></tr>
<tr><td></td><td>0x47</td><td>undoc</td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0x57</td><td>undoc</td><td>Zeropage indexed with X</td><td></td></tr>
<tr><td></td><td>0x43</td><td>undoc</td><td>Zeropage indexed with X indirect 16bit</td><td></td></tr>
<tr><td></td><td>0x53</td><td>undoc</td><td>Zeropage indirect 16bit indexed with Y</td><td></td></tr>
</table>
<h2>LSR</h2>
<a name="LSR"> </a><p>Logical Shift Right - shift accumulator one bit to the right,
				shifting in zero in the highest bit
			</p>
<table class="optable"><tr><th colspan="10">LSR</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x46</td><td></td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0x4a</td><td></td><td>Accumulator</td><td></td></tr>
<tr><td></td><td>0x4e</td><td></td><td>Absolute 16bit</td><td></td></tr>
<tr><td></td><td>0x56</td><td></td><td>Zeropage indexed with X</td><td></td></tr>
<tr><td></td><td>0x5e</td><td></td><td>Absolute 16bit indexed with X</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Shift the operand or accumulator right one bit (i.e. divide by
					2). Shift
					in a zero from the left.
					The bit shifted
					out is moved into
					the carry flag.
					Note this opcode is a read-modify-write opcode and
					not only has
					memory-oriented
					addressing modes but can work
					on the
					accumulator alone as well.
				</p><pre>
					C &lt;= AC(0)
					AC(6-0) &lt;= AC(7-1)
					AC(7) &lt;= 0
					N
					&lt;= AC7)
					Z &lt;= Z(AC)
				</pre><h2>LXA</h2>
<a name="LXA"> </a><p>OR the AC with #$EE, AND the result with an immediate value and store the result in AC and XR; this opcode is
				undocumented.
			</p>
<table class="optable"><tr><th colspan="10">LXA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0xab</td><td>undoc</td><td>Immediate</td><td></td></tr>
</table>
<h3>Description</h3>
<p>This operation looks similar to ANE, just that it stores the result in AC and XR instead of AC only.</p><h2>NOP</h2>
<a name="NOP"> </a><p>No operation</p>
<table class="optable"><tr><th colspan="10">NOP</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0xea</td><td></td><td>Implied</td><td></td></tr>
<tr><td></td><td>0x1a</td><td>undoc</td><td>Implied</td><td></td></tr>
<tr><td></td><td>0x3a</td><td>undoc</td><td>Implied</td><td></td></tr>
<tr><td></td><td>0x5a</td><td>undoc</td><td>Implied</td><td></td></tr>
<tr><td></td><td>0x7a</td><td>undoc</td><td>Implied</td><td></td></tr>
<tr><td></td><td>0xda</td><td>undoc</td><td>Implied</td><td></td></tr>
<tr><td></td><td>0xfa</td><td>undoc</td><td>Implied</td><td></td></tr>
<tr><td></td><td>0x80</td><td>undoc</td><td>Implied</td><td></td></tr>
<tr><td></td><td>0x04</td><td>undoc</td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0x14</td><td>undoc</td><td>Zeropage indexed with X</td><td></td></tr>
<tr><td></td><td>0x34</td><td>undoc</td><td>Zeropage indexed with X</td><td></td></tr>
<tr><td></td><td>0x44</td><td>undoc</td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0x54</td><td>undoc</td><td>Zeropage indexed with X</td><td></td></tr>
<tr><td></td><td>0x64</td><td>undoc</td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0x74</td><td>undoc</td><td>Zeropage indexed with X</td><td></td></tr>
<tr><td></td><td>0xd4</td><td>undoc</td><td>Zeropage indexed with X</td><td></td></tr>
<tr><td></td><td>0xf4</td><td>undoc</td><td>Zeropage indexed with X</td><td></td></tr>
<tr><td></td><td>0x0c</td><td>undoc</td><td>Absolute 16bit</td><td></td></tr>
<tr><td></td><td>0x1c</td><td>undoc</td><td>Absolute 16bit indexed with X</td><td></td></tr>
<tr><td></td><td>0x3c</td><td>undoc</td><td>Absolute 16bit indexed with X</td><td></td></tr>
<tr><td></td><td>0x5c</td><td>undoc</td><td>Absolute 16bit indexed with X</td><td></td></tr>
<tr><td></td><td>0x7c</td><td>undoc</td><td>Absolute 16bit indexed with X</td><td></td></tr>
<tr><td></td><td>0xdc</td><td>undoc</td><td>Absolute 16bit indexed with X</td><td></td></tr>
<tr><td></td><td>0xfc</td><td>undoc</td><td>Absolute 16bit indexed with X</td><td></td></tr>
<tr><td></td><td>0x89</td><td>undoc</td><td>Immediate</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					No Operation.
				</p><h2>ORA</h2>
<a name="ORA"> </a><p>Bitwise OR accumulator with content of memory location</p>
<table class="optable"><tr><th colspan="10">ORA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x01</td><td></td><td>Zeropage indexed with X indirect 16bit</td><td></td></tr>
<tr><td></td><td>0x05</td><td></td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0x09</td><td></td><td>Immediate</td><td></td></tr>
<tr><td></td><td>0x0d</td><td></td><td>Absolute 16bit</td><td></td></tr>
<tr><td></td><td>0x11</td><td></td><td>Zeropage indirect 16bit indexed with Y</td><td></td></tr>
<tr><td></td><td>0x15</td><td></td><td>Zeropage indexed with X</td><td></td></tr>
<tr><td></td><td>0x19</td><td></td><td>Absolute 16bit indexed with Y</td><td></td></tr>
<tr><td></td><td>0x1d</td><td></td><td>Absolute 16bit indexed with X</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Bitwise OR the accumulator with the operand and store back in the
					accumulator.
					Set the flags from the result.
				</p><pre>
					AC &lt;= AC | Operand
					N &lt;= Tmp(7)
					Z &lt;= Z(Tmp)
				</pre><h2>PHA</h2>
<a name="PHA"> </a><p>Push contents of the accumulator onto the stack</p>
<table class="optable"><tr><th colspan="10">PHA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x48</td><td></td><td>Implied</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Push the content of the accumulator on the stack.
				</p><pre>
					Stack(SP--) &lt;= A
				</pre><h2>PHP</h2>
<a name="PHP"> </a><p>Push processor status register onto the stack</p>
<table class="optable"><tr><th colspan="10">PHP</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x08</td><td></td><td>Implied</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Push the standard status register on the stack.
				</p><pre>
					Stack(SP--) &lt;= Status
				</pre><h2>PLA</h2>
<a name="PLA"> </a><p>Pull the contents of the accumulator from the stack</p>
<table class="optable"><tr><th colspan="10">PLA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x68</td><td></td><td>Implied</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Pull the value of the accumulator from the stack.
				</p><pre>
					A &lt;= Stack(++SP)
				</pre><h2>PLP</h2>
<a name="PLP"> </a><p>Pull processor status register from the stack</p>
<table class="optable"><tr><th colspan="10">PLP</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x28</td><td></td><td>Implied</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Pull the standard status register on the stack.
				</p><pre>
					Status &lt;= Stack(++SP)
				</pre><h2>RLA</h2>
<a name="RLA"> </a><p>ROL operand and AND with AC; this opcode is undocumented.</p>
<table class="optable"><tr><th colspan="10">RLA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x2f</td><td>undoc</td><td>Absolute 16bit</td><td></td></tr>
<tr><td></td><td>0x3f</td><td>undoc</td><td>Absolute 16bit indexed with X</td><td></td></tr>
<tr><td></td><td>0x3b</td><td>undoc</td><td>Absolute 16bit indexed with Y</td><td></td></tr>
<tr><td></td><td>0x27</td><td>undoc</td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0x37</td><td>undoc</td><td>Zeropage indexed with X</td><td></td></tr>
<tr><td></td><td>0x23</td><td>undoc</td><td>Zeropage indexed with X indirect 16bit</td><td></td></tr>
<tr><td></td><td>0x33</td><td>undoc</td><td>Zeropage indirect 16bit indexed with Y</td><td></td></tr>
</table>
<h2>ROL</h2>
<a name="ROL"> </a><p>Rotate Left - shift accumulator one bit to the left, shifting
				in
				the carry flag in bit 0, and shifting the
				highest bit into the
				carry flag instead.
			</p>
<table class="optable"><tr><th colspan="10">ROL</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x26</td><td></td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0x2a</td><td></td><td>Accumulator</td><td></td></tr>
<tr><td></td><td>0x2e</td><td></td><td>Absolute 16bit</td><td></td></tr>
<tr><td></td><td>0x36</td><td></td><td>Zeropage indexed with X</td><td></td></tr>
<tr><td></td><td>0x3e</td><td></td><td>Absolute 16bit indexed with X</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Shift the operand or accumulator left one bit (i.e. multiply by
					2).
					Shift
					in the carry flag from the right.
					The bit
					shifted out is
					moved into the carry flag.
					Note this opcode is a read-modify-write
					opcode and not only has
					memory-oriented addressing modes but can
					work
					on the accumulator alone as well.
				</p><pre>
					Tmp &lt;= AC(7)
					AC(7-1) &lt;= AC(6-0)
					AC(0) &lt;= C
					C
					&lt;= Tmp
					N &lt;= AC7)
					Z &lt;= Z(AC)
				</pre><h2>ROR</h2>
<a name="ROR"> </a><p>Rotate Right - shift accumulator one bit to the right, shifting
				in the carry flag in the highest bit, and
				shifting
				bit 0 into the
				carry flag instead.
			</p>
<table class="optable"><tr><th colspan="10">ROR</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x66</td><td>ror</td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0x6a</td><td>ror</td><td>Accumulator</td><td></td></tr>
<tr><td></td><td>0x6e</td><td>ror</td><td>Absolute 16bit</td><td></td></tr>
<tr><td></td><td>0x76</td><td>ror</td><td>Zeropage indexed with X</td><td></td></tr>
<tr><td></td><td>0x7e</td><td>ror</td><td>Absolute 16bit indexed with X</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Shift the operand or accumulator right one bit (i.e. divide by
					2). Shift
					in the carry flag from the left.
					The bit
					shifted out is
					moved into the carry flag.
					Note this opcode is a read-modify-write
					opcode and not only has
					memory-oriented addressing modes but can
					work
					on the accumulator alone as well.
				</p><pre>
					Tmp &lt;= AC(0)
					AC(6-0) &lt;= AC(7-1)
					AC(7) &lt;= C
					C
					&lt;= Tmp
					N &lt;= AC7)
					Z &lt;= Z(AC)
				</pre><h2>RRA</h2>
<a name="RRA"> </a><p>ROR operand and ADC with AC; this opcode is undocumented.</p>
<table class="optable"><tr><th colspan="10">RRA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x6f</td><td>undoc</td><td>Absolute 16bit</td><td></td></tr>
<tr><td></td><td>0x7f</td><td>undoc</td><td>Absolute 16bit indexed with X</td><td></td></tr>
<tr><td></td><td>0x7b</td><td>undoc</td><td>Absolute 16bit indexed with Y</td><td></td></tr>
<tr><td></td><td>0x67</td><td>undoc</td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0x77</td><td>undoc</td><td>Zeropage indexed with X</td><td></td></tr>
<tr><td></td><td>0x63</td><td>undoc</td><td>Zeropage indexed with X indirect 16bit</td><td></td></tr>
<tr><td></td><td>0x73</td><td>undoc</td><td>Zeropage indirect 16bit indexed with Y</td><td></td></tr>
</table>
<h2>RTI</h2>
<a name="RTI"> </a><p>Return from interrupt</p>
<table class="optable"><tr><th colspan="10">RTI</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x40</td><td></td><td>Implied</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Returns from an interrupt or a BRK opcode handling. It first
					pulls the
					status register from the stack, then
					takes
					the return
					address from the stack, increment it by one, and
					continue at the new
					address.
				</p><pre>
					Status &lt;= Stack(++SP) -- bit 5=1
					Tmp(0-7) &lt;=
					Stack(++SP)
					Tmp(8-15) &lt;= Stack(++SP)
					PC &lt;=
					Tmp;
				</pre><h2>RTS</h2>
<a name="RTS"> </a><p>Return from subroutine - read return address from stack</p>
<table class="optable"><tr><th colspan="10">RTS</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x60</td><td></td><td>Implied</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Take the return address from the stack, increment it by one, and
					continue at the new address.
				</p><pre>
					Tmp(0-7) &lt;= Stack(++SP)
					Tmp(8-15) &lt;= Stack(++SP)
					PC &lt;= Tmp + 1;
				</pre><h2>SAX</h2>
<a name="SAX"> </a><p>Store the result of X AND A in the given address, without changing flags; this opcode is undocumented.</p>
<table class="optable"><tr><th colspan="10">SAX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x8f</td><td>undoc</td><td>Absolute 16bit</td><td></td></tr>
<tr><td></td><td>0x87</td><td>undoc</td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0x97</td><td>undoc</td><td>Zeropage indexed with Y</td><td></td></tr>
<tr><td></td><td>0x83</td><td>undoc</td><td>Zeropage indexed with X indirect 16bit</td><td></td></tr>
</table>
<h2>SBC</h2>
<a name="SBC"> </a><p>Substract content of memory location from accumulator</p>
<table class="optable"><tr><th colspan="10">SBC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0xe1</td><td></td><td>Zeropage indexed with X indirect 16bit</td><td></td></tr>
<tr><td></td><td>0xe5</td><td></td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0xe9</td><td></td><td>Immediate</td><td></td></tr>
<tr><td></td><td>0xeb</td><td>undoc</td><td>Immediate</td><td></td></tr>
<tr><td></td><td>0xed</td><td></td><td>Absolute 16bit</td><td></td></tr>
<tr><td></td><td>0xf1</td><td></td><td>Zeropage indirect 16bit indexed with Y</td><td></td></tr>
<tr><td></td><td>0xf5</td><td></td><td>Zeropage indexed with X</td><td></td></tr>
<tr><td></td><td>0xf9</td><td></td><td>Absolute 16bit indexed with Y</td><td></td></tr>
<tr><td></td><td>0xfd</td><td></td><td>Absolute 16bit indexed with X</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Substract the operand from the accumulator and store back in the
					accumulator.
					Set the flags from the result. Use
					Decimal or Binary
					add depending
					on whether the
					decimal mode status bis is set or not
					respectively. C status flag is
					used
					as borrow.
				</p><pre>
					AC, C, V &lt;= AC - Operand, C
					N &lt;= Tmp(7)
					Z &lt;=
					Z(Tmp)
				</pre><p>
					For a handling of the V-flag please see
					<a href="http://www.6502.org/tutorials/vflag.html">http://www.6502.org/tutorials/vflag.html</a>
					.
				</p><h2>SBX</h2>
<a name="SBX"> </a><p>AND the AC and XR registers, substract an immediate value from that and store the result in XR. ; this opcode
				is undocumented.
			</p>
<table class="optable"><tr><th colspan="10">SBX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0xcb</td><td>undoc</td><td>Immediate</td><td></td></tr>
</table>
<h3>Description</h3>
<p>The substraction works similar to CMP in that no flags are set. It also has no decimal mode, as it
					is a combination of CMP and DEX (the latter to store the result). For details see 64doc.txt.
				</p><h2>SEC</h2>
<a name="SEC"> </a><p>Set the C flag</p>
<table class="optable"><tr><th colspan="10">SEC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x38</td><td></td><td>Implied</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Set the carry status flag.
				</p><h2>SED</h2>
<a name="SED"> </a><p>Set the decimal (D) flag</p>
<table class="optable"><tr><th colspan="10">SED</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0xf8</td><td>bcd</td><td>Implied</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Set the decimal mode status flag.
				</p><h2>SEI</h2>
<a name="SEI"> </a><p>Set the interrupt (I) flag</p>
<table class="optable"><tr><th colspan="10">SEI</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x78</td><td></td><td>Implied</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Set the interrupt status flag.
				</p><h2>SHA</h2>
<a name="SHA"> </a><p>Synonyms: AXA</p>
<p>AND the content of the AC, XR registers with the high address byte plus one and store in memory; this opcode is
				undocumented.
			</p>
<table class="optable"><tr><th colspan="10">SHA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x9f</td><td>undoc</td><td>Absolute 16bit indexed with Y</td><td></td></tr>
<tr><td></td><td>0x93</td><td>undoc</td><td>Zeropage indirect 16bit indexed with Y</td><td></td></tr>
</table>
<h3>Description</h3>
<pre>
					Store (A & X & (ADDR_HI + 1))
				</pre><h2>SHS</h2>
<a name="SHS"> </a><p>AND the AC and XR registers, transfer the result to the stack pointer; this opcode is undocumented.</p>
<table class="optable"><tr><th colspan="10">SHS</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x9b</td><td>undoc</td><td>Absolute 16bit indexed with Y</td><td></td></tr>
</table>
<h3>Description</h3>
<p>SHA and TXS where, X is replaced by (A & X).</p><p>Note: the value to be stored is also copied to ADDR_HI if page boundary is crossed.</p><h2>SHX</h2>
<a name="SHX"> </a><p>AND the content of the XR registers with the high address byte plus one and store in memory; this opcode is
				undocumented.
			</p>
<table class="optable"><tr><th colspan="10">SHX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x9e</td><td>undoc</td><td>Absolute 16bit indexed with Y</td><td></td></tr>
</table>
<h3>Description</h3>
<pre>
					Store (X & (ADDR_HI + 1))
				</pre><h2>SHY</h2>
<a name="SHY"> </a><p>AND the content of the YR registers with the high address byte plus one and store in memory; this opcode is
				undocumented.
			</p>
<table class="optable"><tr><th colspan="10">SHY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x9c</td><td>undoc</td><td>Absolute 16bit indexed with X</td><td></td></tr>
</table>
<h3>Description</h3>
<pre>
					Store (Y & (ADDR_HI + 1))
				</pre><h2>STA</h2>
<a name="STA"> </a><p>Store the content of the accumulator into a memory location
			</p>
<table class="optable"><tr><th colspan="10">STA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x81</td><td></td><td>Zeropage indexed with X indirect 16bit</td><td></td></tr>
<tr><td></td><td>0x85</td><td></td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0x8d</td><td></td><td>Absolute 16bit</td><td></td></tr>
<tr><td></td><td>0x91</td><td></td><td>Zeropage indirect 16bit indexed with Y</td><td></td></tr>
<tr><td></td><td>0x95</td><td></td><td>Zeropage indexed with X</td><td></td></tr>
<tr><td></td><td>0x99</td><td></td><td>Absolute 16bit indexed with Y</td><td></td></tr>
<tr><td></td><td>0x9d</td><td></td><td>Absolute 16bit indexed with X</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Store the accumulator into the address given by the operand.
				</p><pre>
					Operand &lt;= A
				</pre><h2>STX</h2>
<a name="STX"> </a><p>Store the content of the X register to memory.</p>
<table class="optable"><tr><th colspan="10">STX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x86</td><td></td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0x8e</td><td></td><td>Absolute 16bit</td><td></td></tr>
<tr><td></td><td>0x96</td><td></td><td>Zeropage indexed with Y</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Store the content of the X register into the address given by the
					operand.
				</p><pre>
					Operand &lt;= A
				</pre><h2>STY</h2>
<a name="STY"> </a><p>Store the content of the Y register to memory.</p>
<table class="optable"><tr><th colspan="10">STY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x84</td><td></td><td>Zeropage</td><td></td></tr>
<tr><td></td><td>0x8c</td><td></td><td>Absolute 16bit</td><td></td></tr>
<tr><td></td><td>0x94</td><td></td><td>Zeropage indexed with X</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Store the content of the Y register into the address given by the
					operand.
				</p><pre>
					Operand &lt;= A
				</pre><h2>TAX</h2>
<a name="TAX"> </a><p>Transfer the contents of accumulator into the X register</p>
<table class="optable"><tr><th colspan="10">TAX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0xaa</td><td></td><td>Implied</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the accumulator to the X register
				</p><pre>
					X &lt;= A
				</pre><h2>TAY</h2>
<a name="TAY"> </a><p>Transfer the contents of accumulator into the Y register</p>
<table class="optable"><tr><th colspan="10">TAY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0xa8</td><td></td><td>Implied</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the accumulator to the Y register
				</p><pre>
					Y &lt;= A
				</pre><h2>TSX</h2>
<a name="TSX"> </a><p>Transfer the contents of the stack pointer into the X register
				(Note: needs RS to keep compatibility with 6502)
			</p>
<table class="optable"><tr><th colspan="10">TSX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0xba</td><td></td><td>Implied</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the stack pointer to the X register
				</p><pre>
					X &lt;= S
				</pre><h2>TXA</h2>
<a name="TXA"> </a><p>Transfer the contents of the X register into the accumulator
			</p>
<table class="optable"><tr><th colspan="10">TXA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x8a</td><td></td><td>Implied</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the X register to the accumulator
				</p><pre>
					A &lt;= X
				</pre><h2>TXS</h2>
<a name="TXS"> </a><p>Transfer the contents of X register into the stack pointer
				(Note: needs RS to keep compatibility with 6502)
			</p>
<table class="optable"><tr><th colspan="10">TXS</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x9a</td><td></td><td>Implied</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the X register to the stack pointer.
				</p><pre>
					S &lt;= X
				</pre><h2>TYA</h2>
<a name="TYA"> </a><p>Transfer the contents of the Y register into the accumulator
			</p>
<table class="optable"><tr><th colspan="10">TYA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Syntax</th></tr>
<tr><td></td><td>0x98</td><td></td><td>Implied</td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the Y register to the accumulator
				</p><pre>
					A &lt;= Y
				</pre>