<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<cpu>
    <creator>A. Fachat</creator>
    <creationDate>2011-05-14T01:55:04.022+02:00</creationDate>
    <identifier>af65002</identifier>

	<!-- ################################# -->
	<!-- opcode classes, when were they introduced -->
		
	<class>
		<name>cmos</name>
		<prio>1</prio>
		<doc><p>
			This class is for those opcodes that have been introduced with the CMOS version
			of the 6502, the 65C02.
			Note this does not include the extended bit set and clear opcodes of the Rockwell variant.
		</p></doc>
	</class>
	<class>
		<name>65k</name>
		<prio>2</prio>
		<extends>cmos</extends>
		<doc><p>
			This class contains the new opcodes and opcode extensions of the af65002 compared to the 65C02.
		</p></doc>
	</class>
	<class>
		<name>65k10</name>
		<prio>2</prio>
		<extends>65k</extends>
		<doc><p>
			This class contains the new opcodes and opcode extensions of the af65010 compared to the af65002.
		</p></doc>
	</class>
	
	<!-- ################################# -->
	<!-- actual opcode definitions -->
	
    <operation>
        <name>BRK</name>
        <desc>Starts the break routine.</desc>
        <prefixBits>RS</prefixBits>
        <opcodes>
            <addressingMode>imm</addressingMode>
            <opcode>0x00</opcode>
        </opcodes>
        <doc><p>
        	The BRK opcode is used to jump to the BRK vector. It pushes the 
        	return address and the status on the stack, then reads the BRK vector
        	(doubling as IRQ vector) and jumps there. 
        	</p><p>
        	Please note that the address put on the stack is the address of the next
        	instruction. And the BRK opcode is using the immediate addressing mode 
        	(although the MOS manual does not state it). Thus the address put on the
        	stack is two bytes behind the address of the BRK!
        	</p><p>
        	Before storing the status on the stack, the opcode sets the I-flag to
        	avoid recursive calling of the interrupt routine.
        	</p><p>
        	When storing the status on the stack, the B-flag is set to indicate that
        	the shared IRQ/BRK vector has been called from a BRK and not an IRQ.
        	</p>
        	<pre>
        		Stack(SP--) &lt;= &gt; NextPC
        		Stack(SP--) &lt;= &lt; NextPC
        		Stack(SP--) &lt;= Status | B | I
        		PC &lt;= ($FFFE)
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	On the 65k, the RS prefix determines the size of the immediate operand,
        	so that the return address that is pushed onto the stack depends on it.
        	</p><p>
        	As opposed to the IRQ, the BRK opcode stays in the user resp. hypervisor mode
        	where it is executed.
        	</p><p>
        	In hypervisor mode, once the processor configuration register for abort vector table is set,
        	the BRK vector is taken from the abort vector table. For details see the interrupt handling
        	description.
        	</p><p>
        	In user mode the BRK always uses the standard two-byte $FFFE IRQ vector, sign-expanded to
        	full address length. 
        	</p>
        </doc>
    </operation>
    
	<!-- ################################# -->

    <operation>
        <name>BPL</name>
        <desc>Branch on plus - take branch when N flag is cleared</desc>
        <prefixBits>RS</prefixBits>
        <opcodes>
            <addressingMode>rel</addressingMode>
            <opcode>0x10</opcode>
        </opcodes>
        <doc><p>
        	Branch to the address given by adding the parameter to the address of the
        	next operation (after the branch opcode) given the condition that the
        	negative status flag is clear.
        	The parameter is a signed 8-bit value, i.e. jump distances can be from -128 to +127.
        	</p><pre>
        		PC &lt;= NextPC + Operand when N=1 else NextPC
        	</pre>
        </doc>
        <doc mode="65k">
        	<p>The RS prefix determines the width of the parameter, the default is 8-bit.
        	With a 16-bit parameter the jump distances can be from -32768 to +32767
        	and so on.</p>
        </doc>
    </operation>
    
    <operation>
        <name>BMI</name>
        <desc>Branch on minus - take branch when N flag is set</desc>
        <prefixBits>RS</prefixBits>
        <opcodes>
            <addressingMode>rel</addressingMode>
            <opcode>0x30</opcode>
        </opcodes>
        <doc><p>
        	Branch to the address given by adding the parameter to the address of the
        	next operation (after the branch opcode) given the condition that the
        	negative status flag is set.
        	The parameter is a signed 8-bit value, i.e. jump distances can be from -128 to +127.
        	</p><pre>
        		PC &lt;= NextPC + Operand when N=1 else NextPC
        	</pre>
        </doc>
        <doc mode="65k">
        	<p>The RS prefix determines the width of the parameter, the default is 8-bit.
        	With a 16-bit parameter the jump distances can be from -32768 to +32767
        	and so on.</p>
        </doc>
    </operation>
    
    <operation>
        <name>BVC</name>
        <desc>Branch on overflow clear - take branch when V flag is cleared</desc>
        <prefixBits>RS</prefixBits>
        <opcodes>
            <addressingMode>rel</addressingMode>
            <opcode>0x50</opcode>
        </opcodes>
        <doc><p>
        	Branch to the address given by adding the parameter to the address of the
        	next operation (after the branch opcode) given the condition that the
        	overflow status flag is clear.
        	The parameter is a signed 8-bit value, i.e. jump distances can be from -128 to +127.
        	</p><pre>
        		PC &lt;= NextPC + Operand when N=1 else NextPC
        	</pre>
        </doc>
        <doc mode="65k">
        	<p>The RS prefix determines the width of the parameter, the default is 8-bit.
        	With a 16-bit parameter the jump distances can be from -32768 to +32767
        	and so on.</p>
        </doc>
    </operation>
    
    <operation>
        <name>BVS</name>
        <desc>Branch on overflow set - take branch when V flag is set</desc>
        <prefixBits>RS</prefixBits>
        <opcodes>
            <addressingMode>rel</addressingMode>
            <opcode>0x70</opcode>
        </opcodes>
        <doc><p>
        	Branch to the address given by adding the parameter to the address of the
        	next operation (after the branch opcode) given the condition that the
        	overflow status flag is set.
        	The parameter is a signed 8-bit value, i.e. jump distances can be from -128 to +127.
        	</p><pre>
        		PC &lt;= NextPC + Operand when N=1 else NextPC
        	</pre>
        </doc>
        <doc mode="65k">
        	<p>The RS prefix determines the width of the parameter, the default is 8-bit.
        	With a 16-bit parameter the jump distances can be from -32768 to +32767
        	and so on.</p>
        </doc>
    </operation>
    
    <operation>
        <name>BCC</name>
        <desc>Branch on carry clear - take branch when C flag is cleared</desc>
        <prefixBits>RS</prefixBits>
        <opcodes>
            <addressingMode>rel</addressingMode>
            <opcode>0x90</opcode>
        </opcodes>
        <doc><p>
        	Branch to the address given by adding the parameter to the address of the
        	next operation (after the branch opcode) given the condition that the
        	carry status flag is clear.
        	The parameter is a signed 8-bit value, i.e. jump distances can be from -128 to +127.
        	</p><pre>
        		PC &lt;= NextPC + Operand when N=1 else NextPC
        	</pre>
        </doc>
        <doc mode="65k">
        	<p>The RS prefix determines the width of the parameter, the default is 8-bit.
        	With a 16-bit parameter the jump distances can be from -32768 to +32767
        	and so on.</p>
        </doc>
    </operation>
    
    <operation>
        <name>BCS</name>
        <desc>Branch on carry set - take branch when C flag is set</desc>
        <prefixBits>RS</prefixBits>
        <opcodes>
            <addressingMode>rel</addressingMode>
            <opcode>0xB0</opcode>
        </opcodes>
        <doc><p>
        	Branch to the address given by adding the parameter to the address of the
        	next operation (after the branch opcode) given the condition that the
        	carry status flag is set.
        	The parameter is a signed 8-bit value, i.e. jump distances can be from -128 to +127.
        	</p><pre>
        		PC &lt;= NextPC + Operand when N=1 else NextPC
        	</pre>
        </doc>
        <doc mode="65k">
        	<p>The RS prefix determines the width of the parameter, the default is 8-bit.
        	With a 16-bit parameter the jump distances can be from -32768 to +32767
        	and so on.</p>
        </doc>
    </operation>

    <operation>
        <name>BGT</name>
        <desc>Branch if greater - take branch when C flag is set but Z flag is clear</desc>
        <prefixBits>RS</prefixBits>
        <class>65k</class>
        <opcodes>
            <addressingMode>rel</addressingMode>
            <opcode>0xB0</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <doc><p>
        	Branch to the address given by adding the parameter to the address of the
        	next operation (after the branch opcode) given the condition that the
        	carry status flag is set and the zero status flag is not set.
        	The parameter is a signed 8-bit value, i.e. jump distances can be from -128 to +127.
        	</p><pre>
        		PC &lt;= NextPC + Operand when (N=1 and Z=0) else NextPC
        	</pre>
        </doc>
        <doc mode="65k">
        	<p>The RS prefix determines the width of the parameter, the default is 8-bit.
        	With a 16-bit parameter the jump distances can be from -32768 to +32767
        	and so on.</p>
        </doc>
    </operation>

    <operation>
        <name>BLE</name>
        <desc>Branch if less or equal - take branch when C flag is clear or Z flag is set</desc>
        <prefixBits>RS</prefixBits>
        <class>65k</class>
        <opcodes>
            <addressingMode>rel</addressingMode>
            <opcode>0x90</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <doc><p>
        	Branch to the address given by adding the parameter to the address of the
        	next operation (after the branch opcode) given the condition that the
        	carry status flag is clear or the zero status flag is set.
        	The parameter is a signed 8-bit value, i.e. jump distances can be from -128 to +127.
        	</p><pre>
        		PC &lt;= NextPC + Operand when (N=1 and Z=0) else NextPC
        	</pre>
        </doc>
        <doc mode="65k">
        	<p>The RS prefix determines the width of the parameter, the default is 8-bit.
        	With a 16-bit parameter the jump distances can be from -32768 to +32767
        	and so on.</p>
        </doc>
    </operation>

    <operation>
        <name>BNE</name>
        <desc>Branch on not equal - take branch when Z flag is cleared</desc>
        <prefixBits>RS</prefixBits>
        <opcodes>
            <addressingMode>rel</addressingMode>
            <opcode>0xD0</opcode>
        </opcodes>
        <doc><p>
        	Branch to the address given by adding the parameter to the address of the
        	next operation (after the branch opcode) given the condition that the
        	zero status flag is clear.
        	The parameter is a signed 8-bit value, i.e. jump distances can be from -128 to +127.
        	</p><pre>
        		PC &lt;= NextPC + Operand when N=1 else NextPC
        	</pre>
        </doc>
        <doc mode="65k">
        	<p>The RS prefix determines the width of the parameter, the default is 8-bit.
        	With a 16-bit parameter the jump distances can be from -32768 to +32767
        	and so on.</p>
        </doc>
    </operation>
    
    <operation>
        <name>BEQ</name>
        <desc>Branch on equal - take branch when Z flag is set</desc>
        <prefixBits>RS</prefixBits>
        <opcodes>
            <addressingMode>rel</addressingMode>
            <opcode>0xf0</opcode>
        </opcodes>
        <doc><p>
        	Branch to the address given by adding the parameter to the address of the
        	next operation (after the branch opcode) given the condition that the
        	zero status flag is set.
        	The parameter is a signed 8-bit value, i.e. jump distances can be from -128 to +127.
        	</p><pre>
        		PC &lt;= NextPC + Operand when N=1 else NextPC
        	</pre>
        </doc>
        <doc mode="65k">
        	<p>The RS prefix determines the width of the parameter, the default is 8-bit.
        	With a 16-bit parameter the jump distances can be from -32768 to +32767
        	and so on.</p>
        </doc>
    </operation>
    
    <operation>
        <name>BRA</name>
        <desc>Branch always - branch independent from any flags</desc>
        <prefixBits>RS</prefixBits>
      	<class>cmos</class>
        <opcodes>
            <addressingMode>rel</addressingMode>
            <opcode>0x80</opcode>
        </opcodes>
        <doc><p>
        	Branch (always) to the address given by adding the parameter to the address of the
        	next operation (after the branch opcode).
        	The parameter is a signed 8-bit value, i.e. jump distances can be from -128 to +127.
        	</p><pre>
        		PC &lt;= NextPC + Operand when N=1 else NextPC
        	</pre>
        </doc>
        <doc mode="65k">
        	<p>The RS prefix determines the width of the parameter, the default is 8-bit.
        	With a 16-bit parameter the jump distances can be from -32768 to +32767
        	and so on.</p>
        </doc>
    </operation>
    
	<!-- ################################# -->

	<operation>
		<name>JMP</name>
		<desc>Jump to new code address</desc>
        <prefixBits>AM</prefixBits>
        <prefixBits>OF</prefixBits>
        <prefixBits>UM</prefixBits>
        <prefixBits>LE</prefixBits>
        <default-le>sign</default-le>
		<opcodes>
			<addressingMode>absindquad</addressingMode>
			<opcode>0x07</opcode>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
		</opcodes>
		<opcodes>
			<addressingMode>absxindquad</addressingMode>
			<opcode>0x27</opcode>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
		</opcodes>
		<opcodes>
			<addressingMode>addr</addressingMode>
			<opcode>0x4c</opcode>
		</opcodes>
		<opcodes>
			<addressingMode>absind</addressingMode>
			<opcode>0x6c</opcode>
		</opcodes>
		<opcodes>
			<addressingMode>absxind</addressingMode>
			<opcode>0x7c</opcode>
		</opcodes>
        <opcodes>
            <addressingMode>eind</addressingMode>
            <opcode>0x4c</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <opcodes>
            <addressingMode>addrlong</addressingMode>
            <opcode>0x6c</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <doc><p>
        	Jump to the address given by the operand (as computed depending on the respective addressing mode).
        	</p>
        	<pre>
        		PC &lt;= Operand
        		Status |= U when UM is set
        	</pre>
        </doc>
        <doc mode="65k">
        	<p>The AM, OF, LE and UM prefixes are evaluated by the addressing modes.
        	Note that if UM is set, then the processor jumps into user mode.
        	<p></p>
        	If the operand is not as wide as required for an address, it is sign-extended.
        	</p>
        </doc>
	</operation>
	
    <operation>
        <name>JSR</name>
        <desc>Jump subroutine - jump to a new code location, save return address on stack for RTS</desc>
        <prefixBits>AM</prefixBits>
        <prefixBits>OF</prefixBits>
        <prefixBits>RS</prefixBits>
        <prefixBits>LE</prefixBits>
        <default-le>sign</default-le>
        <opcodes>
            <addressingMode>addr</addressingMode>
            <opcode>0x20</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>addrlong</addressingMode>
            <opcode>0xdc</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <opcodes>
            <addressingMode>absind</addressingMode>
            <opcode>0xdc</opcode>
            <class>65k</class>
        </opcodes>
        <opcodes>
            <addressingMode>absxind</addressingMode>
            <opcode>0xfc</opcode>
            <class>65k</class>
        </opcodes>
        <opcodes>
            <addressingMode>absindquad</addressingMode>
            <opcode>0x87</opcode>
            <class>65k</class>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
        </opcodes>
        <opcodes>
            <addressingMode>absxindquad</addressingMode>
            <opcode>0xa7</opcode>
            <class>65k</class>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
        </opcodes>
        <opcodes>
            <addressingMode>eind</addressingMode>
            <opcode>0x20</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <doc><p>
        	Jump to the address given by the operand (as computed depending on the respective addressing mode) and
        	store the return address (-1) on the stack to prepare for the RTS opcode
        	</p><pre>
        		Stack(SP--) &lt;= &gt; NextPC-1
        		Stack(SP--) &lt;= &lt; NextPC-1
        		PC &lt;= Operand
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The AM, OF, and LE prefixes are evaluated by the addressing modes.
        	Note that the UM prefix is not supported.
        	</p><p>
        	If the operand is not wide enough as required for an address, it is sign-extended.
        	</p><p>
        	The RS prefix determines the width of the return address put on the stack. Note that the
        	BYTE width prefix denotes the natural width of the processor (respectively its current mode).
        	</p><p>
        	The stack pointer used is the stack pointer of the current mode.
        	</p>
        </doc>
    </operation>

    <operation>
        <name>BSR</name>
        <desc>Branch subroutine - similar to JSR, but use relative addressing similar to branch opcodes</desc>
        <prefixBits>AM</prefixBits>
        <prefixBits>RS</prefixBits>
        <opcodes>
            <addressingMode>relj</addressingMode>
            <opcode>0x82</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>reljwide</addressingMode>
            <opcode>0x44</opcode>
        </opcodes>
		<class>65k</class>
        <doc><p>
        	Branch to the address given by the operand as computed similar to the branch opcodes.
        	Store the return address (-1) on the stack to prepare for the RTS opcode. 
        	</p><pre>
        		Stack(SP--) &lt;= &gt; NextPC-1
        		Stack(SP--) &lt;= &lt; NextPC-1
        		PC &lt;= NextPC + Operand
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The AM prefix is evaluated by the relative addressing modes. Note that the RS prefix is
        	used to determine the return address size on the stack, so it cannot be used as parameter width
        	selector. Thus there are two opcodes to define 8-bit or 16-bit parameter width, using the AM
        	prefix to make that 32- or 64-bit respectively.
        	</p><p>
        	Note that the UM prefix is not supported.
        	</p><p>
        	If the operand is not wide enough as required for an address, it is sign-extended.
        	</p><p>
        	The RS prefix determines the width of the return address put on the stack. Note that the
        	BYTE width prefix denotes the natural width of the processor (respectively its current mode). This 
        	is the default.
        	</p><p>
        	The stack pointer used is the stack pointer of the current mode.
        	</p>
        </doc>
	</operation>
		
	<operation>
		<name>RTS</name>
		<desc>Return from subroutine - read return address from stack</desc>
        <prefixBits>RS</prefixBits>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0x60</opcode>
		</opcodes>
        <doc><p>
        	Take the return address from the stack, increment it by one, and continue at the new address.
        	</p><pre>
        		Tmp(0-7) &lt;= Stack(++SP)
        		Tmp(8-15) &lt;= Stack(++SP)
        		PC &lt;= Tmp + 1;
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The RS prefix determines the width of the return address read from the stack. Note that the
        	BYTE width prefix denotes the natural width of the processor (respectively its current mode). This 
        	is the default.
        	</p><p>
        	If the operand is not wide enough as required for an address, it is extended with the
        	rest of the current PC. This is to support running "narrow" code within a e.g. a 64k window
        	in a wide system.
        	</p><p>
        	The stack pointer used is the stack pointer of the current mode.
        	</p>
        </doc>
	</operation>  
	  
	<operation>
		<name>RTI</name>
		<desc>Return from interrupt</desc>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0x40</opcode>
		</opcodes>
        <doc><p>
        	Returns from an interrupt or a BRK opcode handling. It first pulls the status register from the stack, then
        	takes the return address from the stack, increment it by one, and continue at the new address.
        	</p><pre>
        		Status &lt;= Stack(++SP)		-- bit 5=1
        		Tmp(0-7) &lt;= Stack(++SP)
        		Tmp(8-15) &lt;= Stack(++SP)
        		PC &lt;= Tmp;
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The RTI prefix first reads the status from the current stack. If the "Not extended" flag is set 
        	(bit 5 is always 1 in the 6502 status register, so here it is used as "not extended" flag), then 
        	the normal handling as described above takes place. 
        	</p><p>
        	If the "not extended" flag is clear, i.e. an extended stack frame is used:
        	</p><pre>
        		Status &lt;= Stack(++SP)		-- bit 5=0
        		ExtStatus &lt;= Stack(++SP)
        		Tmp(0-7) &lt;= Stack(++SP)
        		Tmp(8-15) &lt;= Stack(++SP)
        		...
        		PC &lt;= Tmp;
        	</pre>
        	<p>
        	Here the extended status byte is pulled from the stack after the standard status. In this extended status
        	there are two bit that determine the size of the return address following on the stack.
        	So the return address can be 16-, 32- or 64-bit. Note that the "00" designation (otherwise used for BYTE width)
        	maps to the natural address width of the processor executing the code. 
			</p><p>
			Also the user mode bit is stored in the extended stack frame. If the user mode bit is the same as the
			current mode, the execution continues in that mode. 
			If the RTI code is executed in the supervisor mode, and the user mode bit is set, then the 
			return address is interpreted as user mode address, and the execution continues in the 
			user mode. If RTI is executed in user mode, and the user mode bit is clear (i.e. hypervisor mode),
			and ABORT sequence is triggered.
        	</p><p>
        	Note that the "natural" address width is taken from the target environment in case the process jumps
        	from hypervisor to user mode. 
        	</p><p>
        	If the operand is not wide enough as required for an address, it is sign-extended.
        	</p>
        </doc>
	</operation>  
	
	<!-- ################################# -->

	<operation>
		<name>TSB</name>
		<desc>Test and Set Bit - AND the memory location with the accumulator, and set the Z flag from the result, then SET all bits in the
				memory location that are set in the accumulator.</desc>
        <prefixBits>AM</prefixBits>
        <prefixBits>OF</prefixBits>
        <prefixBits>RS</prefixBits>
        <prefixBits>UM</prefixBits>
        <prefixBits>NF</prefixBits>
		<class>cmos</class>
		<opcodes>
			<addressingMode>zp</addressingMode>
			<opcode>0x04</opcode>
		</opcodes>
		<opcodes>
			<addressingMode>abs</addressingMode>
			<opcode>0x0c</opcode>
		</opcodes>
		<opcodes>
			<addressingMode>eind</addressingMode>
			<opcode>0x0c</opcode>
			<oppage>EXT</oppage>
		</opcodes>
        <doc><p>
        	Take the operand, and AND it with the accumulator and evaluate the Z-flag. Then OR the operand with the accumulator
        	and store the value back.  
        	</p><p>
        	The use case for this opcode is the synchronization between processes and implements a variant of the "test-and-set" 
        	primitive. Thus this is a Read-Modify-Write operation and will trigger a Memory-Lock between the read and write
        	to make that operation atomic.
        	</p><pre>
        		Tmp &lt;= operand &amp; AC 
        		Z &lt;= Z(Tmp)
        		operand &lt; operand | AC
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The AM, OF and RS prefixes are evaluated by the addressing modes. The UM prefix determines whether the
        	operand resides in user space or not. 
        	</p><p>
        	The NF prefix allows to implement a read-modify-write OR of a memory location (without the usual or/store
        	sequence) - without setting a flag though.
        	</p>
        </doc>
	</operation>
	
	<operation>
		<name>TRB</name>
		<desc>Test and Reset Bit - AND the memory location with the accumulator, and set the Z flag from the result, then CLEAR all bits in the
				memory location that are set in the accumulator.</desc>
        <prefixBits>AM</prefixBits>
        <prefixBits>OF</prefixBits>
        <prefixBits>RS</prefixBits>
        <prefixBits>UM</prefixBits>
        <prefixBits>NF</prefixBits>
		<class>cmos</class>
		<opcodes>
			<addressingMode>zp</addressingMode>
			<opcode>0x14</opcode>
		</opcodes>
		<opcodes>
			<addressingMode>abs</addressingMode>
			<opcode>0x1c</opcode>
		</opcodes>
		<opcodes>
			<addressingMode>eind</addressingMode>
			<opcode>0x1c</opcode>
			<oppage>EXT</oppage>
		</opcodes>
        <doc><p>
        	Take the operand, and AND it with the accumulator and evaluate the Z-flag. Then clear all bits in the operand 
        	that are set in the accumulator (basically AND with the inverse of the accumulator),
        	and store the value back.  
        	</p><p>
        	The use case for this opcode is the synchronization between processes and implements a variant of the "test-and-clear" 
        	primitive. Thus this is a Read-Modify-Write operation and will trigger a Memory-Lock between the read and write
        	to make that operation atomic.
        	</p><pre>
        		Tmp &lt;= operand &amp; AC 
        		Z &lt;= Z(Tmp)
        		operand &lt; operand | AC
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The AM, OF and RS prefixes are evaluated by the addressing modes. The UM prefix determines whether the
        	operand resides in user space or not. 
        	</p><p>
        	The NF prefix allows to implement a read-modify-write AND of a memory location (without the usual and/store
        	sequence) - without setting a flag though.
        	</p>
        </doc>
	</operation>

	<operation>
		<name>BIT</name>
		<desc>Bitwise test with accumulator - AND the memory location with the accumulator, and set N (=bit 7), V (=bit 7), Z (iff all bits 
				zero) flags from the result. In case of the accumulator addressing, simply set the flags from the accumulator</desc>  
        <prefixBits>AM</prefixBits>
        <prefixBits>OF</prefixBits>
        <prefixBits>RS</prefixBits>
        <prefixBits>LE</prefixBits>
        <prefixBits>UM</prefixBits>
        <prefixBits>NF</prefixBits>
		<opcodes>
			<addressingMode>zp</addressingMode>
			<opcode>0x24</opcode>
		</opcodes>
		<opcodes>
			<addressingMode>abs</addressingMode>
			<opcode>0x2c</opcode>
		</opcodes>
		<opcodes>
			<addressingMode>zpx</addressingMode>
			<opcode>0x34</opcode>
			<class>cmos</class>
		</opcodes>
		<opcodes>
			<addressingMode>absx</addressingMode>
			<opcode>0x3c</opcode>
			<class>cmos</class>
		</opcodes>
		<opcodes>
			<addressingMode>imm</addressingMode>
			<opcode>0x89</opcode>
			<class>cmos</class>
		</opcodes>
		<opcodes>
			<addressingMode>eind</addressingMode>
			<opcode>0x89</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>A</addressingMode>
			<opcode>0x34</opcode>
			<oppage>EXT</oppage>
		</opcodes>
        <doc><p>
        	Read the operand and set the N and V flags from the value (from the highest and next-to-highest bit respectively).
        	Then take the operand, and AND it with the accumulator and evaluate the Z-flag.  
        	</p><pre>
        		N &lt;= Operand(7)
        		V &lt;= Operand(6)
        		Tmp &lt;= Operand &amp; AC 
        		Z &lt;= Z(Tmp)
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The AM, OF, LE and RS prefixes are evaluated by the addressing modes. The UM prefix determines whether the
        	operand resides in user space or not. 
        	</p><p>
        	The NF prefix allows to implement a read-modify-write AND of a memory location (without the usual and/store
        	sequence) - without setting a flag though.
        	</p>
        </doc>
	</operation>
	
	
	<!-- ################################# -->

    <operation>
        <name>LDY</name>
        <desc>Load Y register</desc>
        <prefixBits>AM</prefixBits>
        <prefixBits>OF</prefixBits>
        <prefixBits>RS</prefixBits>
        <prefixBits>LE</prefixBits>
        <prefixBits>UM</prefixBits>
        <prefixBits>NF</prefixBits>
        <default-le>zero</default-le>
        <opcodes>
            <addressingMode>imm</addressingMode>
            <opcode>0xa0</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zp</addressingMode>
            <opcode>0xa4</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>abs</addressingMode>
            <opcode>0xac</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpx</addressingMode>
            <opcode>0xb4</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>absx</addressingMode>
            <opcode>0xbc</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>eind</addressingMode>
            <opcode>0xa0</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <doc><p>
        	Read the operand and store it in the Y register. Set the flags appropriately.
        	</p><pre>
        		N &lt;= Operand(7)
        		Z &lt;= Z(Operand)
        		Y &lt;= Operand
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The AM, OF, LE and RS prefixes are evaluated by the addressing modes. The UM prefix determines whether the
        	operand resides in user space or not. 
        	</p><p>
        	Note that the default load extension is "zero-extended", to "not surprise" programmers.
        	</p><p>
        	The NF prefix lets the flags unmodified.
        	</p>
        </doc>
    </operation>
    
    <operation>
        <name>LDX</name>
        <desc>Load X register</desc>
        <prefixBits>AM</prefixBits>
        <prefixBits>OF</prefixBits>
        <prefixBits>RS</prefixBits>
        <prefixBits>LE</prefixBits>
        <prefixBits>UM</prefixBits>
        <prefixBits>NF</prefixBits>
        <default-le>zero</default-le>
        <opcodes>
            <addressingMode>imm</addressingMode>
            <opcode>0xa2</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zp</addressingMode>
            <opcode>0xa6</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>abs</addressingMode>
            <opcode>0xae</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpy</addressingMode>
            <opcode>0xb6</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>absy</addressingMode>
            <opcode>0xbe</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>eind</addressingMode>
            <opcode>0xa2</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <doc><p>
        	Read the operand and store it in the X register. Set the flags appropriately.
        	</p><pre>
        		N &lt;= Operand(7)
        		Z &lt;= Z(Operand)
        		X &lt;= Operand
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The AM, OF, LE and RS prefixes are evaluated by the addressing modes. The UM prefix determines whether the
        	operand resides in user space or not. 
        	</p><p>
        	Note that the default load extension is "zero-extended", to "not surprise" programmers.
        	</p><p>
        	The NF prefix lets the flags unmodified.
        	</p>
        </doc>
    </operation>
    

    <operation>
        <name>LDA</name>
        <desc>Load accumulator</desc>
        <prefixBits>AM</prefixBits>
        <prefixBits>OF</prefixBits>
        <prefixBits>RS</prefixBits>
        <prefixBits>LE</prefixBits>
        <prefixBits>UM</prefixBits>
        <prefixBits>NF</prefixBits>
        <default-le>zero</default-le>
        <opcodes>
            <addressingMode>zpy</addressingMode>
            <opcode>0x02</opcode>
            <class>65k</class>
        </opcodes>
        <opcodes>
            <addressingMode>absindy</addressingMode>
            <opcode>0x42</opcode>
            <class>65k</class>
        </opcodes>
        <opcodes>
            <addressingMode>absindyquad</addressingMode>
            <opcode>0x47</opcode>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
        </opcodes>
        <opcodes>
            <addressingMode>absxind</addressingMode>
            <opcode>0x62</opcode>
            <class>65k</class>
        </opcodes>
        <opcodes>
            <addressingMode>absxindquad</addressingMode>
            <opcode>0x67</opcode>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
        </opcodes>
        <opcodes>
            <addressingMode>zpxind</addressingMode>
            <opcode>0xa1</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpxindquad</addressingMode>
            <opcode>0xa3</opcode>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
        </opcodes>
        <opcodes>
            <addressingMode>zp</addressingMode>
            <opcode>0xa5</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>imm</addressingMode>
            <opcode>0xa9</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>abs</addressingMode>
            <opcode>0xad</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpindy</addressingMode>
            <opcode>0xb1</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpind</addressingMode>
            <opcode>0xb2</opcode>
            <class>cmos</class>
        </opcodes>
        <opcodes>
            <addressingMode>zpindyquad</addressingMode>
            <opcode>0xb3</opcode>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
        </opcodes>
        <opcodes>
            <addressingMode>zpx</addressingMode>
            <opcode>0xb5</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpindquad</addressingMode>
            <opcode>0xb7</opcode>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
        </opcodes>
        <opcodes>
            <addressingMode>absy</addressingMode>
            <opcode>0xb9</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>absx</addressingMode>
            <opcode>0xbd</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>eind</addressingMode>
            <opcode>0xa9</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <doc><p>
        	Read the operand and store it in the Accumulator. Set the flags appropriately.
        	</p><pre>
        		N &lt;= Operand(7)
        		Z &lt;= Z(Operand)
        		Y &lt;= Operand
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The AM, OF, LE and RS prefixes are evaluated by the addressing modes. The UM prefix determines whether the
        	operand resides in user space or not. 
        	</p><p>
        	Note that the default load extension is "zero-extended", to "not surprise" programmers.
        	</p><p>
        	The NF prefix lets the flags unmodified.
        	</p>
        </doc>
    </operation>

	<!-- ################################# -->
    
    <operation>
        <name>CPY</name>
        <desc>Compare Y register with content of memory location</desc>
        <prefixBits>AM</prefixBits>
        <prefixBits>OF</prefixBits>
        <prefixBits>RS</prefixBits>
        <prefixBits>UM</prefixBits>
        <prefixBits>LE</prefixBits>
        <opcodes>
            <addressingMode>imm</addressingMode>
            <opcode>0xc0</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zp</addressingMode>
            <opcode>0xc4</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>abs</addressingMode>
            <opcode>0xcc</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>eind</addressingMode>
            <opcode>0xc0</opcode>
            <oppage>EXT</oppage>
            <class>65k</class>
        </opcodes>
        <doc><p>
        	Compare the operand with the Y register and set the flags appropriately.
        	I.e. substract the operand from Y with an implicitely set carry in binary mode (even if
        	decimal mode status bit is set), and set the flags from the result.
        	</p><pre>
        		Tmp, C &lt;= Y - Operand, C=1
        		N &lt;= Tmp(7)
        		Z &lt;= Z(Tmp)
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The AM, OF, LE and RS prefixes are evaluated by the addressing modes. UM determines 
        	whether the operand is in user space. 
        	</p><p>
        	Note that the default is to use BYTE-wide operation without load extension.
        	</p>
        </doc>
    </operation>

    <operation>
        <name>CPX</name>
        <desc>Compare X register with content of memory location</desc>
        <prefixBits>AM</prefixBits>
        <prefixBits>OF</prefixBits>
        <prefixBits>RS</prefixBits>
        <prefixBits>UM</prefixBits>
        <prefixBits>LE</prefixBits>
        <opcodes>
            <addressingMode>imm</addressingMode>
            <opcode>0xe0</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zp</addressingMode>
            <opcode>0xe4</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>abs</addressingMode>
            <opcode>0xec</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>eind</addressingMode>
            <opcode>0xe0</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <doc><p>
        	Compare the operand with the X register and set the flags appropriately.
        	I.e. substract the operand from X with an implicitely set carry in binary mode (even if
        	decimal mode status bit is set), and set the flags from the result.
        	</p><pre>
        		Tmp, C &lt;= X - Operand, C=1
        		N &lt;= Tmp(7)
        		Z &lt;= Z(Tmp)
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The AM, OF, LE and RS prefixes are evaluated by the addressing modes. UM determines 
        	whether the operand is in user space. 
        	</p><p>
        	Note that the default is to use BYTE-wide operation without load extension.
        	</p>
        </doc>
    </operation>
    
    <operation>
        <name>CMP</name>
        <desc>Compare accumulator with content of memory location</desc>
        <prefixBits>AM</prefixBits>
        <prefixBits>OF</prefixBits>
        <prefixBits>RS</prefixBits>
        <prefixBits>UM</prefixBits>
        <prefixBits>LE</prefixBits>
        <opcodes>
            <addressingMode>zpxind</addressingMode>
            <opcode>0xc1</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpxindquad</addressingMode>
            <opcode>0xc3</opcode>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
        </opcodes>
        <opcodes>
            <addressingMode>zp</addressingMode>
            <opcode>0xc5</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>imm</addressingMode>
            <opcode>0xc9</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>abs</addressingMode>
            <opcode>0xcd</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpindy</addressingMode>
            <opcode>0xd1</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpind</addressingMode>
            <opcode>0xd2</opcode>
            <class>cmos</class>
        </opcodes>
        <opcodes>
            <addressingMode>zpindyquad</addressingMode>
            <opcode>0xd3</opcode>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
        </opcodes>
        <opcodes>
            <addressingMode>zpindquad</addressingMode>
            <opcode>0xd7</opcode>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
        </opcodes>
        <opcodes>
            <addressingMode>zpx</addressingMode>
            <opcode>0xd5</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>absy</addressingMode>
            <opcode>0xd9</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>absx</addressingMode>
            <opcode>0xdd</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>eind</addressingMode>
            <opcode>0xc9</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <doc><p>
        	Compare the operand with the accumulator and set the flags appropriately.
        	I.e. substract the operand from AC with an implicitely set carry in binary mode (even if
        	decimal mode status bit is set), and set the flags from the result.
        	</p><pre>
        		Tmp, C &lt;= Y - Operand, C=1
        		N &lt;= Tmp(7)
        		Z &lt;= Z(Tmp)
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The AM, OF, LE and RS prefixes are evaluated by the addressing modes. UM determines 
        	whether the operand is in user space. 
        	</p><p>
        	Note that the default is to use BYTE-wide operation without load extension.
        	</p>
        </doc>
    </operation>
    
    
	<!-- ################################# -->

    <operation>
        <name>ORA</name>
        <desc>Bitwise OR accumulator with content of memory location</desc>
        <prefixBits>AM</prefixBits>
        <prefixBits>OF</prefixBits>
        <prefixBits>RS</prefixBits>
        <prefixBits>LE</prefixBits>
        <prefixBits>UM</prefixBits>
        <prefixBits>NF</prefixBits>
        <opcodes>
            <addressingMode>zpxind</addressingMode>
            <opcode>0x01</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpxindquad</addressingMode>
            <opcode>0x03</opcode>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
        </opcodes>
        <opcodes>
            <addressingMode>zp</addressingMode>
            <opcode>0x05</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>imm</addressingMode>
            <opcode>0x09</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>abs</addressingMode>
            <opcode>0x0d</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpindy</addressingMode>
            <opcode>0x11</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpind</addressingMode>
            <opcode>0x12</opcode>
            <class>cmos</class>
        </opcodes>
        <opcodes>
            <addressingMode>zpindyquad</addressingMode>
            <opcode>0x13</opcode>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
        </opcodes>
        <opcodes>
            <addressingMode>zpx</addressingMode>
            <opcode>0x15</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpindquad</addressingMode>
            <opcode>0x17</opcode>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
        </opcodes>
        <opcodes>
            <addressingMode>absy</addressingMode>
            <opcode>0x19</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>absx</addressingMode>
            <opcode>0x1d</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>eind</addressingMode>
            <opcode>0x09</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <doc><p>
        	Bitwise OR the accumulator with the operand and store back in the accumulator.
        	Set the flags from the result.
        	</p><pre>
        		AC &lt;= AC | Operand
        		N &lt;= Tmp(7)
        		Z &lt;= Z(Tmp)
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The AM, OF, LE and RS prefixes are evaluated by the addressing modes. UM determines 
        	whether the operand is in user space. NF allows to not set the flags.
        	</p><p>
        	RS and LE together also determine the width of the operation.
        	Note that the default is to use BYTE-wide operation without load extension.
        	</p>
        </doc>
    </operation>

    <operation>
        <name>AND</name>
        <desc>Bitwise AND accumulator with content of memory location</desc>
        <prefixBits>AM</prefixBits>
        <prefixBits>OF</prefixBits>
        <prefixBits>RS</prefixBits>
        <prefixBits>LE</prefixBits>
        <prefixBits>UM</prefixBits>
        <prefixBits>NF</prefixBits>
        <opcodes>
            <addressingMode>zpxind</addressingMode>
            <opcode>0x21</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpxindquad</addressingMode>
            <opcode>0x23</opcode>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
        </opcodes>
        <opcodes>
            <addressingMode>zp</addressingMode>
            <opcode>0x25</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>imm</addressingMode>
            <opcode>0x29</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>abs</addressingMode>
            <opcode>0x2d</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpindy</addressingMode>
            <opcode>0x31</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpind</addressingMode>
            <opcode>0x32</opcode>
            <class>cmos</class>
        </opcodes>
        <opcodes>
            <addressingMode>zpindyquad</addressingMode>
            <opcode>0x33</opcode>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
        </opcodes>
        <opcodes>
            <addressingMode>zpx</addressingMode>
            <opcode>0x35</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpindquad</addressingMode>
            <opcode>0x37</opcode>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
        </opcodes>
        <opcodes>
            <addressingMode>absy</addressingMode>
            <opcode>0x39</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>absx</addressingMode>
            <opcode>0x3d</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>eind</addressingMode>
            <opcode>0x29</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <doc><p>
        	Bitwise AND the accumulator with the operand and store back in the accumulator.
        	Set the flags from the result.
        	</p><pre>
        		AC &lt;= AC &amp; Operand
        		N &lt;= Tmp(7)
        		Z &lt;= Z(Tmp)
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The AM, OF, LE and RS prefixes are evaluated by the addressing modes. UM determines 
        	whether the operand is in user space. NF allows to not set the flags.
        	</p><p>
        	RS and LE together also determine the width of the operation.
        	Note that the default is to use BYTE-wide operation without load extension.
        	</p>
        </doc>
    </operation>

    <operation>
        <name>EOR</name>
        <desc>Bitwise Exclusive-OR accumulator with content of memory location</desc>
        <prefixBits>AM</prefixBits>
        <prefixBits>OF</prefixBits>
        <prefixBits>RS</prefixBits>
        <prefixBits>LE</prefixBits>
        <prefixBits>UM</prefixBits>
        <prefixBits>NF</prefixBits>
        <opcodes>
            <addressingMode>zpxind</addressingMode>
            <opcode>0x41</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpxindquad</addressingMode>
            <opcode>0x43</opcode>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
        </opcodes>
        <opcodes>
            <addressingMode>zp</addressingMode>
            <opcode>0x45</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>imm</addressingMode>
            <opcode>0x49</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>abs</addressingMode>
            <opcode>0x4d</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpindy</addressingMode>
            <opcode>0x51</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpind</addressingMode>
            <opcode>0x52</opcode>
            <class>cmos</class>
        </opcodes>
        <opcodes>
            <addressingMode>zpindyquad</addressingMode>
            <opcode>0x53</opcode>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
        </opcodes>
        <opcodes>
            <addressingMode>zpx</addressingMode>
            <opcode>0x55</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpindquad</addressingMode>
            <opcode>0x57</opcode>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
        </opcodes>
        <opcodes>
            <addressingMode>absy</addressingMode>
            <opcode>0x59</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>absx</addressingMode>
            <opcode>0x5d</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>eind</addressingMode>
            <opcode>0x49</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <doc><p>
        	Bitwise Exclusive-OR the accumulator with the operand and store back in the accumulator.
        	Set the flags from the result.
        	</p><pre>
        		AC &lt;= AC ^ Operand
        		N &lt;= Tmp(7)
        		Z &lt;= Z(Tmp)
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The AM, OF, LE and RS prefixes are evaluated by the addressing modes. UM determines 
        	whether the operand is in user space. NF allows to not set the flags.
        	</p><p>
        	RS and LE together also determine the width of the operation.
        	Note that the default is to use BYTE-wide operation without load extension.
        	</p>
        </doc>
    </operation>

    <operation>
        <name>ADC</name>
        <desc>Add content of memory location to accumulator</desc>
        <prefixBits>AM</prefixBits>
        <prefixBits>OF</prefixBits>
        <prefixBits>RS</prefixBits>
        <prefixBits>LE</prefixBits>
        <prefixBits>UM</prefixBits>
        <prefixBits>NF</prefixBits>
        <opcodes>
            <addressingMode>zpxind</addressingMode>
            <opcode>0x61</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpxindquad</addressingMode>
            <opcode>0x63</opcode>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
        </opcodes>
        <opcodes>
            <addressingMode>zp</addressingMode>
            <opcode>0x65</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>imm</addressingMode>
            <opcode>0x69</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>abs</addressingMode>
            <opcode>0x6d</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpindy</addressingMode>
            <opcode>0x71</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpind</addressingMode>
            <opcode>0x72</opcode>
            <class>cmos</class>
        </opcodes>
        <opcodes>
            <addressingMode>zpindyquad</addressingMode>
            <opcode>0x73</opcode>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
        </opcodes>
        <opcodes>
            <addressingMode>zpx</addressingMode>
            <opcode>0x75</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpindquad</addressingMode>
            <opcode>0x77</opcode>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
        </opcodes>
        <opcodes>
            <addressingMode>absy</addressingMode>
            <opcode>0x79</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>absx</addressingMode>
            <opcode>0x7d</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>eind</addressingMode>
            <opcode>0x69</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <doc><p>
        	Add the operand to the accumulator and store back in the accumulator.
        	Set the flags from the result. Use Decimal or Binary add depending on whether the
        	decimal mode status bis is set or not respectively.
        	</p><pre>
        		AC, C, V &lt;= AC + Operand, C
        		N &lt;= Tmp(7)
        		Z &lt;= Z(Tmp)
        	</pre>
        	<p>For a handling of the V-flag please see 
        	<a href="http://www.6502.org/tutorials/vflag.html">http://www.6502.org/tutorials/vflag.html</a>.
        	</p>
        </doc>
        <doc mode="65k"><p>
        	The AM, OF, LE and RS prefixes are evaluated by the addressing modes. UM determines 
        	whether the operand is in user space. NF allows to not set the flags.
        	</p><p>
        	RS and LE together also determine the width of the operation.
        	Note that the default is to use BYTE-wide operation without load extension.
        	</p>
        </doc>
    </operation>

    
    <operation>
        <name>SBC</name>   
        <desc>Substract content of memory location from accumulator</desc>
        <prefixBits>AM</prefixBits>
        <prefixBits>OF</prefixBits>
        <prefixBits>RS</prefixBits>
        <prefixBits>LE</prefixBits>
        <prefixBits>UM</prefixBits>
        <prefixBits>NF</prefixBits>
        <opcodes>
            <addressingMode>zpxind</addressingMode>
            <opcode>0xe1</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpxindquad</addressingMode>
            <opcode>0xe3</opcode>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
        </opcodes>
        <opcodes>
            <addressingMode>zp</addressingMode>
            <opcode>0xe5</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>imm</addressingMode>
            <opcode>0xe9</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>abs</addressingMode>
            <opcode>0xed</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpindy</addressingMode>
            <opcode>0xf1</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpind</addressingMode>
            <opcode>0xf2</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpindyquad</addressingMode>
            <opcode>0xf3</opcode>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
        </opcodes>
        <opcodes>
            <addressingMode>zpx</addressingMode>
            <opcode>0xf5</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpindquad</addressingMode>
            <opcode>0xf7</opcode>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
        </opcodes>
        <opcodes>
            <addressingMode>absy</addressingMode>
            <opcode>0xf9</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>absx</addressingMode>
            <opcode>0xfd</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>eind</addressingMode>
            <opcode>0xe9</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <doc><p>
        	Substract the operand from the accumulator and store back in the accumulator.
        	Set the flags from the result. Use Decimal or Binary add depending on whether the
        	decimal mode status bis is set or not respectively. C status flag is used as borrow.
        	</p><pre>
        		AC, C, V &lt;= AC - Operand, C
        		N &lt;= Tmp(7)
        		Z &lt;= Z(Tmp)
        	</pre>
        	<p>For a handling of the V-flag please see 
        	<a href="http://www.6502.org/tutorials/vflag.html">http://www.6502.org/tutorials/vflag.html</a>.
        	</p>
        </doc>
        <doc mode="65k"><p>
        	The AM, OF, LE and RS prefixes are evaluated by the addressing modes. UM determines 
        	whether the operand is in user space. NF allows to not set the flags.
        	</p><p>
        	RS and LE together also determine the width of the operation.
        	Note that the default is to use BYTE-wide operation without load extension.
        	</p>
        </doc>
    </operation>

	<!-- ################################# -->

    <operation>
        <name>ASR</name>
        <desc>Arithmetic Shift Right - Similar to LSR, but shifts in the sign of the value, not zero</desc>   
        <prefixBits>AM</prefixBits>
        <prefixBits>OF</prefixBits>
        <prefixBits>RS</prefixBits>
        <prefixBits>UM</prefixBits>
        <prefixBits>NF</prefixBits>
        <class>65k</class>
        <opcodes>
            <addressingMode>zp</addressingMode>
            <opcode>0x06</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <opcodes>
            <addressingMode>A</addressingMode>
            <opcode>0x0a</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <opcodes>
            <addressingMode>abs</addressingMode>
            <opcode>0x0e</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <opcodes>
            <addressingMode>zpx</addressingMode>
            <opcode>0x16</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <opcodes>
            <addressingMode>absx</addressingMode>
            <opcode>0x1e</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <opcodes>
            <addressingMode>absy</addressingMode>
            <opcode>0x1f</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <opcodes>
            <addressingMode>eind</addressingMode>
            <opcode>0x1d</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <doc><p>
        	Shift the operand or accumulator right one bit (i.e. divide by 2). Shift in the sign (uppermost bit) from the left.
        	The bit shifted out is moved into the carry flag.
        	Note this opcode is a read-modify-write opcode and not only has memory-oriented addressing modes but can work
        	on the accumulator alone as well.
        	</p><pre>
        		C &lt;= AC(0)
        		AC(6-0) &lt;= AC(7-1)
        		N &lt;= AC7)
        		Z &lt;= Z(AC)
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The AM, OF and RS prefixes are evaluated by the addressing modes. UM determines 
        	whether the operand is in user space. NF allows to not set the flags.
        	</p><p>
        	RS also determine the width of the operation. There is no LE prefix, as the read and write
        	widths are the same.
        	Note that the default is to use BYTE-wide operation without load extension.
        	</p>
        </doc>
    </operation>

    <operation>
        <name>RDL</name>
        <desc>Rotate Direct Left - similar to ROL, but do not shift in carry, but the highest bit of the original value</desc>   
        <prefixBits>AM</prefixBits>
        <prefixBits>OF</prefixBits>
        <prefixBits>RS</prefixBits>
        <prefixBits>UM</prefixBits>
        <prefixBits>NF</prefixBits>
        <class>65k</class>
        <opcodes>
            <addressingMode>zp</addressingMode>
            <opcode>0x26</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <opcodes>
            <addressingMode>A</addressingMode>
            <opcode>0x2a</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <opcodes>
            <addressingMode>abs</addressingMode>
            <opcode>0x2e</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <opcodes>
            <addressingMode>zpx</addressingMode>
            <opcode>0x36</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <opcodes>
            <addressingMode>absx</addressingMode>
            <opcode>0x3e</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <opcodes>
            <addressingMode>absy</addressingMode>
            <opcode>0x3f</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <opcodes>
            <addressingMode>eind</addressingMode>
            <opcode>0x3d</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <doc><p>
        	Shift the operand or accumulator left one bit (i.e. multiply by 2). Shift in the sign (uppermost bit) of
        	the original value from the right.
        	The bit shifted is also moved into the carry flag.
        	Note this opcode is a read-modify-write opcode and not only has memory-oriented addressing modes but can work
        	on the accumulator alone as well.
        	</p><pre>
        		C &lt;= AC(7)
        		AC(7-1) &lt;= AC(6-0)
        		AC(0) &lt;= C
        		N &lt;= AC7)
        		Z &lt;= Z(AC)
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The AM, OF and RS prefixes are evaluated by the addressing modes. UM determines 
        	whether the operand is in user space. NF allows to not set the flags.
        	</p><p>
        	RS also determine the width of the operation. There is no LE prefix, as the read and write
        	widths are the same.
        	Note that the default is to use BYTE-wide operation without load extension.
        	</p>
        </doc>
    </operation>


    <operation>
        <name>RDR</name>   
        <desc>Rotate Direct Right - similar to ROR, but do not shift in carry, but the lowest bit of the original value</desc>   
        <prefixBits>AM</prefixBits>
        <prefixBits>OF</prefixBits>
        <prefixBits>RS</prefixBits>
        <prefixBits>UM</prefixBits>
        <prefixBits>NF</prefixBits>
        <opcodes>
            <addressingMode>zp</addressingMode>
            <opcode>0x66</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <opcodes>
            <addressingMode>A</addressingMode>
            <opcode>0x6a</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <opcodes>
            <addressingMode>abs</addressingMode>
            <opcode>0x6e</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <opcodes>
            <addressingMode>zpx</addressingMode>
            <opcode>0x76</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <opcodes>
            <addressingMode>absx</addressingMode>
            <opcode>0x7e</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <opcodes>
            <addressingMode>absy</addressingMode>
            <opcode>0x7f</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <opcodes>
            <addressingMode>eind</addressingMode>
            <opcode>0x7d</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <doc><p>
        	Shift the operand or accumulator right one bit (i.e. divide by 2). Shift in bit 0 (lowermost bit) of
        	the original value from the left.
        	The bit shifted is also moved into the carry flag.
        	Note this opcode is a read-modify-write opcode and not only has memory-oriented addressing modes but can work
        	on the accumulator alone as well.
        	</p><pre>
        		C &lt;= AC(0)
        		AC(6-0) &lt;= AC(7-1)
        		AC(7) &lt;= C
        		N &lt;= AC7)
        		Z &lt;= Z(AC)
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The AM, OF and RS prefixes are evaluated by the addressing modes. UM determines 
        	whether the operand is in user space. NF allows to not set the flags.
        	</p><p>
        	RS also determine the width of the operation. There is no LE prefix, as the read and write
        	widths are the same.
        	Note that the default is to use BYTE-wide operation without load extension.
        	</p>
        </doc>
    </operation>
    
	<!-- ################################# -->

    <operation>
        <name>ASL</name>   
        <desc>Arithmetic Shift Left - shift accumulator one bit to the left, shifting in zero in bit 0</desc>
        <prefixBits>AM</prefixBits>
        <prefixBits>OF</prefixBits>
        <prefixBits>RS</prefixBits>
        <prefixBits>UM</prefixBits>
        <prefixBits>NF</prefixBits>
        <opcodes>
            <addressingMode>zp</addressingMode>
            <opcode>0x06</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>A</addressingMode>
            <opcode>0x0a</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>abs</addressingMode>
            <opcode>0x0e</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpx</addressingMode>
            <opcode>0x16</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>absx</addressingMode>
            <opcode>0x1e</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>absy</addressingMode>
            <opcode>0x1f</opcode>
            <class>65k</class>
        </opcodes>
        <opcodes>
            <addressingMode>eind</addressingMode>
            <opcode>0x0d</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <doc><p>
        	Shift the operand or accumulator left one bit (i.e. multiply by 2). Shift in a zero from the right.
        	The bit shifted out is moved into the carry flag.
        	Note this opcode is a read-modify-write opcode and not only has memory-oriented addressing modes but can work
        	on the accumulator alone as well.
        	</p><pre>
        		C &lt;= AC(7)
        		AC(7-1) &lt;= AC(6-0)
        		AC(0) &lt;= 0
        		N &lt;= AC7)
        		Z &lt;= Z(AC)
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The AM, OF and RS prefixes are evaluated by the addressing modes. UM determines 
        	whether the operand is in user space. NF allows to not set the flags.
        	</p><p>
        	RS also determine the width of the operation. There is no LE prefix, as the read and write
        	widths are the same.
        	Note that the default is to use BYTE-wide operation without load extension.
        	</p>
        </doc>
    </operation>

    <operation>
        <name>LSR</name>   
        <desc>Logical Shift Right - shift accumulator one bit to the right, shifting in zero in the highest bit</desc>
        <prefixBits>AM</prefixBits>
        <prefixBits>OF</prefixBits>
        <prefixBits>RS</prefixBits>
        <prefixBits>UM</prefixBits>
        <prefixBits>NF</prefixBits>
        <opcodes>
            <addressingMode>zp</addressingMode>
            <opcode>0x46</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>A</addressingMode>
            <opcode>0x4a</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>abs</addressingMode>
            <opcode>0x4e</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpx</addressingMode>
            <opcode>0x56</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>absx</addressingMode>
            <opcode>0x5e</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>absy</addressingMode>
            <opcode>0x5f</opcode>
            <class>65k</class>
        </opcodes>
        <opcodes>
            <addressingMode>eind</addressingMode>
            <opcode>0x4d</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <doc><p>
        	Shift the operand or accumulator right one bit (i.e. divide by 2). Shift in a zero from the left.
        	The bit shifted out is moved into the carry flag.
        	Note this opcode is a read-modify-write opcode and not only has memory-oriented addressing modes but can work
        	on the accumulator alone as well.
        	</p><pre>
        		C &lt;= AC(0)
        		AC(6-0) &lt;= AC(7-1)
        		AC(7) &lt;= 0
        		N &lt;= AC7)
        		Z &lt;= Z(AC)
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The AM, OF and RS prefixes are evaluated by the addressing modes. UM determines 
        	whether the operand is in user space. NF allows to not set the flags.
        	</p><p>
        	RS also determine the width of the operation. There is no LE prefix, as the read and write
        	widths are the same.
        	Note that the default is to use BYTE-wide operation without load extension.
        	</p>
        </doc>
    </operation>


    <operation>
        <name>ROL</name>   
        <desc>Rotate Left - shift accumulator one bit to the left, shifting in the carry flag in bit 0, and shifting the 
        	highest bit into the carry flag instead.</desc>
        <prefixBits>AM</prefixBits>
        <prefixBits>OF</prefixBits>
        <prefixBits>RS</prefixBits>
        <prefixBits>UM</prefixBits>
        <prefixBits>NF</prefixBits>
        <opcodes>
            <addressingMode>zp</addressingMode>
            <opcode>0x26</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>A</addressingMode>
            <opcode>0x2a</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>abs</addressingMode>
            <opcode>0x2e</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpx</addressingMode>
            <opcode>0x36</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>absx</addressingMode>
            <opcode>0x3e</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>absy</addressingMode>
            <opcode>0x3f</opcode>
            <class>65k</class>
        </opcodes>
        <opcodes>
            <addressingMode>eind</addressingMode>
            <opcode>0x2d</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <doc><p>
        	Shift the operand or accumulator left one bit (i.e. multiply by 2). Shift in the carry flag from the right.
        	The bit shifted out is moved into the carry flag.
        	Note this opcode is a read-modify-write opcode and not only has memory-oriented addressing modes but can work
        	on the accumulator alone as well.
        	</p><pre>
        		Tmp &lt;= AC(7)
        		AC(7-1) &lt;= AC(6-0)
        		AC(0) &lt;= C
        		C &lt;= Tmp
        		N &lt;= AC7)
        		Z &lt;= Z(AC)
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The AM, OF and RS prefixes are evaluated by the addressing modes. UM determines 
        	whether the operand is in user space. NF allows to not set the flags.
        	</p><p>
        	RS also determine the width of the operation. There is no LE prefix, as the read and write
        	widths are the same.
        	Note that the default is to use BYTE-wide operation without load extension.
        	</p>
        </doc>
    </operation>


    <operation>
        <name>ROR</name>   
        <desc>Rotate Right - shift accumulator one bit to the right, shifting in the carry flag in the highest bit, and shifting 
        	bit 0 into the carry flag instead.</desc>
        <prefixBits>AM</prefixBits>
        <prefixBits>OF</prefixBits>
        <prefixBits>RS</prefixBits>
        <prefixBits>UM</prefixBits>
        <prefixBits>NF</prefixBits>
        <opcodes>
            <addressingMode>zp</addressingMode>
            <opcode>0x66</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>A</addressingMode>
            <opcode>0x6a</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>abs</addressingMode>
            <opcode>0x6e</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpx</addressingMode>
            <opcode>0x76</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>absx</addressingMode>
            <opcode>0x7e</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>absy</addressingMode>
            <opcode>0x7f</opcode>
            <class>65k</class>
        </opcodes>
        <opcodes>
            <addressingMode>eind</addressingMode>
            <opcode>0x6d</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <doc><p>
        	Shift the operand or accumulator right one bit (i.e. divide by 2). Shift in the carry flag from the left.
        	The bit shifted out is moved into the carry flag.
        	Note this opcode is a read-modify-write opcode and not only has memory-oriented addressing modes but can work
        	on the accumulator alone as well.
        	</p><pre>
        		Tmp &lt;= AC(0)
        		AC(6-0) &lt;= AC(7-1)
        		AC(7) &lt;= C
        		C &lt;= Tmp
        		N &lt;= AC7)
        		Z &lt;= Z(AC)
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The AM, OF and RS prefixes are evaluated by the addressing modes. UM determines 
        	whether the operand is in user space. NF allows to not set the flags.
        	</p><p>
        	RS also determine the width of the operation. There is no LE prefix, as the read and write
        	widths are the same.
        	Note that the default is to use BYTE-wide operation without load extension.
        	</p>
        </doc>
    </operation>

    <operation>
        <name>INC</name>   
        <desc>Increment the content of a memory location by one</desc>
        <prefixBits>AM</prefixBits>
        <prefixBits>OF</prefixBits>
        <prefixBits>RS</prefixBits>
        <prefixBits>UM</prefixBits>
        <prefixBits>NF</prefixBits>
        <opcodes>
            <addressingMode>zp</addressingMode>
            <opcode>0xe6</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>A</addressingMode>
            <opcode>0x1a</opcode>
            <class>cmos</class>
        </opcodes>
        <opcodes>
            <addressingMode>abs</addressingMode>
            <opcode>0xee</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpx</addressingMode>
            <opcode>0xf6</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>absx</addressingMode>
            <opcode>0xfe</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>absy</addressingMode>
            <opcode>0xff</opcode>
            <class>65k</class>
        </opcodes>
        <opcodes>
            <addressingMode>eind</addressingMode>
            <opcode>0xed</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <doc><p>
        	Increment the operand by one, i.e. binary add one.
        	Note this opcode is a read-modify-write opcode and not only has memory-oriented addressing modes but can work
        	on the accumulator alone as well.
        	</p><pre>
        		Operand &lt;= Operand + 1
        		N &lt;= OperandC7)
        		Z &lt;= Z(AC)
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The AM, OF and RS prefixes are evaluated by the addressing modes. UM determines 
        	whether the operand is in user space. NF allows to not set the flags.
        	</p><p>
        	RS also determine the width of the operation. There is no LE prefix, as the read and write
        	widths are the same.
        	Note that the default is to use BYTE-wide operation without load extension.
        	</p>
        </doc>
    </operation>

    <operation>
        <name>DEC</name>   
        <desc>Decrement the content of a memory location by one</desc>
        <prefixBits>AM</prefixBits>
        <prefixBits>OF</prefixBits>
        <prefixBits>RS</prefixBits>
        <prefixBits>UM</prefixBits>
        <prefixBits>NF</prefixBits>
        <opcodes>
            <addressingMode>zp</addressingMode>
            <opcode>0xc6</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>A</addressingMode>
            <opcode>0x3a</opcode>
            <class>cmos</class>
        </opcodes>
        <opcodes>
            <addressingMode>abs</addressingMode>
            <opcode>0xce</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpx</addressingMode>
            <opcode>0xd6</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>absx</addressingMode>
            <opcode>0xde</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>absy</addressingMode>
            <opcode>0xdf</opcode>
            <class>65k</class>
        </opcodes>
        <opcodes>
            <addressingMode>eind</addressingMode>
            <opcode>0xcd</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <doc><p>
        	Decrement the operand by one, i.e. binary substract one.
        	Note this opcode is a read-modify-write opcode and not only has memory-oriented addressing modes but can work
        	on the accumulator alone as well.
        	</p><pre>
        		Operand &lt;= Operand - 1
        		N &lt;= OperandC7)
        		Z &lt;= Z(AC)
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The AM, OF and RS prefixes are evaluated by the addressing modes. UM determines 
        	whether the operand is in user space. NF allows to not set the flags.
        	</p><p>
        	RS also determine the width of the operation. There is no LE prefix, as the read and write
        	widths are the same.
        	Note that the default is to use BYTE-wide operation without load extension.
        	</p>
        </doc>
    </operation>



	<!-- ################################# -->

    <operation>
        <name>STA</name>
        <desc>Store the content of the accumulator into a memory location</desc>
        <prefixBits>AM</prefixBits>
        <prefixBits>OF</prefixBits>
        <prefixBits>RS</prefixBits>
        <prefixBits>UM</prefixBits>
        <opcodes>
            <addressingMode>zpy</addressingMode>
            <opcode>0x22</opcode>
            <class>65k</class>
        </opcodes>
        <opcodes>
            <addressingMode>zpxind</addressingMode>
            <opcode>0x81</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpxindquad</addressingMode>
            <opcode>0x83</opcode>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
        </opcodes>
        <opcodes>
            <addressingMode>zp</addressingMode>
            <opcode>0x85</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>abs</addressingMode>
            <opcode>0x8d</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpindy</addressingMode>
            <opcode>0x91</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpind</addressingMode>
            <opcode>0x92</opcode>
            <class>cmos</class>
        </opcodes>
        <opcodes>
            <addressingMode>zpindyquad</addressingMode>
            <opcode>0x93</opcode>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
        </opcodes>
        <opcodes>
            <addressingMode>zpx</addressingMode>
            <opcode>0x95</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpindquad</addressingMode>
            <opcode>0x97</opcode>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
        </opcodes>
        <opcodes>
            <addressingMode>absy</addressingMode>
            <opcode>0x99</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>absx</addressingMode>
            <opcode>0x9d</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>absindy</addressingMode>
            <opcode>0xc2</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>absindyquad</addressingMode>
            <opcode>0xc7</opcode>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
        </opcodes>
        <opcodes>
            <addressingMode>absxind</addressingMode>
            <opcode>0xe2</opcode>
            <class>65k</class>
        </opcodes>
        <opcodes>
            <addressingMode>absxindquad</addressingMode>
            <opcode>0xe7</opcode>
            <fixed>
            	<name>AM</name>
            	<value>1</value>
            </fixed>
        </opcodes>
        <opcodes>
            <addressingMode>eind</addressingMode>
            <opcode>0x8d</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <doc><p>
        	Store the accumulator into the address given by the operand.
        	</p><pre>
        		Operand &lt;= A
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The AM, OF and RS prefixes are evaluated by the addressing modes. UM determines 
        	whether the operand is in user space.
        	</p><p>
        	RS also determine the width of the operation.
        	Note that the default is to use BYTE-wide operation without load extension.
        	</p>
        </doc>
    </operation>

    <operation>
        <name>STZ</name>
        <desc>Store zero into a memory location</desc>
        <prefixBits>AM</prefixBits>
        <prefixBits>OF</prefixBits>
        <prefixBits>RS</prefixBits>
        <prefixBits>UM</prefixBits>
        <class>cmos</class>
        <opcodes>
            <addressingMode>zp</addressingMode>
            <opcode>0x64</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpx</addressingMode>
            <opcode>0x74</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>abs</addressingMode>
            <opcode>0x9c</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>absx</addressingMode>
            <opcode>0x9e</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>absy</addressingMode>
            <opcode>0x9e</opcode>
            <class>65k</class>
            <oppage>EXT</oppage>
        </opcodes>
        <opcodes>
            <addressingMode>eind</addressingMode>
            <opcode>0x9c</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <doc><p>
        	Store the zero into the address given by the operand.
        	</p><pre>
        		Operand &lt;= 0
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The AM, OF and RS prefixes are evaluated by the addressing modes. UM determines 
        	whether the operand is in user space.
        	</p><p>
        	RS also determine the width of the operation.
        	Note that the default is to use BYTE-wide operation without load extension.
        	</p>
        </doc>
    </operation>

    <operation>
        <name>STY</name>
        <desc>Store the content of the Y register to memory.</desc>
        <prefixBits>AM</prefixBits>
        <prefixBits>OF</prefixBits>
        <prefixBits>RS</prefixBits>
        <prefixBits>UM</prefixBits>
        <opcodes>
            <addressingMode>zp</addressingMode>
            <opcode>0x84</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>abs</addressingMode>
            <opcode>0x8c</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpx</addressingMode>
            <opcode>0x94</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>absx</addressingMode>
            <opcode>0x9f</opcode>
            <class>65k</class>
        </opcodes>
        <opcodes>
            <addressingMode>eind</addressingMode>
            <opcode>0x8c</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <doc><p>
        	Store the content of the Y register into the address given by the operand.
        	</p><pre>
        		Operand &lt;= A
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The AM, OF and RS prefixes are evaluated by the addressing modes. UM determines 
        	whether the operand is in user space.
        	</p><p>
        	RS also determine the width of the operation.
        	Note that the default is to use BYTE-wide operation without load extension.
        	</p>
        </doc>
    </operation>
    
    <operation>
        <name>STX</name>
        <desc>Store the content of the X register to memory.</desc>
        <prefixBits>AM</prefixBits>
        <prefixBits>OF</prefixBits>
        <prefixBits>RS</prefixBits>
        <prefixBits>UM</prefixBits>
        <opcodes>
            <addressingMode>zp</addressingMode>
            <opcode>0x86</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>abs</addressingMode>
            <opcode>0x8e</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>zpy</addressingMode>
            <opcode>0x96</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>absy</addressingMode>
            <opcode>0xbf</opcode>
            <class>65k</class>
        </opcodes>
        <opcodes>
            <addressingMode>eind</addressingMode>
            <opcode>0x8e</opcode>
            <oppage>EXT</oppage>
        </opcodes>
        <doc><p>
        	Store the content of the X register into the address given by the operand.
        	</p><pre>
        		Operand &lt;= A
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The AM, OF and RS prefixes are evaluated by the addressing modes. UM determines 
        	whether the operand is in user space.
        	</p><p>
        	RS also determine the width of the operation.
        	Note that the default is to use BYTE-wide operation without load extension.
        	</p>
        </doc>
    </operation>
    
   
	<!-- ################################# -->

    <operation>
        <name>TRP</name>
        <desc>Trap into 65k supervisor mode</desc>
        <class>65k</class>
        <opcodes>
            <addressingMode>imm</addressingMode>
            <opcode>0xf4</opcode>
        </opcodes>
        <doc><p>
        	Trap into supervisor mode. Pushes the return address and the extended status byte
        	on the hypervisor stack and jumps into hypervisor mode,
        	using the appropriate trap vector. To return from the trap, the RTU operations is used.
        	For compatibility with RTS, the return address minus one is stored on the stack.
        	</p><pre>
        		Stack(SP--) &lt;= &gt; NextPC-1
        		Stack(SP--) &lt;= &lt; NextPC-1
        		Stack(SP--) &lt;= ExtStatus
        		PC &lt;= TrapVector(Operand)
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The address put on the stack always has the natural width of the processor. 
        	Currently no further prefix is supported.
        	The stack pointer used is that of the hypervisor stack.
        	</p><p>
        	This opcode can be used in user mode as well as in hypervisor mode. The extended status byte
        	contains the user mode bit, so that the RTU opcode knows whether to return to user mode or
        	hypervisor mode.
        	</p><p>
        	The extendend status byte also contains width bits that store the width of the return
        	address on stack. BYTE is not used, but the real width is stored with the width bits.
        	</p><p>
        	Note for future expansions the RS prefix may extend the trap number (the immediate operand) 
        	to word, or even wider widths.
        	</p>
        </doc>
    </operation>

    <operation>
        <name>RTU</name>
        <desc>Return from trap handler.</desc>
        <class>65k</class>
        <opcodes>
            <addressingMode>imm</addressingMode>
            <opcode>0x60</opcode>
            <oppage>SYS</oppage>
        </opcodes>
        <doc><p>
        	Return from trap handling. Reads the extended status byte and the return address from hypervisor stack,
        	then jumps to the return address.
        	</p><pre>
        		&lt;Tmp &lt;= Stack(++SP)
        		&gt;Tmp &lt;= Stack(++SP)
        		Tmp &lt;= Tmp+1
        		PC &lt;= Tmp;
        		ExtStatus &lt;= Stack(++SP)
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The extended status byte contains the width bits for the return address as well as the user mode bit
        	from where the trap came. In RTU the user mode bit is restored, so the RTU opcode can return to 
        	user as well as hypervisor mode. 
        	</p><p>
        	The stack pointer used is that of the hypervisor stack.
        	</p><p>
        	Note for future expansions the RS prefix may extend the number of traps to word, or even wider widths.
        	</p><p>
        	When executed in user mode, this opcode triggers an ABORT exception.
        	</p>
        </doc>
    </operation>

<!--  
    <operation>
        <name>EXT prefix</name>
        <class>65k</class>
        <opcodes>
            <addressingMode>prefix</addressingMode>
            <opcode>0x0f</opcode>
        </opcodes>
    </operation>
    
    <operation>
        <name>SYS prefix</name>
        <class>65k</class>
        <opcodes>
            <addressingMode>prefix</addressingMode>
            <opcode>0x2f</opcode>
        </opcodes>
    </operation>
    
    <operation>
        <name>QUICK prefix</name>
        <class>65k</class>
        <opcodes>
            <addressingMode>prefix</addressingMode>
            <opcode>0x4f</opcode>
        </opcodes>
    </operation>
    
    <operation>
        <name>reserved prefix</name>
        <class>65k</class>
        <opcodes>
            <addressingMode>prefix</addressingMode>
            <opcode>0x6f</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>prefix</addressingMode>
            <opcode>0x8f</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>prefix</addressingMode>
            <opcode>0xaf</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>prefix</addressingMode>
            <opcode>0xcf</opcode>
        </opcodes>
        <opcodes>
            <addressingMode>prefix</addressingMode>
            <opcode>0xef</opcode>
        </opcodes>
    </operation>
-->
    
	<!-- ################################# -->

	<operation>
		<name>PHP</name>
		<desc>Push processor status register onto the stack</desc> 
        <prefixBits>UM</prefixBits>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0x08</opcode>
		</opcodes>
        <doc><p>
        	Push the standard status register on the stack.
        	</p><pre>
        		Stack(SP--) &lt;= Status
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The stack pointer used is the one of the current stack if the UM prefix is not set.
        	If UM is set and the opcode is executed in hypervisor mode, the stack pointer used is the 
        	user mode stack pointer and the value is stored in user mode memory. If executed in
        	user mode with UM set an ABORT exception is triggered.
        	</p><p>
        	The not-extended bit is set (so the status is compatible with the 6502 and would denote a
        	standard stack frame)
        	</p>
        </doc>
	</operation>

	<operation>
		<name>CLC</name>
		<desc>Clear the C flag</desc>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0x18</opcode>
		</opcodes>
        <doc><p>
        	Clear the carry status flag.
        </p></doc>
	</operation>
	
	<operation>
		<name>PLP</name>
		<desc>Pull processor status register from the stack</desc> 
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0x28</opcode>
		</opcodes>
        <doc><p>
        	Pull the standard status register on the stack.
        	</p><pre>
        		Status &lt;= Stack(++SP)
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The stack pointer used is the one of the current stack if the UM prefix is not set.
        	If UM is set and the opcode is executed in hypervisor mode, the stack pointer used is the 
        	user mode stack pointer and the value is stored in user mode memory. If executed in
        	user mode with UM set an ABORT exception is triggered.
        	</p>
        </doc>
	</operation>
	
	<operation>
		<name>SEC</name>
		<desc>Set the C flag</desc>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0x38</opcode>
		</opcodes>
        <doc><p>
        	Set the carry status flag.
        </p></doc>
	</operation>
	
	<operation>
		<name>PHA</name>
		<desc>Push contents of the accumulator onto the stack</desc> 
		<prefixBits>RS</prefixBits>
		<prefixBits>UM</prefixBits>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0x48</opcode>
		</opcodes>
        <doc><p>
        	Push the content of the accumulator on the stack.
        	</p><pre>
        		Stack(SP--) &lt;= A
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The RS prefix determines the width of the accumulator value as written on the stack.
        	</p><p>
        	The stack pointer used is the one of the current stack if the UM prefix is not set.
        	If UM is set and the opcode is executed in hypervisor mode, the stack pointer used is the 
        	user mode stack pointer and the value is stored in user mode memory. If executed in
        	user mode with UM set an ABORT exception is triggered.
        	</p>
        </doc>
	</operation>
	
	<operation>
		<name>PHY</name>
		<desc>Push contents of the Y register onto the stack</desc> 
		<prefixBits>RS</prefixBits>
		<prefixBits>UM</prefixBits>
        <class>cmos</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0x5a</opcode>
		</opcodes>
        <doc><p>
        	Push the content of the Y register on the stack.
        	</p><pre>
        		Stack(SP--) &lt;= Y
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The RS prefix determines the width of the accumulator value as written on the stack.
        	</p><p>
        	The stack pointer used is the one of the current stack if the UM prefix is not set.
        	If UM is set and the opcode is executed in hypervisor mode, the stack pointer used is the 
        	user mode stack pointer and the value is stored in user mode memory. If executed in
        	user mode with UM set an ABORT exception is triggered.
        	</p>
        </doc>
	</operation>
	
	<operation>
		<name>PHX</name>
		<desc>Push contents of the X register onto the stack</desc> 
		<prefixBits>RS</prefixBits>
		<prefixBits>UM</prefixBits>
        <class>cmos</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0xda</opcode>
		</opcodes>
        <doc><p>
        	Push the content of the X register on the stack.
        	</p><pre>
        		Stack(SP--) &lt;= X
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The RS prefix determines the width of the accumulator value as written on the stack.
        	</p><p>
        	The stack pointer used is the one of the current stack if the UM prefix is not set.
        	If UM is set and the opcode is executed in hypervisor mode, the stack pointer used is the 
        	user mode stack pointer and the value is stored in user mode memory. If executed in
        	user mode with UM set an ABORT exception is triggered.
        	</p>
        </doc>
	</operation>
	
	<operation>
		<name>CLI</name>
		<desc>Clear the interrupt (I) flag</desc>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0x58</opcode>
		</opcodes>
        <doc><p>
        	Clear the interrupt status flag.
        </p></doc>
        <doc mode="65k"><p>
        	Note that the interrupt handling is much more sophisticated in the 65k. 
        	In hypervisor mode setting the interrupt status flag disables all interrupts except the non-maskable interrupt.
        	In user mode setting the interrupt status flag disables all "user level interrupts", but hypervisor interrupts
        	are served. The interrupt level for user level interrupts can be configured in a configuration register.
        	</p>
        </doc>
	</operation>
	
	<operation>
		<name>PLA</name>
		<desc>Pull the contents of the accumulator from the stack</desc>
		<prefixBits>RS</prefixBits>
		<prefixBits>LE</prefixBits>
		<prefixBits>UM</prefixBits>
		<prefixBits>NF</prefixBits>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0x68</opcode>
		</opcodes>
        <doc><p>
        	Pull the value of the accumulator from the stack.
        	</p><pre>
        		A &lt;= Stack(++SP)
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The RS prefix determines the width of the accumulator value as written on the stack.
        	</p><p>
        	The stack pointer used is the one of the current stack if the UM prefix is not set.
        	If UM is set and the opcode is executed in hypervisor mode, the stack pointer used is the 
        	user mode stack pointer and the value is stored in user mode memory. If executed in
        	user mode with UM set an ABORT exception is triggered.
        	</p>
        </doc>
	</operation>
	
	<operation>
		<name>PLY</name>
		<desc>Pull the contents of the Y register from the stack</desc>
		<prefixBits>RS</prefixBits>
		<prefixBits>LE</prefixBits>
		<prefixBits>UM</prefixBits>
		<prefixBits>NF</prefixBits>
        <class>cmos</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0x7a</opcode>
		</opcodes>
        <doc><p>
        	Pull the value of the Y register from the stack.
        	</p><pre>
        		Y &lt;= Stack(++SP)
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The RS prefix determines the width of the accumulator value as written on the stack.
        	</p><p>
        	The stack pointer used is the one of the current stack if the UM prefix is not set.
        	If UM is set and the opcode is executed in hypervisor mode, the stack pointer used is the 
        	user mode stack pointer and the value is stored in user mode memory. If executed in
        	user mode with UM set an ABORT exception is triggered.
        	</p>
        </doc>
	</operation>
	
	<operation>
		<name>PLX</name>
		<desc>Pull the contents of the X register from the stack</desc>
		<prefixBits>RS</prefixBits>
		<prefixBits>LE</prefixBits>
		<prefixBits>UM</prefixBits>
		<prefixBits>NF</prefixBits>
        <class>cmos</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0xfa</opcode>
		</opcodes>
        <doc><p>
        	Pull the value of the X register from the stack.
        	</p><pre>
        		X &lt;= Stack(++SP)
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The RS prefix determines the width of the accumulator value as written on the stack.
        	</p><p>
        	The stack pointer used is the one of the current stack if the UM prefix is not set.
        	If UM is set and the opcode is executed in hypervisor mode, the stack pointer used is the 
        	user mode stack pointer and the value is stored in user mode memory. If executed in
        	user mode with UM set an ABORT exception is triggered.
        	</p>
        </doc>
	</operation>
	
	<operation>
		<name>SEI</name>
		<desc>Set the interrupt (I) flag</desc>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0x78</opcode>
		</opcodes>
        <doc><p>
        	Set the interrupt status flag.
        </p></doc>
        <doc mode="65k"><p>
        	Note that the interrupt handling is much more sophisticated in the 65k. 
        	In hypervisor mode setting the interrupt status flag disables all interrupts except the non-maskable interrupt.
        	In user mode setting the interrupt status flag disables all "user level interrupts", but hypervisor interrupts
        	are served. The interrupt level for user level interrupts can be configured in a configuration register.
        	</p>
        </doc>
	</operation>
	
	<operation>
		<name>DEY</name>
		<desc>Decrement the Y register by one</desc>
		<prefixBits>RS</prefixBits>
		<prefixBits>NF</prefixBits>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0x88</opcode>
		</opcodes>
        <doc><p>
        	Decrement the Y register by one (binary).
        </p><pre>
        	Y &lt;= Y-1
        </pre></doc>
        <doc mode="65k"><p>
        	The RS prefix determines the width of the operation. The NF flag allows to perform the operation
        	without setting flags.
        	</p>
        </doc>
	</operation>
	
	<operation>
		<name>TYA</name>
		<desc>Transfer the contents of the Y register into the accumulator</desc>
		<prefixBits>RS</prefixBits>
		<prefixBits>LE</prefixBits>
		<prefixBits>NF</prefixBits>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0x98</opcode>
		</opcodes>
        <doc><p>
        	Transfer the value of the Y register to the accumulator
        </p><pre>
        	A &lt;= Y
        </pre></doc>
        <doc mode="65k"><p>
        	The RS and LE prefixes determines the width of the operation. LE determines how to extend the value
        	loaded to the full (natural) width. The NF flag allows to perform the operation
        	without setting flags.
        	</p>
        </doc>
	</operation>
	
	<operation>
		<name>TXA</name>
		<desc>Transfer the contents of the X register into the accumulator</desc>
		<prefixBits>RS</prefixBits>
		<prefixBits>LE</prefixBits>
		<prefixBits>NF</prefixBits>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0x8a</opcode>
		</opcodes>
        <doc><p>
        	Transfer the value of the X register to the accumulator
        </p><pre>
        	A &lt;= X
        </pre></doc>
        <doc mode="65k"><p>
        	The RS and LE prefixes determines the width of the operation. LE determines how to extend the value
        	loaded to the full (natural) width. The NF flag allows to perform the operation
        	without setting flags.
        	</p>
        </doc>
	</operation>
	
	<operation>
		<name>TSX</name>
		<desc>Transfer the contents of the stack pointer into the X register (Note: needs RS to keep compatibility with 6502)</desc>
		<prefixBits>UM</prefixBits>
		<prefixBits>NF</prefixBits>
		<prefixBits>RS</prefixBits>
		<prefixBits>LE</prefixBits>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0xba</opcode>
		</opcodes>
        <doc><p>
        	Transfer the value of the stack pointer to the X register
        </p><pre>
        	X &lt;= S
        </pre></doc>
        <doc mode="65k"><p>
        	The RS and LE prefixes determines the width of the operation. LE determines how to extend the value
        	loaded to the full (natural) width. The NF flag allows to perform the operation
        	without setting flags.
        	</p><p>
        	The stack pointer used is the current stack pointer. If the user mode bit is set in hypervisor mode, 
        	the stack pointer used is the user mode stack pointer. If the user mode bit is set in user mode,
        	an ABORT exception is triggered. 
        	</p>
        </doc>
	</operation>
	
	<operation>
		<name>TXS</name>
		<desc>Transfer the contents of X register into the stack pointer (Note: needs RS to keep compatibility with 6502)</desc>
		<prefixBits>RS</prefixBits>
		<prefixBits>LE</prefixBits>
		<prefixBits>UM</prefixBits>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0x9a</opcode>
		</opcodes>
        <doc><p>
        	Transfer the value of the X register to the stack pointer.
        </p><pre>
        	S &lt;= X
        </pre></doc>
        <doc mode="65k"><p>
        	The RS and LE prefixes determines the width of the operation. LE determines how to extend the value
        	loaded to the full (natural) width. The NF flag allows to perform the operation
        	without setting flags.
        	</p><p>
        	The stack pointer used is the current stack pointer. If the user mode bit is set in hypervisor mode, 
        	the stack pointer used is the user mode stack pointer. If the user mode bit is set in user mode,
        	an ABORT exception is triggered. 
        	</p>
        </doc>
	</operation>
	
	<operation>
		<name>TAY</name>
		<desc>Transfer the contents of accumulator into the Y register</desc>
		<prefixBits>RS</prefixBits>
		<prefixBits>LE</prefixBits>
		<prefixBits>NF</prefixBits>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0xa8</opcode>
		</opcodes>
        <doc><p>
        	Transfer the value of the accumulator to the Y register
        </p><pre>
        	Y &lt;= A
        </pre></doc>
        <doc mode="65k"><p>
        	The RS and LE prefixes determines the width of the operation. LE determines how to extend the value
        	loaded to the full (natural) width. The NF flag allows to perform the operation
        	without setting flags.
        	</p>
        </doc>
	</operation>
	
	<operation>
		<name>TAX</name>
		<desc>Transfer the contents of accumulator into the X register</desc>
		<prefixBits>RS</prefixBits>
		<prefixBits>LE</prefixBits>
		<prefixBits>NF</prefixBits>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0xaa</opcode>
		</opcodes>
        <doc><p>
        	Transfer the value of the accumulator to the X register
        </p><pre>
        	X &lt;= A
        </pre></doc>
        <doc mode="65k"><p>
        	The RS and LE prefixes determines the width of the operation. LE determines how to extend the value
        	loaded to the full (natural) width. The NF flag allows to perform the operation
        	without setting flags.
        	</p>
        </doc>
	</operation>
	
	<operation>
		<name>CLV</name>
		<desc>Clear the overflow (V) flag</desc>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0xb8</opcode>
		</opcodes>
        <doc><p>
        	Clear the overflow status flag.
        </p></doc>
	</operation>
	
	<operation>
		<name>INY</name>
		<desc>Increment the content of the Y register by one</desc>
		<prefixBits>RS</prefixBits>
		<prefixBits>NF</prefixBits>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0xc8</opcode>
		</opcodes>
        <doc><p>
        	Increment the Y register by one (binary).
        </p><pre>
        	Y &lt;= Y+1
        </pre></doc>
        <doc mode="65k"><p>
        	The RS prefix determines the width of the operation. The NF flag allows to perform the operation
        	without setting flags.
        	</p>
        </doc>
	</operation>
	
	<operation>
		<name>CLD</name>
		<desc>Clear the decimal (D) flag</desc>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0xd8</opcode>
		</opcodes>
        <doc><p>
        	Clear the decimal mode status flag.
        </p></doc>
	</operation>
	
	<operation>
		<name>INX</name>
		<desc>Increment the content of the X register by one</desc>
		<prefixBits>RS</prefixBits>
		<prefixBits>NF</prefixBits>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0xe8</opcode>
		</opcodes>
        <doc><p>
        	Increment the X register by one (binary).
        </p><pre>
        	X &lt;= X+1
        </pre></doc>
        <doc mode="65k"><p>
        	The RS prefix determines the width of the operation. The NF flag allows to perform the operation
        	without setting flags.
        	</p>
        </doc>
	</operation>
	
	<operation>
		<name>DEX</name>
		<desc>Decrement the content of the X register by one</desc>
		<prefixBits>RS</prefixBits>
		<prefixBits>NF</prefixBits>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0xca</opcode>
		</opcodes>
        <doc><p>
        	Decrement the X register by one (binary).
        </p><pre>
        	X &lt;= X-1
        </pre></doc>
        <doc mode="65k"><p>
        	The RS prefix determines the width of the operation. The NF flag allows to perform the operation
        	without setting flags.
        	</p>
        </doc>
	</operation>
	
	<operation>
		<name>SED</name>
		<desc>Set the decimal (D) flag</desc>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0xf8</opcode>
		</opcodes>
        <doc><p>
        	Set the decimal mode status flag.
        </p></doc>
	</operation>
	    
	<operation>
		<name>NOP</name>
		<desc>No operation</desc>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0xea</opcode>
		</opcodes>
        <doc><p>
        	No Operation.
        </p></doc>
	</operation>

	<!-- ################################# -->

	<operation>
		<name>LEA</name>
		<desc>Load Effective Address: compute the effective address and store it in the E (effective Address) register (always full width)</desc>
		<class>65k</class>
		<prefixBits>AM</prefixBits>
		<prefixBits>OF</prefixBits>
		<prefixBits>UM</prefixBits>
		<prefixBits>NF</prefixBits>
		<opcodes>
			<addressingMode>zpy</addressingMode>
			<opcode>0x02</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>absindy</addressingMode>
			<opcode>0x42</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>absxind</addressingMode>
			<opcode>0x62</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>rel</addressingMode>
			<opcode>0x80</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>zpxind</addressingMode>
			<opcode>0xa1</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>zp</addressingMode>
			<opcode>0x46</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>abs</addressingMode>
			<opcode>0xae</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>zpindy</addressingMode>
			<opcode>0xb1</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>zpind</addressingMode>
			<opcode>0xb2</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>zpx</addressingMode>
			<opcode>0x56</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>absy</addressingMode>
			<opcode>0xb9</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>absx</addressingMode>
			<opcode>0xbe</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>relwide</addressingMode>
			<opcode>0x44</opcode>
			<oppage>EXT</oppage>
		</opcodes>
        <doc><p>
        	Load the effective address given by the addressing mode into the E register (without accessing
        	the memory pointed to by the parameter).
        </p><pre>
        	E &lt;= EffectiveAddress
        </pre></doc>
        <doc mode="65k"><p>
        	The value stored in E is always in the natural (full) width of the processor.
        	</p><p>
        	The AM and OF prefixes are interpreted as usually when computing the address.
        	</p><p>
        	The memory and stack pointers used are the current ones when the user mode prefix is not set.
        	When the user mode prefix is set in hypervisor mode, the memory and stack pointer is that of the
        	user mode. When set in user mode an ABORT is triggered.
        	</p><p>
        	With this approach you can use this in trap handling:
        	</p><pre>
        		LEA.U S,$08			; load user space address of offset 8 on the user mode stack
        		LDA.U (E)			; load the value from user space
        	</pre>
        </doc>
	</operation>

	<operation>
		<name>PEA</name>
		<desc>Push Effective Address: compute the effective address and push it onto the stack (always full width)</desc>
		<class>65k</class>
		<prefixBits>AM</prefixBits>
		<prefixBits>OF</prefixBits>
		<prefixBits>UM</prefixBits>
		<opcodes>
			<addressingMode>zpy</addressingMode>
			<opcode>0x22</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>absindy</addressingMode>
			<opcode>0xc2</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>absxind</addressingMode>
			<opcode>0xe2</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>rel</addressingMode>
			<opcode>0x82</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>zpxind</addressingMode>
			<opcode>0x81</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>zp</addressingMode>
			<opcode>0x85</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>abs</addressingMode>
			<opcode>0xad</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>zpindy</addressingMode>
			<opcode>0x91</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>zpind</addressingMode>
			<opcode>0x92</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>zpx</addressingMode>
			<opcode>0x95</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>absy</addressingMode>
			<opcode>0x99</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>absx</addressingMode>
			<opcode>0xbd</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>relwide</addressingMode>
			<opcode>0x54</opcode>
			<oppage>EXT</oppage>
		</opcodes>
        <doc><p>
        	Push the effective address given by the addressing mode onto the stack (without accessing
        	the memory pointed to by the parameter).
        </p><pre>
        	Stack(SP--) &lt;= &gt;EffectiveAddress
        	Stack(SP--) &lt;= &lt;EffectiveAddress
        </pre></doc>
        <doc mode="65k"><p>
        	The value pushed is always in the natural (full) width of the processor.
        	</p><p>
        	The AM and OF prefixes are interpreted as usually when computing the address.
        	</p><p>
        	The memory and stack pointers used are the current ones when the user mode prefix is not set.
        	When the user mode prefix is set in hypervisor mode, the memory and stack pointer is that of the
        	user mode. When set in user mode an ABORT is triggered.
        	</p><p>
			Note that the stack used to actually store the address is always (no matter the user mode bit)
			the current stack!
			</p> 
        </doc>
	</operation>
		
	<!-- ################################# -->

	<operation>
		<name>MVN</name>
		<desc>Move block of data of size AC from XR to YR, count addresses down. All registers full size, interruptable</desc>
		<class>65k10</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0x04</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>
	
	<operation>
		<name>MVP</name>
		<desc>Move block of data of size AC from XR to YR, count addresses down. All registers full size, interruptable</desc>
		<class>65k10</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0x14</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>
	
	<operation>
		<name>FIL</name>
		<desc>Fill a memory area of size AC at address XR with a value from YR</desc>
		<prefixBits>RS</prefixBits>
		<class>65k10</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0x24</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>
	
	<operation>
		<name>WMB</name>
		<desc>Write memory barrier: flushes dirty caches (globally, or for a specific, given location)</desc>
		<prefixBits>UM</prefixBits>
		<class>65k10</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0x74</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>eind</addressingMode>
			<opcode>0xf4</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>
	
	<operation>
		<name>RMB</name>
		<desc>Read memory barrier: invalidates cache content (globally, or for a specific, given location)</desc>
		<prefixBits>UM</prefixBits>
		<class>65k10</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0x64</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>eind</addressingMode>
			<opcode>0xe4</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>
	
	<operation>
		<name>SCA</name>
		<desc>Store conditional - store the contents of AC into a memory location, if location has not been accessed since 
			LLA with same address (and no other LLA in same thread)</desc>
		<prefixBits>RS</prefixBits>
		<prefixBits>UM</prefixBits>
		<class>65k10</class>
		<opcodes>
			<addressingMode>eind</addressingMode>
			<opcode>0x84</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>
	
	<operation>
		<name>LLA</name>
		<desc>Load linked AC - load the content from a memory location into accumulator, optimistic-locking the address for SCA</desc>
		<prefixBits>RS</prefixBits>
		<prefixBits>LE</prefixBits>
		<prefixBits>UM</prefixBits>
		<prefixBits>NF</prefixBits>
		<class>65k10</class>
		<opcodes>
			<addressingMode>eind</addressingMode>
			<opcode>0x94</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>

	<operation>
		<name>BCN</name>
		<desc>Bit Count: counts 1-bits in AC or in given location, stores number of 1-bits back in AC</desc>
		<prefixBits>RS</prefixBits>
		<prefixBits>NF</prefixBits>
		<class>65k</class>
		<opcodes>
			<addressingMode>A</addressingMode>
			<opcode>0xb4</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<!--opcodes>
			<addressingMode>eind</addressingMode>
			<opcode>0xbc</opcode>
			<oppage>EXT</oppage>
		</opcodes-->
	</operation>

	<operation>
		<name>BSW</name>
		<desc>Bit Swap: exchanges bit 0 with bit W-1, bit 1 with bit W-2 and so on.</desc>
		<prefixBits>RS</prefixBits>
		<prefixBits>NF</prefixBits>
		<class>65k10</class>
		<opcodes>
			<addressingMode>A</addressingMode>
			<opcode>0x38</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<!--opcodes>
			<addressingMode>eind</addressingMode>
			<opcode>0xbc</opcode>
			<oppage>EXT</oppage>
		</opcodes-->
	</operation>

	<operation>
		<name>HBS</name>
		<desc>Highest Bit Set: Determines the number of the highest bit that is set to one.</desc>
		<prefixBits>RS</prefixBits>
		<prefixBits>NF</prefixBits>
		<class>65k10</class>
		<opcodes>
			<addressingMode>A</addressingMode>
			<opcode>0x78</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<!--opcodes>
			<addressingMode>eind</addressingMode>
			<opcode>0xbc</opcode>
			<oppage>EXT</oppage>
		</opcodes-->
	</operation>

	<operation>
		<name>HBC</name>
		<desc>Highest Bit Clear: Determines the number of the highest bit that is set to zero.</desc>
		<prefixBits>RS</prefixBits>
		<prefixBits>NF</prefixBits>
		<class>65k10</class>
		<opcodes>
			<addressingMode>A</addressingMode>
			<opcode>0x18</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<!--opcodes>
			<addressingMode>eind</addressingMode>
			<opcode>0xbc</opcode>
			<oppage>EXT</oppage>
		</opcodes-->
	</operation>

	<operation>
		<name>PSH</name>
		<desc>Push contents of all registers (A, X, Y, B, E) onto the stack</desc> 
		<prefixBits>UM</prefixBits>
		<class>65k10</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0xac</opcode>
			<oppage>EXT</oppage>
		</opcodes>
        <doc><p>
        	Push the content of all registers on the stack.
        	</p><pre>
        		Stack(SP--) &lt;= A
        		Stack(SP--) &lt;= X
        		Stack(SP--) &lt;= Y
        		Stack(SP--) &lt;= B
        		Stack(SP--) &lt;= E
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	All registers are stored in full (natural) width.
        	</p><p>
        	The stack pointer used is the one of the current stack if the UM prefix is not set.
        	If UM is set and the opcode is executed in hypervisor mode, the stack pointer used is the 
        	user mode stack pointer and the value is stored in user mode memory. If executed in
        	user mode with UM set an ABORT exception is triggered.
        	</p>
        </doc>
	</operation>

	<operation>
		<name>PLL</name>
		<desc>Pull the contents of all registers from the stack</desc>
		<prefixBits>UM</prefixBits>
		<class>65k10</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0xcc</opcode>
			<oppage>EXT</oppage>
		</opcodes>
        <doc><p>
        	Pull the value of all registers from the stack.
        	</p><pre>
        		B &lt;= Stack(++SP)
        		E &lt;= Stack(++SP)
        		Y &lt;= Stack(++SP)
        		X &lt;= Stack(++SP)
        		A &lt;= Stack(++SP)
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	All registers are restored in full (natural) width. Flags are not set.
        	</p><p>
        	The stack pointer used is the one of the current stack if the UM prefix is not set.
        	If UM is set and the opcode is executed in hypervisor mode, the stack pointer used is the 
        	user mode stack pointer and the value is stored in user mode memory. If executed in
        	user mode with UM set an ABORT exception is triggered.
        	</p>
        </doc>
	</operation>

	<!-- ################################# -->
	
	<operation>
		<name>INV</name>
		<desc>invert AC, i.e. set AC to the 2s-complement of AC</desc>
		<prefixBits>RS</prefixBits>
		<prefixBits>LE</prefixBits>
		<prefixBits>NF</prefixBits>
		<class>65k</class>
		<opcodes>
			<addressingMode>A</addressingMode>
			<opcode>0xa4</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<!--opcodes>
			<addressingMode>eind</addressingMode>
			<opcode>0xac</opcode>
			<oppage>EXT</oppage>
		</opcodes-->
	</operation>
	
	<operation>
		<name>SWP</name>
		<desc>swap upper and lower part nibble / byte / word / long word of a byte / word / long / quad (longlong) operand in Accumulator</desc>
		<prefixBits>RS</prefixBits>
		<prefixBits>NF</prefixBits>
		<class>65k</class>
		<opcodes>
			<addressingMode>A</addressingMode>
			<opcode>0xd4</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>
		
	<operation>
		<name>EXT</name>
		<desc>Extend a value in AC from RS to the full size. Setting LE defines the type of extension.</desc>
		<prefixBits>RS</prefixBits>
		<prefixBits>LE</prefixBits>
		<prefixBits>NF</prefixBits>
		<class>65k</class>
		<opcodes>
			<addressingMode>A</addressingMode>
			<opcode>0xc4</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>
	
	<!-- ################################# -->
	
	<operation>
		<name>LDE</name>
		<desc>Load E with an immediate value</desc>
		<prefixBits>RS</prefixBits>
		<prefixBits>LE</prefixBits>
		<prefixBits>NF</prefixBits>
        <default-le>sign</default-le>
		<class>65k</class>
		<opcodes>
			<addressingMode>imm</addressingMode>
			<opcode>0x39</opcode>
			<oppage>EXT</oppage>
		</opcodes>
        <doc><p>
        	Read the operand and store it in the E register. Set the flags appropriately.
        	</p><pre>
        		N &lt;= Operand(7)
        		Z &lt;= Z(Operand)
        		E &lt;= Operand
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The LE and RS prefixes are evaluated by the addressing modes. 
        	</p><p>
        	Note that the default load extension is "sign-extended".
        	</p><p>
        	The NF prefix lets the flags unmodified.
        	</p>
        </doc>
	</operation>
	
	<operation>
		<name>LDB</name>
		<desc>Load B with an immediate value</desc>
		<prefixBits>RS</prefixBits>
		<prefixBits>LE</prefixBits>
		<prefixBits>UM</prefixBits>
		<prefixBits>NF</prefixBits>
        <default-le>sign</default-le>
		<class>65k</class>
		<opcodes>
			<addressingMode>imm</addressingMode>
			<opcode>0x59</opcode>
			<oppage>EXT</oppage>
		</opcodes>
        <doc><p>
        	Read the operand and store it in the B register. Set the flags appropriately.
        	</p><pre>
        		N &lt;= Operand(7)
        		Z &lt;= Z(Operand)
        		B &lt;= Operand
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The LE and RS prefixes are evaluated by the addressing modes. 
        	</p><p>
        	Note that the default load extension is "sign-extended".
        	</p><p>
        	The NF prefix lets the flags unmodified.
        	</p>
        </doc>
	</operation>
		

	<operation>
		<name>PHE</name>
		<desc>Push E onto stack (always full width)</desc>
		<prefixBits>UM</prefixBits>
		<class>65k</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0x08</opcode>
			<oppage>EXT</oppage>
		</opcodes>
        <doc><p>
        	Push the content of the E register on the stack.
        	</p><pre>
        		Stack(SP--) &lt;= E
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The value stored is always in the natural width of the processor (mode).
        	</p><p>
        	The stack pointer used is the one of the current stack if the UM prefix is not set.
        	If UM is set and the opcode is executed in hypervisor mode, the stack pointer used is the 
        	user mode stack pointer and the value is stored in user mode memory. If executed in
        	user mode with UM set an ABORT exception is triggered.
        	</p>
        </doc>
	</operation>

	<operation>
		<name>PLE</name>
		<desc>Pull E from stack (full width)</desc>
		<prefixBits>UM</prefixBits>
		<prefixBits>NF</prefixBits>
		<class>65k</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0x28</opcode>
			<oppage>EXT</oppage>
		</opcodes>
        <doc><p>
        	Pull the value of the E register from the stack.
        	</p><pre>
        		E &lt;= Stack(++SP)
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The value retrieved is always in the natural width of the processor (mode).
        	</p><p>
        	The stack pointer used is the one of the current stack if the UM prefix is not set.
        	If UM is set and the opcode is executed in hypervisor mode, the stack pointer used is the 
        	user mode stack pointer and the value is stored in user mode memory. If executed in
        	user mode with UM set an ABORT exception is triggered.
        	</p>
        </doc>
	</operation>

	<operation>
		<name>PHB</name>
		<desc>Push B onto stack (full width)</desc>
		<prefixBits>UM</prefixBits>
		<class>65k</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0x48</opcode>
			<oppage>EXT</oppage>
		</opcodes>
        <doc><p>
        	Push the content of the B register on the stack.
        	</p><pre>
        		Stack(SP--) &lt;= B
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The value stored is always in the natural width of the processor (mode).
        	</p><p>
        	The stack pointer used is the one of the current stack if the UM prefix is not set.
        	If UM is set and the opcode is executed in hypervisor mode, the stack pointer used is the 
        	user mode stack pointer and the value is stored in user mode memory. If executed in
        	user mode with UM set an ABORT exception is triggered.
        	</p>
        </doc>
	</operation>

	<operation>
		<name>PRB</name>
		<desc>Push and Replace Base register: Push base offset register to the stack, then transfer accumulator to the base register</desc>
		<prefixBits>UM</prefixBits>
		<prefixBits>NF</prefixBits>
		<class>65k</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0x58</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>

	<operation>
		<name>PLB</name>
		<desc>Pull E from stack (full width)</desc>
		<prefixBits>UM</prefixBits>
		<prefixBits>NF</prefixBits>
		<class>65k</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0x68</opcode>
			<oppage>EXT</oppage>
		</opcodes>
        <doc><p>
        	Pull the value of the B register from the stack.
        	</p><pre>
        	B &lt;= Stack(++SP)
        	</pre>
        </doc>
        <doc mode="65k"><p>
        	The value retrieved is always in the natural width of the processor (mode).
        	</p><p>
        	The stack pointer used is the one of the current stack if the UM prefix is not set.
        	If UM is set and the opcode is executed in hypervisor mode, the stack pointer used is the 
        	user mode stack pointer and the value is stored in user mode memory. If executed in
        	user mode with UM set an ABORT exception is triggered.
        	</p>
        </doc>
	</operation>

	<operation>
		<name>TPA</name>
		<desc>Transfer Program counter to Accumulator</desc>
		<prefixBits>NF</prefixBits>
		<class>65k</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0xc8</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>

	<operation>
		<name>TBA</name>
		<desc>Transfer base register B to Accumulator</desc>
		<prefixBits>NF</prefixBits>
		<class>65k</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0xf8</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>

	<operation>
		<name>TEA</name>
		<desc>Transfer E register to Accumulator</desc>
		<prefixBits>NF</prefixBits>
		<class>65k</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0x98</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>

	<operation>
		<name>TAE</name>
		<desc>Transfer AC to E register</desc>
		<prefixBits>NF</prefixBits>
		<prefixBits>LE</prefixBits>
		<prefixBits>RS</prefixBits>
		<class>65k</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0x88</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>

	<operation>
		<name>TYS</name>
		<desc>Transfer Y to stack pointer</desc>
		<prefixBits>LE</prefixBits>
		<prefixBits>RS</prefixBits>
		<prefixBits>UM</prefixBits>
		<class>65k</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0x8a</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>

	<operation>
		<name>TSY</name>
		<desc>Transfer stack pointer to Y</desc>
		<prefixBits>NF</prefixBits>
		<prefixBits>UM</prefixBits>
		<prefixBits>RS</prefixBits>
		<prefixBits>LE</prefixBits>
		<class>65k</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0xca</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>

	<operation>
		<name>TAB</name>
		<desc>Transfer AC to B register</desc>
		<prefixBits>NF</prefixBits>
		<prefixBits>LE</prefixBits>
		<prefixBits>RS</prefixBits>
		<class>65k</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0xe8</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>

	<operation>
		<name>TEB</name>
		<desc>Transfer E to B register (full width)</desc>
		<prefixBits>NF</prefixBits>
		<class>65k</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0xea</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>

	<operation>
		<name>TBE</name>
		<desc>Transfer content of B register into E register (full width)</desc>
		<prefixBits>NF</prefixBits>
		<class>65k</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0xfa</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>

	<!-- ################################# -->

	<operation>
		<name>SEB</name>
		<desc>Swap E register with B register. Always done full width, no flags set.</desc>
		<class>65k</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0xb8</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>

	<operation>
		<name>SAB</name>
		<desc>Swap A register with B register. Always done full width, no flags set.</desc>
		<class>65k</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0xa8</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>

	<operation>
		<name>SAE</name>
		<desc>Swap AC with E register. Always done full width, no flags set.</desc>
		<class>65k</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0xd8</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>

	<operation>
		<name>SAX</name>
		<desc>Swap AC with X register. Always done full width, no flags set.</desc>
		<class>65k</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0xba</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>

	<operation>
		<name>SAY</name>
		<desc>Swap AC with Y register. Always done full width, no flags set.</desc>
		<class>65k</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0xda</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>


	<operation>
		<name>SXY</name>
		<desc>Swap X with Y register. Always done full width, no flags set.</desc>
		<class>65k</class>
		<opcodes>
			<addressingMode>implied</addressingMode>
			<opcode>0x9a</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>

	
	<!-- ################################# -->

	<operation>
		<name>ADE</name>
		<desc>Add value to E register</desc>
		<prefixBits>RS</prefixBits>
		<prefixBits>LE</prefixBits>
		<prefixBits>NF</prefixBits>
		<class>65k</class>
		<opcodes>
			<addressingMode>imm</addressingMode>
			<opcode>0x25</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>A</addressingMode>
			<opcode>0x35</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>

	<operation>
		<name>ADS</name>
		<desc>Add value to stack pointer</desc>
		<prefixBits>RS</prefixBits>
		<prefixBits>LE</prefixBits>
		<prefixBits>NF</prefixBits>
		<prefixBits>UM</prefixBits>
		<class>65k</class>
		<opcodes>
			<addressingMode>imm</addressingMode>
			<opcode>0x45</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>A</addressingMode>
			<opcode>0x55</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>

	<operation>
		<name>ADB</name>
		<desc>Add value to B register</desc>
		<prefixBits>RS</prefixBits>
		<prefixBits>LE</prefixBits>
		<prefixBits>NF</prefixBits>
		<class>65k</class>
		<opcodes>
			<addressingMode>imm</addressingMode>
			<opcode>0x65</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>A</addressingMode>
			<opcode>0x75</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>

	<operation>
		<name>SBE</name>
		<desc>Add value to E register</desc>
		<prefixBits>RS</prefixBits>
		<prefixBits>LE</prefixBits>
		<prefixBits>NF</prefixBits>
		<class>65k</class>
		<opcodes>
			<addressingMode>imm</addressingMode>
			<opcode>0xa5</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>A</addressingMode>
			<opcode>0xb5</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>

	<operation>
		<name>SBS</name>
		<desc>Substract value from stack pointer</desc>
		<prefixBits>RS</prefixBits>
		<prefixBits>LE</prefixBits>
		<prefixBits>NF</prefixBits>
		<prefixBits>UM</prefixBits>
		<class>65k</class>
		<opcodes>
			<addressingMode>imm</addressingMode>
			<opcode>0xc5</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>A</addressingMode>
			<opcode>0xd5</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>

	<operation>
		<name>SBB</name>
		<desc>Substract value from B register</desc>
		<prefixBits>RS</prefixBits>
		<prefixBits>LE</prefixBits>
		<prefixBits>NF</prefixBits>
		<class>65k</class>
		<opcodes>
			<addressingMode>imm</addressingMode>
			<opcode>0xe5</opcode>
			<oppage>EXT</oppage>
		</opcodes>
		<opcodes>
			<addressingMode>A</addressingMode>
			<opcode>0xf5</opcode>
			<oppage>EXT</oppage>
		</opcodes>
	</operation>


	<!-- ################################# -->

	<syntax>
		<id>implied</id>
		<desc>Empty syntax, either AC or implied addressing modes.</desc>
		<simplesyntax></simplesyntax>
		<mode>
			<!--width>0</width-->
			<addrMode>A</addrMode>
		</mode>
		<mode>
			<!--width>0</width-->
			<addrMode>implied</addrMode>
		</mode>
	</syntax>
	
	<syntax>
		<id>immediate</id>
		<desc>Immediate addressing: operand directly follows the opcode.</desc>
		<simplesyntax>#&lt;operand&gt;</simplesyntax>
		<mode>
			<!--width>1</width-->
			<addrMode>imm</addrMode>
		</mode>
		<mode>
			<!--width>2</width-->
			<addrMode>imm2</addrMode>
			<class>65k</class>
			<prefix>
				<name>RS</name>
				<value>01</value>
			</prefix>
		</mode>
		<mode>
			<!--width>4</width-->
			<addrMode>imm4</addrMode>
			<class>65k</class>
			<prefix>
				<name>RS</name>
				<value>10</value>
			</prefix>
		</mode>
		<mode>
			<!--width>8</width-->
			<addrMode>imm8</addrMode>
			<class>65k</class>
			<prefix>
				<name>RS</name>
				<value>11</value>
			</prefix>
		</mode>
	</syntax>

	<syntax>
		<id>absolute</id>
		<desc>Opcode is followed by an address for the operand</desc>
		<simplesyntax>&lt;address&gt;</simplesyntax>
		<mode>
			<addrMode>zp</addrMode>
		</mode>
		<mode>
			<addrMode>abs</addrMode>
		</mode>
		<mode>
			<addrMode>long</addrMode>
			<class>65k</class>
			<prefix>
				<name>AM</name>
				<value>1</value>
			</prefix>
		</mode>
		<mode>
			<addrMode>quad</addrMode>
			<class>65k</class>
			<prefix>
				<name>AM</name>
				<value>1</value>
			</prefix>
		</mode>
		<mode>
			<addrMode>addr</addrMode>
		</mode>
		<mode>
			<addrMode>addrlong</addrMode>
			<class>65k</class>
			<prefix>
				<name>AM</name>
				<value>1</value>
			</prefix>
		</mode>
		<mode>
			<addrMode>addrquad</addrMode>
			<class>65k</class>
			<prefix>
				<name>AM</name>
				<value>1</value>
			</prefix>
		</mode>
		<mode>
			<addrMode>rel</addrMode>
	        <simplesyntax>rel</simplesyntax>
		</mode>
		<mode>
			<addrMode>relwide</addrMode>
	        <simplesyntax>relwide</simplesyntax>
			<class>65k</class>
			<prefix>
				<name>RS</name>
				<value>01</value>
			</prefix>
		</mode>
		<mode>
			<addrMode>rellong</addrMode>
	        <simplesyntax>rellong</simplesyntax>
			<class>65k</class>
			<prefix>
				<name>RS</name>
				<value>10</value>
			</prefix>
		</mode>
		<mode>
			<addrMode>relquad</addrMode>
	        <simplesyntax>relquad</simplesyntax>
			<class>65k</class>
			<prefix>
				<name>RS</name>
				<value>11</value>
			</prefix>
		</mode>
		<mode>
			<addrMode>relj</addrMode>
	        <simplesyntax>rel</simplesyntax>
		</mode>
		<mode>
			<addrMode>reljwide</addrMode>
	        <simplesyntax>relwide</simplesyntax>
			<class>65k</class>
		</mode>
		<mode>
			<addrMode>reljlong</addrMode>
	        <simplesyntax>rellong</simplesyntax>
			<class>65k</class>
			<prefix>
				<name>AM</name>
				<value>1</value>
			</prefix>
		</mode>
		<mode>
			<addrMode>reljquad</addrMode>
	        <simplesyntax>relquad</simplesyntax>
			<class>65k</class>
			<prefix>
				<name>AM</name>
				<value>1</value>
			</prefix>
		</mode>
	</syntax>

	<syntax>
		<id>absolutex</id>
		<desc>The X register is added to the operand following the opcode</desc>
		<simplesyntax>&lt;address&gt;,X</simplesyntax>
		<mode>
			<addrMode>zpx</addrMode>
		</mode>
		<mode>
			<addrMode>absx</addrMode>
		</mode>
		<mode>
			<addrMode>longx</addrMode>
			<prefix>
				<name>AM</name>
				<value>1</value>
			</prefix>
		</mode>
		<mode>
			<addrMode>quadx</addrMode>
			<prefix>
				<name>AM</name>
				<value>1</value>
			</prefix>
		</mode>
	</syntax>
	
	<syntax>
		<id>absolutey</id>
		<desc>The Y register is added to the operand following the opcode</desc>
		<simplesyntax>&lt;address&gt;,Y</simplesyntax>
		<mode>
			<addrMode>zpy</addrMode>
		</mode>
		<mode>
			<addrMode>absy</addrMode>
		</mode>
		<mode>
			<addrMode>longy</addrMode>
			<prefix>
				<name>AM</name>
				<value>1</value>
			</prefix>
		</mode>
		<mode>
			<addrMode>quady</addrMode>
			<prefix>
				<name>AM</name>
				<value>1</value>
			</prefix>
		</mode>
	</syntax>
	
	<syntax>
		<id>indirect</id>
		<desc>The opcode is followed by an address, from which the effective address of the operand is read.
			The effective address is taken as a wide address (16 bit)</desc>
		<simplesyntax>(&lt;address&gt;)</simplesyntax>
		<mode>
			<addrMode>zpind</addrMode>
		</mode>
		<mode>
			<addrMode>absind</addrMode>
		</mode>
	</syntax>

	<syntax>
		<id>eindirect</id>
		<desc>The effective operand address is taken from the E register</desc>
		<simplesyntax>(E)</simplesyntax>
		<mode>
			<addrMode>eind</addrMode>
		</mode>
	</syntax>
	
	<syntax>
		<id>indirectlong</id>
		<desc>The opcode is followed by an address, from which the effective address of the operand is read.
			The effective address is taken as a long address (32 bit)</desc>
		<simplesyntax>[&lt;address&gt;]</simplesyntax>
		<mode>
			<addrMode>zpindlong</addrMode>
			<prefix>
				<name>AM</name>
				<value>1</value>
			</prefix>
		</mode>
		<mode>
			<addrMode>absindlong</addrMode>
			<prefix>
				<name>AM</name>
				<value>1</value>
			</prefix>
		</mode>
	</syntax>
	
	<syntax>
		<id>indirectquad</id>
		<desc>The opcode is followed by an address, from which the effective address of the operand is read.
			The effective address is taken as a quad address (64 bit)</desc>
		<simplesyntax>[[&lt;address&gt;]]</simplesyntax>
		<mode>
			<addrMode>zpindquad</addrMode>
			<prefix>
				<name>AM</name>
				<value>1</value>
			</prefix>
		</mode>
		<mode>
			<addrMode>absindquad</addrMode>
			<prefix>
				<name>AM</name>
				<value>1</value>
			</prefix>
		</mode>
	</syntax>
	
	<syntax>
		<id>indirecty</id>
		<desc>The opcode is followed by an address, from which an address read.
			This address is taken as a wide address (16 bit). The Y register is added to the address, the result
			is taken as the effective address of the operand.</desc>
		<simplesyntax>(&lt;address&gt;),Y</simplesyntax>
		<mode>
			<addrMode>zpindy</addrMode>
		</mode>
		<mode>
			<addrMode>absindy</addrMode>
		</mode>
	</syntax>
	
	<syntax>
		<id>indirectylong</id>
		<desc>The opcode is followed by an address, from which an address read.
			This address is taken as a long address (32 bit). The Y register is added to the address, the result
			is taken as the effective address of the operand.</desc>
		<simplesyntax>[&lt;address&gt;],Y</simplesyntax>
		<mode>
			<!--width>1</width-->
			<addrMode>zpindylong</addrMode>
			<prefix>
				<name>AM</name>
				<value>1</value>
			</prefix>
		</mode>
		<mode>
			<!--width>2</width-->
			<addrMode>absindylong</addrMode>
			<prefix>
				<name>AM</name>
				<value>1</value>
			</prefix>
		</mode>
	</syntax>
	
	<syntax>
		<id>indirectyquad</id>
		<desc>The opcode is followed by an address, from which an address read.
			This address is taken as a quad address (64 bit). The Y register is added to the address, the result
			is taken as the effective address of the operand.</desc>
		<simplesyntax>[[&lt;address&gt;]],Y</simplesyntax>
		<mode>
			<!--width>1</width-->
			<addrMode>zpindyquad</addrMode>
			<prefix>
				<name>AM</name>
				<value>1</value>
			</prefix>
		</mode>
		<mode>
			<!--width>2</width-->
			<addrMode>absindyquad</addrMode>
			<prefix>
				<name>AM</name>
				<value>1</value>
			</prefix>
		</mode>
	</syntax>
	
	<syntax>
		<id>xindirect</id>
		<desc>The opcode is followed by an address. The X register is added to this address. From the result the effective operand address is read.
			The effective address is taken as a wide address (16 bit).</desc>
		<simplesyntax>(&lt;address&gt;,X)</simplesyntax>
		<mode>
			<!--width>1</width-->
			<addrMode>zpxind</addrMode>
		</mode>
		<mode>
			<!--width>2</width-->
			<addrMode>absxind</addrMode>
		</mode>
	</syntax>
	
	<syntax>
		<id>xindirectlong</id>
		<desc>The opcode is followed by an address. The X register is added to this address. From the result the effective operand address is read.
			The effective address is taken as a long address (32 bit).</desc>
		<simplesyntax>[&lt;address&gt;,X]</simplesyntax>
		<mode>
			<!--width>1</width-->
			<addrMode>zpxindlong</addrMode>
			<prefix>
				<name>AM</name>
				<value>1</value>
			</prefix>
		</mode>
		<mode>
			<!--width>2</width-->
			<addrMode>absxindlong</addrMode>
			<prefix>
				<name>AM</name>
				<value>1</value>
			</prefix>
		</mode>
	</syntax>
	
	<syntax>
		<id>xindirectquad</id>
		<desc>The opcode is followed by an address. The X register is added to this address. From the result the effective operand address is read.
			The effective address is taken as a quad address (64 bit).</desc>
		<simplesyntax>[[&lt;address&gt;,X]]</simplesyntax>
		<mode>
			<!--width>1</width-->
			<addrMode>zpxindquad</addrMode>
			<prefix>
				<name>AM</name>
				<value>1</value>
			</prefix>
		</mode>
		<mode>
			<!--width>2</width-->
			<addrMode>absxindquad</addrMode>
			<prefix>
				<name>AM</name>
				<value>1</value>
			</prefix>
		</mode>
	</syntax>
	
	
	<!-- ################################# -->
	    
    <addrmode>
    	<name>Implied</name>
        <desc>Implied by the operation</desc>
        <identifier>implied</identifier>
        <ignoredPrefixes>AM</ignoredPrefixes>
        <ignoredPrefixes>OF</ignoredPrefixes>
        <width>0</width>
    </addrmode>
    
    <addrmode>
    	<name>Accumulator</name>
    	<identifier>A</identifier>
    	<desc>Accumulator operation</desc>
        <ignoredPrefixes>AM</ignoredPrefixes>
        <ignoredPrefixes>UM</ignoredPrefixes>
        <ignoredPrefixes>OF</ignoredPrefixes>
        <ignoredPrefixes>LE</ignoredPrefixes>
        <width>0</width>
    </addrmode>

	<!-- ################################# -->
	
    <addrmode>
    	<name>Address</name>
        <desc>The parameter following the opcode is an address (16 bit; for JMP, JSR, JPU)</desc>
        <identifier>addr</identifier>
        <altMode>addrquad</altMode>
        <width>2</width>
    </addrmode>
    
    <addrmode>
    	<name>Address Long</name>
        <desc>The parameter following the opcode is an address (32 bit; for JMP, JSR, JPU)</desc>
        <identifier>addrlong</identifier>
        <width>4</width>
    </addrmode>
    
    <addrmode>
    	<name>Address Quad</name>
        <desc>The parameter following the opcode is an address (32 bit; for JMP, JSR, JPU)</desc>
        <identifier>addrquad</identifier>
        <width>8</width>
    </addrmode>
    
	<!-- ################################# -->
	
    <addrmode>
    	<name>Immediate</name>
        <desc>The immediate addressing mode uses the opcode parameter directly, without further lookup. Here it is a byte parameter</desc>
        <identifier>imm</identifier>
        <ignoredPrefixes>AM</ignoredPrefixes>
        <ignoredPrefixes>UM</ignoredPrefixes>
        <ignoredPrefixes>OF</ignoredPrefixes>
        <width>1</width>
    </addrmode>
    
    <addrmode>
    	<name>Immediate 16bit</name>
    	<altname>Wide immediate</altname>
        <desc>The immediate addressing mode uses the opcode parameter directly, without further lookup. Here it is a word (16bit) parameter</desc>
        <identifier>imm2</identifier>
        <ignoredPrefixes>AM</ignoredPrefixes>
        <ignoredPrefixes>UM</ignoredPrefixes>
        <width>2</width>
    </addrmode>
    
    <addrmode>
    	<name>Immediate 32bit</name>
    	<altname>Long immediate</altname>
        <desc>The immediate addressing mode uses the opcode parameter directly, without further lookup. Here it is a long (32bit) parameter</desc>
        <identifier>imm4</identifier>
        <ignoredPrefixes>AM</ignoredPrefixes>
        <ignoredPrefixes>UM</ignoredPrefixes>
        <width>4</width>
    </addrmode>
    
    <addrmode>
    	<name>Immediate 64bit</name>
        <desc>The immediate addressing mode uses the opcode parameter directly, without further lookup. Here it is a quad (64bit) parameter</desc>
        <identifier>imm8</identifier>
        <ignoredPrefixes>AM</ignoredPrefixes>
        <ignoredPrefixes>UM</ignoredPrefixes>
        <width>8</width>
    </addrmode>
    
	<!-- ################################# -->
	
    <addrmode>
    	<name>E indirect</name>
    	<identifier>eind</identifier>
    	<desc>E-register indirect: the effective address is taken from the E register.</desc>
    	<class>65k</class>
        <ignoredPrefixes>AM</ignoredPrefixes>
        <ignoredPrefixes>OF</ignoredPrefixes>
        <width>0</width>
    </addrmode>
    
	<!-- ################################# -->
	    
    <addrmode>
    	<name>Zeropage</name>
        <identifier>zp</identifier>
        <desc>Zeropage address; The effective address of the operand is a zeropage address (i.e. 8bit)</desc>
        <altMode>long</altMode>
        <width>1</width>
    </addrmode>
    
    <addrmode>
    	<name>Zeropage indexed with X</name>
    	<altname>Zeropage X-indexed</altname>
        <identifier>zpx</identifier>
        <desc>Zeropage address, plus content of XR; The effective address of the operand is the opcode parameter (zeropage address), plus the value of the X register</desc>
        <altMode>longx</altMode>
        <width>1</width>
    </addrmode>

    <addrmode>
    	<name>Zeropage indexed with Y</name>
    	<altname>Zeropage Y-indexed</altname>
        <identifier>zpy</identifier>
        <desc>Zeropage address, plus content of YR; The effective address of the operand is the opcode parameter (zeropage address), plus the value of the Y register</desc>
        <altMode>longy</altMode>
        <width>1</width>
    </addrmode>

    <addrmode>
    	<name>Absolute 16bit</name>
    	<altname>Absolute</altname>
        <identifier>abs</identifier>
        <desc>16 bit address; The effective address of the operand is the word address (i.e. 16 bit) given as opcode parameter</desc>
        <altMode>quad</altMode>
        <width>2</width>
    </addrmode>
    
    <addrmode>
    	<name>Absolute 16bit indexed with X</name>
    	<altname>Absolute X-indexed</altname>
        <identifier>absx</identifier>
        <desc>16 bit address, plus content of XR; The effective address is the opcode parameter (word address), plus the value of the X register</desc>
        <altMode>quadx</altMode>
        <width>2</width>
    </addrmode>

    <addrmode>
    	<name>Absolute 16bit indexed with Y</name>
    	<altname>Absolute Y-indexed</altname>
        <identifier>absy</identifier>
        <desc>16 bit address, plus content of YR; The effective address is the opcode parameter (word address), plus the value of the Y register</desc>
        <altMode>quady</altMode>
        <width>2</width>
    </addrmode>
    
    <addrmode>
    	<name>Absolute 32bit</name>
    	<altname>Long absolute</altname>
        <identifier>long</identifier>
        <desc>32 bit address; The effective address is the opcode parameter, which is a long address (i.e. 32 bit)</desc>
    	<class>65k</class>
        <width>4</width>
    </addrmode>
    
    <addrmode>
    	<name>Absolute 32bit indexed with X</name>
    	<altname>Long absolute X-indexed</altname>
        <identifier>longx</identifier>
        <desc>32 bit address, plus content of XR; The effective address is the opcode parameter (long address), plus the value of the X register</desc>
    	<class>65k</class>
        <width>4</width>
    </addrmode>

    <addrmode>
    	<name>Absolute 32bit indexed with Y</name>
    	<altname>Long absolute Y-indexed</altname>
        <identifier>longy</identifier>
        <desc>32 bit address, plus content of YR; The effective address is the opcode parameter (long address), plus the value of the Y register</desc>
    	<class>65k</class>
        <width>4</width>
    </addrmode>
    
    <addrmode>
    	<name>Absolute 64bit</name>
    	<altname>Quad absolute</altname>
        <identifier>quad</identifier>
        <desc>64 bit address; The effective address is the opcode parameter, which is a quad address (i.e. 64 bit)</desc>
    	<class>65k</class>
        <width>8</width>
    </addrmode>
    
    <addrmode>
    	<name>Absolute 64bit indexed with X</name>
    	<altname>Quad absolute X-indexed</altname>
        <identifier>quadx</identifier>
        <desc>64 bit address, plus content of XR; The effective address is the opcode parameter (quad address), plus the value of the X register</desc>
    	<class>65k</class>
        <width>8</width>
    </addrmode>

    <addrmode>
    	<name>Absolute 64bit indexed with Y</name>
    	<altname>Quad absolute Y-indexed</altname>
        <identifier>quady</identifier>
        <desc>64 bit address, plus content of YR; The effective address is the opcode parameter (quad address), plus the value of the Y register</desc>
    	<class>65k</class>
        <width>8</width>
    </addrmode>

	<!-- ################################# -->
	    
    <addrmode>
    	<name>Zeropage indirect 16bit</name>
    	<altname>Zeropage indirect</altname>
        <identifier>zpind</identifier>
        <desc>Load effective 16 bit address from zeropage location given; Load effective word (16bit) address from zeropage location given as parameter.</desc>
        <altMode>zpindlong</altMode>
    	<class>cmos</class>
        <width>1</width>
    </addrmode>
    
    <addrmode>
        <name>Zeropage indirect 16bit indexed with Y</name>
        <altname>Zeropage indirect Y-indexed</altname>
        <identifier>zpindy</identifier>
        <desc>Load effective 16 bit address from zeropage location given, then add content of YR; 
        	The effective address is computed as the word (16bit) address read from the zeropage location given as parameter plus the value of the Y register. The resulting address may be larger than 16bit due to overflow when Y is added.</desc>
        <altMode>zpindylong</altMode>
        <width>1</width>
    </addrmode>

    <addrmode>
        <name>Zeropage indexed with X indirect 16bit</name>
        <altname>Zeropage X-indexed indirect</altname>
        <identifier>zpxind</identifier>
        <desc>Load effective 16 bit address from zeropage location given plus content of XR; 
        	The effective word (16bit) address is read from the location that is computed as the zeropage location given as parameter plus the value of the X register</desc>
        <altMode>zpxindlong</altMode>
        <width>1</width>
    </addrmode>
    
    <addrmode>
    	<name>Absolute indirect 16bit</name>
    	<altname>Absolute indirect</altname>
        <identifier>absind</identifier>
        <desc>Load effective 16 bit address from absolute location given; 
        	The effective word (16bit) address is read from word location given as parameter.</desc>
        <altMode>absindlong</altMode>
        <width>2</width>
    </addrmode>
    
    <addrmode>
    	<name>Absolute indirect 16bit indexed with Y</name>
    	<altname>Absolute indirect Y-indexed</altname>
        <identifier>absindy</identifier>
        <desc>Load effective 16 bit address from absolute location given, then add content of YR; 
        	The effective address is computed as the word (16bit) address read from the word location given as parameter plus the value of the Y register. The resulting address may be larger than 16bit due to overflow when Y is added.</desc>
        <altMode>absindylong</altMode>
        <class>65k</class>
        <width>2</width>
    </addrmode>

    <addrmode>
    	<name>Absolute indexed with X indirect 16bit</name>
    	<altname>Absolute X-indexed indirect</altname>
        <identifier>absxind</identifier>
        <desc>Load effective 16 bit address from absolute location given plus content of XR;
        	The effective word address is read from the location that is computed as the word location given as parameter plus the value of the X register</desc>
        <altMode>absxindlong</altMode>
        <class>cmos</class>
        <width>2</width>
    </addrmode>
    
	<!-- ################################# -->

    <addrmode>
    	<name>Zeropage indirect 32bit</name>
    	<altname>Long Zeropage indirect</altname>
        <identifier>zpindlong</identifier>
        <desc>Load effective 32 bit address from zeropage location given; 
        	The effective long (32bit) address is read from zeropage location given as parameter.</desc>
    	<class>65k</class>
        <width>1</width>
    </addrmode>
    
    <addrmode>
    	<name>Zeropage indirect 32bit indexed with Y</name>
    	<altname>Zeropage long indirect Y-indexed</altname>
        <identifier>zpindylong</identifier>
        <desc>Load effective 32 bit address from zeropage location given, then add content of YR;
        	The effective address is computed as the long (32bit) address read from the zeropage location given as parameter plus the value of the Y register.  The resulting address may be larger than 32bit due to overflow when Y is added.</desc>
    	<class>65k</class>
        <width>1</width>
    </addrmode>

    <addrmode>
    	<name>Zeropage indexed with X indirect 32bit</name>
    	<altname>Zeropage X-indexed long indirect</altname>
        <identifier>zpxindlong</identifier>
        <desc>Load effective 32 bit address from zeropage location given plus content of XR;
        	The effective long (32bit) address is read from the location that is computed as the zeropage location given as parameter plus the value of the X register</desc>
    	<class>65k</class>
        <width>1</width>
    </addrmode>
    
    <addrmode>
    	<name>Absolute indirect 32bit</name>
    	<altname>Absolute long indirect</altname>
        <identifier>absindlong</identifier>
        <desc>Load effective 32 bit address from absolute location given;
        	The effective long (32bit) address is read from word location given as parameter.</desc>
    	<class>65k</class>
        <width>2</width>
    </addrmode>
    
    <addrmode>
    	<name>Absolute indirect 32bit indexed with Y</name>
    	<altname>Absolute long indirect Y-indexed</altname>
        <identifier>absindylong</identifier>
        <desc>Load effective 32 bit address from absolute location given, then add content of YR;
        	The effective address is computed as the long address read from the word location given as parameter plus the value of the Y register.  The resulting address may be larger than 32bit due to overflow when Y is added.</desc>
    	<class>65k</class>
        <width>2</width>
    </addrmode>

    <addrmode>
    	<name>Absolute indexed with X indirect 32bit</name>
    	<altname>Absolute X-indexed long indirect</altname>
        <identifier>absxindlong</identifier>
        <desc>Load effective 32 bit address from absolute location given plus content of XR;
        	The effective long (32bit) address is read from the location that is computed as the word location given as parameter plus the value of the X register</desc>
    	<class>65k</class>
        <width>2</width>
    </addrmode>
    
	<!-- ################################# -->

    <addrmode>
    	<name>Zeropage indirect 64bit</name>
    	<altname>Zeropage quad indirect</altname>
        <identifier>zpindquad</identifier>
        <desc>Load effective 64 bit address from zeropage location given;
        	The effective quad (64bit) address is read from zeropage location given as parameter.</desc>
    	<class>65k</class>
        <width>1</width>
    </addrmode>
    
    <addrmode>
    	<name>Zeropage indirect 64bit indexed with Y</name>
    	<altname>Zeropage quad indirect Y-indexed</altname>
        <identifier>zpindyquad</identifier>
        <desc>Load effective 64 bit address from zeropage location given, then add content of YR;
        	The effective address is computed as the quad (64bit) address read from the zeropage location given as parameter plus the value of the Y register</desc>
    	<class>65k</class>
        <width>1</width>
    </addrmode>

    <addrmode>
    	<name>Zeropage indexed with X indirect 64bit</name>
    	<altname>Zeropage X-indexed quad indirect</altname>
        <identifier>zpxindquad</identifier>
        <desc>Load effective 64 bit address from zeropage location given plus content of XR;
        	The effective quad (64bit) address is read from the location that is computed as the zeropage location given as parameter plus the value of the X register</desc>
    	<class>65k</class>
        <width>1</width>
    </addrmode>
    
    <addrmode>
    	<name>Absolute indirect 64bit</name>
    	<altname>Absolute quad indirect</altname>
        <identifier>absindquad</identifier>
        <desc>Load effective 64 bit address from absolute location given;
        	The effective quad (64bit) address is read from word location given as parameter.</desc>
    	<class>65k</class>
        <width>2</width>
    </addrmode>
    
    <addrmode>
    	<name>Absolute indirect 64bit indexed with Y</name>
    	<altname>Absolute quad indirect Y-indexed</altname>
        <identifier>absindyquad</identifier>
        <desc>Load effective 64 bit address from absolute location given, then add content of YR;
        	The effective address is computed as the quad address read from the word location given as parameter plus the value of the Y register</desc>
    	<class>65k</class>
        <width>2</width>
    </addrmode>

    <addrmode>
    	<name>Absolute indexed with X indirect 64bit</name>
    	<altname>Absolute X-indexed quad indirect</altname>
        <identifier>absxindquad</identifier>
        <desc>Load effective 64 bit address from absolute location given plus content of XR;
        	The effective quad (64bit) address is read from the location that is computed as the word location given as parameter plus the value of the X register</desc>
    	<class>65k</class>
        <width>2</width>
    </addrmode>
    
	<!-- ################################# -->
	    
    <addrmode>
    	<name>Relative</name>
        <desc>relative addressing modes, used in branches; from -128 to +127</desc>
        <identifier>rel</identifier>
        <altMode>rellong</altMode>
        <width>1</width>
    </addrmode>
    
    <addrmode>
    	<name>Relative 16bit</name>
    	<altname>Wide relative</altname>
        <desc>relative addressing modes, used in branches; from -32768 to +32767</desc>
        <identifier>relwide</identifier>
    	<class>65k</class>
        <altMode>relquad</altMode>
        <width>2</width>
    </addrmode>
    
    <addrmode>
    	<name>Relative 32bit</name>
    	<altname>Long relative</altname>
        <desc>relative addressing modes, used in branches; from -2^32 to +2^32-1</desc>
        <identifier>rellong</identifier>
    	<class>65k</class>
        <width>4</width>
    </addrmode>
    
    <addrmode>
    	<name>Relative 64bit</name>
    	<altname>Quad relative</altname>
        <desc>relative addressing modes, used in branches; from -2^64 to +2^64-1</desc>
        <identifier>relquad</identifier>
    	<class>65k</class>
        <width>8</width>
    </addrmode>
    
	<!-- ################################# -->
	    
    <addrmode>
    	<name>Relative (BSR)</name>
        <desc>relative addressing modes, used in BSR; from -128 to +127</desc>
        <identifier>relj</identifier>
        <altMode>reljlong</altMode>
        <width>1</width>
    </addrmode>
    
    <addrmode>
    	<name>Relative 16bit (BSR)</name>
    	<altname>Wide relative</altname>
        <desc>relative addressing modes, used in BSR; from -32768 to +32767</desc>
        <identifier>reljwide</identifier>
        <altMode>reljquad</altMode>
    	<class>65k</class>
        <width>2</width>
    </addrmode>
    
    <addrmode>
    	<name>Relative 32bit (BSR)</name>
    	<altname>Long relative</altname>
        <desc>relative addressing modes, used in BSR; from -2^32 to +2^32-1</desc>
        <identifier>reljlong</identifier>
    	<class>65k</class>
        <width>4</width>
    </addrmode>
    
    <addrmode>
    	<name>Relative 64bit (BSR)</name>
    	<altname>Quad relative</altname>
        <desc>relative addressing modes, used in BSR; from -2^64 to +2^64-1</desc>
        <identifier>reljquad</identifier>
    	<class>65k</class>
        <width>8</width>
    </addrmode>
    
	<!-- ################################# -->
	    
    <addrmode>
    	<name>Prefix</name>
        <desc>n/a</desc>
        <identifier>prefix</identifier>
    	<class>65k</class>
        <width>0</width>
    </addrmode>
    
	<!-- ################################# -->
	
    <prefix>
    	<name>EXT</name>
    	<value>0x0f</value>
    	<page>EXT</page>
    </prefix>
    
    <prefix>
    	<name>SYS</name>
    	<value>0x2f</value>
    	<!-- page>SYS</page -->
    </prefix>
    
    <prefix>
    	<name>QUICK</name>
    	<value>0x4f</value>
    	<!-- page>QUICK</page -->
    </prefix>
    
    <prefix>
    	<name>reserved prefix</name>
    	<value>0x6f</value>
    </prefix>
    
    <prefix>
    	<name>reserved prefix</name>
    	<value>0x8f</value>
    </prefix>
    
    <prefix>
    	<name>reserved prefix</name>
    	<value>0xaf</value>
    </prefix>
    
    <prefix>
    	<name>reserved prefix</name>
    	<value>0xcf</value>
    </prefix>
    
    <prefix>
    	<name>reserved prefix</name>
    	<value>0xef</value>
    </prefix>
    
    <prefix>
    	<name>prefix1</name>
    	<value>0x03</value>
    	<bits>
	    	<name>Addressing modes</name>
	    	<mask>0x04</mask>
    	    <desc>The AM bit allows to extend the addressing modes to larger sizes. The zeropage addressing modes become 32-bit addressing modes, while the 16-bit addressing modes become 64-bit addressing modes</desc>
        	<id>AM</id>
	        <value>
    	    	<value>0</value>
        		<desc>normal addressing modes (8 / 16 bit)</desc>
	        </value>
    	    <value>
        		<value>1</value>
        		<desc>extended addressing modes (32 / 64 bit)</desc>
        	</value>
    	</bits>
    	<bits>
	    	<name>Register and operation size</name>
	    	<mask>0x30</mask>
    	    <desc>These bits determine the size of the operation, 8, 16, 32 or 64 bit width.</desc>
        	<id>RS</id>
	        <value>
    	    	<value>00</value>
        		<desc>8 bit register</desc>
	        </value>
    	    <value>
        		<value>01</value>
        		<desc>16 bit register</desc>
	        	<syntaxval>W</syntaxval>
    	    </value>
        	<value>
        		<value>10</value>
	        	<desc>32 bit register</desc>
    	    	<syntaxval>L</syntaxval>
        	</value>
	        <value>
    	    	<value>11</value>
        		<desc>64 bit register</desc>
        		<syntaxval>Q</syntaxval>
        	</value>
    	</bits>
    	<bits>
	    	<name>Offset register</name>
	    	<mask>0xc0</mask>
    	    <desc>Allows to add either the stack pointer, program counter, or the base register to an address.
        		For indirect addressing modes, the offset is added to the address of the indirect pointer, not the pointer value.
        		I.e. for &lt;code&gt;LDA (zp),y&lt;/code&gt; the offset is added to the operand "zp", not to the value read from there.</desc>
	        <id>OF</id>
    	    <value>
        		<value>00</value>
        		<desc>No offset added to address</desc>
	        </value>
    	    <value>
        		<value>01</value>
        		<desc>Add Program Counter (PC) to address</desc>
	        	<syntaxval>P</syntaxval>
    	    </value>
        	<value>
        		<value>10</value>
	        	<desc>Add Stack Pointer (SP) to address</desc>
    	    	<syntaxval>S</syntaxval>
        	</value>
	        <value>
    	    	<value>11</value>
        		<desc>Add Base Offset Register (BR) to address</desc>
        		<syntaxval>B</syntaxval>
	        </value>
    	</bits>
    </prefix>
    
    <prefix>
    	<name>prefix2</name>
    	<value>0x0b</value>
    	<bits>
	    	<name>Load extension</name>
	    	<mask>0x60</mask>
    	    <desc>Determines how a value read is extended from width determine by RS to full width before it is given to an operation.</desc>
        	<id>LE</id>
	        <value>
    	    	<value>00</value>
        		<desc>Do not extend the value from RS-width.</desc>
	        	<syntaxval>E</syntaxval>
	        </value>
    	    <value>
        		<value>01</value>
        		<desc>Extend with the sign of the value</desc>
	        	<syntaxval>S</syntaxval>
    	    </value>
    	    <value>
        		<value>10</value>
        		<desc>Extend with zero</desc>
	        	<syntaxval>0</syntaxval>
    	    </value>
    	    <value>
        		<value>11</value>
        		<desc>Extend with one</desc>
	        	<syntaxval>1</syntaxval>
    	    </value>
    	</bits>
    	<bits>
	    	<name>User mode selector</name>
	    	<mask>0x80</mask>
    	    <desc>When the UM mode bit is set, the effective address it not computed using the current mode, but the user mode. This bit is ignored in user mode, but in supervisor mode it switches address calculation to user mode. The effective addressthen also points to user mode memory</desc>
        	<id>UM</id>
	        <value>
    	    	<value>0</value>
        		<desc>Current mode environment (user space/hypervisor mode)</desc>
	        </value>
    	    <value>
        		<value>1</value>
        		<desc>User mode environment (i.e. ignored when used in user mode); Stack Pointer for OF=10 is also User Space stack pointer </desc>
	        	<syntaxval>U</syntaxval>
    	    </value>
    	</bits>
    	<bits>
	    	<name>No flags selector</name>
	    	<mask>0x10</mask>
    	    <desc>When this is set, flags are not updated after an operation as is normal done by the 6502.</desc>
        	<id>NF</id>
	        <value>
    	    	<value>0</value>
        		<desc>Flags are updated on each (relevant) operation according to standard 6502 rules</desc>
	        </value>
    	    <value>
        		<value>1</value>
        		<desc>Flags are not updated.</desc>
	         	<syntaxval>N</syntaxval>
    	    </value>
    	</bits>
    </prefix>
        
</cpu>
