<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<cpu>
	<creator>A. Fachat</creator>
	<creationDate>2011-05-14T01:55:04.022+02:00</creationDate>
	<identifier>af65002</identifier>

	<!-- ################################# -->
	<!-- opcode classes, when were they introduced -->

	<features>
		<feature>
			<name>base</name>
		</feature>
		<feature>
			<name>bcd</name>
		</feature>
		<feature>
			<name>ror</name>
		</feature>
		<feature>
			<name>undoc</name>
		</feature>
		<feature>
			<name>cmos</name>
		</feature>
		<feature>
			<name>cmos_ind</name>
		</feature>
		<feature>
			<name>cmos_indz</name>
		</feature>
		<feature>
			<name>rcmos</name>
		</feature>
		<feature>
			<name>rcmos_bbx</name>
		</feature>
		<feature>
			<name>816ce02</name>
		</feature>
		<feature>
			<name>816</name>
		</feature>
		<feature>
			<name>65k</name>
		</feature>
		<feature>
			<name>65k10</name>
		</feature>
		<feature>
			<name>ce02</name>
		</feature>
	</features>

	<classes>
		<class>
			<name>nmos_bcd_noror</name>
			<feature>base</feature>
			<feature>bcd</feature>
			<doc>
				<p>
					The original 6502 with the ROR-bug, and with BCD codes.
				</p>
			</doc>
		</class>
		<class>
			<name>nmos_nobcd</name>
			<feature>base</feature>
			<feature>ror</feature>
			<doc>
				<p>
					The original 6502 without BCD routines (fixed ROR)
				</p>
			</doc>
		</class>
		<class>
			<name>nmos</name>
			<feature>base</feature>
			<feature>ror</feature>
			<feature>bcd</feature>
			<doc>
				<p>
					The original 6502 with the ROR-bug fixed, and with BCD opcodes
				</p>
			</doc>
		</class>
		<class>
			<name>nmosext</name>
			<includes>nmos</includes>
			<feature>undoc</feature>
			<doc>
				<p>
					The original 6502 with ROR and BCD opcodes, and also with the &quot;undocumented&quot; opcodes.
				</p>
			</doc>
		</class>
		<class>
			<name>cmos</name>
			<includes>nmos</includes>
			<feature>cmos</feature>
			<feature>cmos_ind</feature>
			<!-- prio>1</prio -->
			<doc>
				<p>
					This class is for those opcodes that have been introduced with
					the CMOS
					version
					of the 6502, the 65C02.
					Note this
					does not include
					the extended bit set and clear opcodes of
					the Rockwell variant.
				</p>
			</doc>
		</class>
		<class>
			<name>rcmos</name>
			<includes>cmos</includes>
			<feature>rcmos</feature>
			<feature>rcmos_bbx</feature>
			<doc>
				<p>
					This class is for the extended bit set and clear opcodes of
					the Rockwell variant.
				</p>
			</doc>
		</class>
		<class>
			<name>65816</name>
			<includes>cmos</includes>
			<feature>816</feature>
			<feature>816ce02</feature>
			<doc>
				<p>
					This class contains the new opcodes and opcode extensions of the
					WDC65816. 
				</p>
				<p>
					For more details on the 65816 see the <a href="http://6502.org/tutorials/65c816opcodes.html">65816 tutorial</a>
					on 6502.org.
				</p>
			</doc>
		</class>
		<class>
			<name>65k</name>
			<!-- prio>2</prio -->
			<includes>nmos</includes>
			<feature>cmos</feature>
			<feature>rcmos</feature>
			<feature>cmos_indz</feature>
			<feature>65k</feature>
			<doc>
				<p>
					This class contains the new opcodes and opcode extensions of the
					af65002 compared to the 65C02.
				</p>
			</doc>
		</class>
		<!-- class> <name>65k10</name> <includes>65k</includes> <doc> <p> This class contains the new opcodes and opcode extensions 
			of the af65010 compared to the af65002. </p> </doc> </class -->
		<class>
			<name>65ce02</name>
			<!-- prio>3</prio -->
			<includes>nmos</includes>
			<feature>cmos</feature>
			<feature>cmos_indz</feature>
			<feature>rcmos</feature>
			<feature>rcmos_bbx</feature>
			<feature>ce02</feature>
			<feature>816ce02</feature>
			<doc>
				<p>
					The 65ce02 opcodes, which are an extension to the Rockwell CMOS opcodes.
					But also the "(zp)" indirect addressing
					mode has been replaced with the
					"(zp),z" adressing mode.
				</p>
			</doc>
		</class>
	</classes>

	<!-- ################################# -->
	<!-- actual opcode definitions -->

	<operations>
		<operation>
			<name>BRK</name>
			<desc>Starts the break routine.</desc>
			<prefixBits>RS</prefixBits>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0x00</opcode>
			</opcodes>
			<doc>
				<p>
					The BRK opcode is used to jump to the BRK vector. It pushes the
					return address and the status on the stack, then
					reads the BRK
					vector
					(doubling as IRQ vector) and jumps there.
				</p>
				<p>
					Please note that the address put on the stack is the address of
					the next
					instruction. And the BRK opcode is using
					the immediate
					addressing
					mode
					(although the MOS manual does not state it). Thus the
					address put on the
					stack is two
					bytes behind the address of the BRK!
				</p>
				<p>
					Before storing the status on the stack, the opcode sets the
					I-flag to
					avoid recursive calling of the interrupt
					routine.
				</p>
				<p>
					When storing the status on the stack, the B-flag is set to
					indicate
					that
					the shared IRQ/BRK vector has been called
					from a BRK
					and not an IRQ.
				</p>
				<pre>
					Stack(SP--) &amp;lt;= &gt; NextPC
					Stack(SP--) &amp;lt;= &amp;lt;
					NextPC
					Stack(SP--) &amp;lt;= Status | B | I
					PC
					&amp;lt;= ($FFFE)
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					On the 65k, the RS prefix determines the size of the immediate
					operand,
					so that the return address that is pushed
					onto the stack
					depends on
					it.
				</p>
				<p>
					As opposed to the IRQ, the BRK opcode stays in the user resp.
					hypervisor mode
					where it is executed.
				</p>
				<p>
					In hypervisor mode, once the processor configuration register for
					abort vector table is set,
					the BRK vector is
					taken from the abort
					vector table. For details see
					the interrupt handling
					description.
				</p>
				<p>
					In user mode the BRK always uses the standard two-byte $FFFE IRQ
					vector, sign-expanded to
					full address length.
				</p>
			</doc>
		</operation>

		<!-- ################################# -->

		<operation>
			<name>BPL</name>
			<desc>Branch on plus - take branch when N flag is cleared</desc>
			<prefixBits>RS</prefixBits>
			<opcodes>
				<addressingMode>rel</addressingMode>
				<opcode>0x10</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>relw</addressingMode>
				<opcode>0x13</opcode>
				<feature>ce02</feature>
			</opcodes>
			<doc>
				<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					negative status flag is clear.
					The parameter is a
					signed 8-bit value, i.e. jump distances
					can be from
					-128 to +127.
				</p>
				<pre>
					PC &amp;lt;= NextPC + Operand when N=1 else NextPC
				</pre>
			</doc>
			<doc mode="65k">
				<p>The RS prefix determines the width of the parameter, the default
					is 8-bit.
					With a 16-bit parameter the jump
					distances can be from
					-32768 to +32767
					and so on.
				</p>
			</doc>
		</operation>

		<operation>
			<name>BMI</name>
			<desc>Branch on minus - take branch when N flag is set</desc>
			<prefixBits>RS</prefixBits>
			<opcodes>
				<addressingMode>rel</addressingMode>
				<opcode>0x30</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>relw</addressingMode>
				<opcode>0x33</opcode>
				<feature>ce02</feature>
			</opcodes>
			<doc>
				<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					negative status flag is set.
					The parameter is a
					signed 8-bit value, i.e. jump distances can
					be from
					-128 to +127.
				</p>
				<pre>
					PC &amp;lt;= NextPC + Operand when N=1 else NextPC
				</pre>
			</doc>
			<doc mode="65k">
				<p>The RS prefix determines the width of the parameter, the default
					is 8-bit.
					With a 16-bit parameter the jump
					distances can be from
					-32768 to +32767
					and so on.
				</p>
			</doc>
		</operation>

		<operation>
			<name>BVC</name>
			<desc>Branch on overflow clear - take branch when V flag is cleared
			</desc>
			<prefixBits>RS</prefixBits>
			<opcodes>
				<addressingMode>rel</addressingMode>
				<opcode>0x50</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>relw</addressingMode>
				<opcode>0x53</opcode>
				<feature>ce02</feature>
			</opcodes>
			<doc>
				<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					overflow status flag is clear.
					The parameter is a
					signed 8-bit value, i.e. jump distances
					can be from
					-128 to +127.
				</p>
				<pre>
					PC &amp;lt;= NextPC + Operand when N=1 else NextPC
				</pre>
			</doc>
			<doc mode="65k">
				<p>The RS prefix determines the width of the parameter, the default
					is 8-bit.
					With a 16-bit parameter the jump
					distances can be from
					-32768 to +32767
					and so on.
				</p>
			</doc>
		</operation>

		<operation>
			<name>BVS</name>
			<desc>Branch on overflow set - take branch when V flag is set</desc>
			<prefixBits>RS</prefixBits>
			<opcodes>
				<addressingMode>rel</addressingMode>
				<opcode>0x70</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>relw</addressingMode>
				<opcode>0x73</opcode>
				<feature>ce02</feature>
			</opcodes>
			<doc>
				<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					overflow status flag is set.
					The parameter is a
					signed 8-bit value, i.e. jump distances can
					be from
					-128 to +127.
				</p>
				<pre>
					PC &amp;lt;= NextPC + Operand when N=1 else NextPC
				</pre>
			</doc>
			<doc mode="65k">
				<p>The RS prefix determines the width of the parameter, the default
					is 8-bit.
					With a 16-bit parameter the jump
					distances can be from
					-32768 to +32767
					and so on.
				</p>
			</doc>
		</operation>

		<operation>
			<name>BCC</name>
			<synonym>BLT</synonym>
			<desc>Branch on carry clear - take branch when C flag is cleared
			</desc>
			<prefixBits>RS</prefixBits>
			<opcodes>
				<addressingMode>rel</addressingMode>
				<opcode>0x90</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>relw</addressingMode>
				<opcode>0x93</opcode>
				<feature>ce02</feature>
			</opcodes>
			<doc>
				<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					carry status flag is clear. After a CMP this is a
					synonym for "less
					than".
					The parameter is
					a signed 8-bit value, i.e.
					jump distances can be from
					-128 to +127.
				</p>
				<pre>
					PC &amp;lt;= NextPC + Operand when N=1 else NextPC
				</pre>
			</doc>
			<doc mode="65k">
				<p>The RS prefix determines the width of the parameter, the default
					is 8-bit.
					With a 16-bit parameter the jump
					distances can be from
					-32768 to +32767
					and so on.
				</p>
			</doc>
		</operation>

		<operation>
			<name>BCS</name>
			<synonym>BGE</synonym>
			<desc>Branch on carry set - take branch when C flag is set</desc>
			<prefixBits>RS</prefixBits>
			<opcodes>
				<addressingMode>rel</addressingMode>
				<opcode>0xB0</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>relw</addressingMode>
				<opcode>0xb3</opcode>
				<feature>ce02</feature>
			</opcodes>
			<doc>
				<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					carry status flag is set. After a CMP this is a
					synonym for "greater or
					equal".
					The
					parameter is a signed 8-bit
					value, i.e. jump distances can be from
					-128 to +127.
				</p>
				<pre>
					PC &amp;lt;= NextPC + Operand when N=1 else NextPC
				</pre>
			</doc>
			<doc mode="65k">
				<p>The RS prefix determines the width of the parameter, the default
					is 8-bit.
					With a 16-bit parameter the jump
					distances can be from
					-32768 to +32767
					and so on.
				</p>
			</doc>
		</operation>

		<operation>
			<name>BGT</name>
			<synonym>(SEQ BCS)</synonym>
			<desc>Branch if greater - take branch when C flag is set but Z flag
				is
				clear
			</desc>
			<feature>65k</feature>
			<doc>
				<p>
					Execute a branch given the
					condition that the
					carry status flag is set and the zero status flag
					is not set.
					Synonym to "SEQ BCS", i.e. branch on carry set, skipped if zero is set. 
				</p>
			</doc>
		</operation>

		<operation>
			<name>BLE</name>
			<desc>Branch if less or equal - take branch when C flag is clear or Z
				flag is set
			</desc>
			<prefixBits>RS</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>rel</addressingMode>
				<opcode>0x90</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					carry status flag is clear or the zero status flag
					is set.
					The parameter is a signed 8-bit
					value, i.e. jump distances
					can be from
					-128 to +127.
				</p>
				<pre>
					PC &amp;lt;= NextPC + Operand when (N=1 and Z=0) else NextPC
				</pre>
			</doc>
			<doc mode="65k">
				<p>The RS prefix determines the width of the parameter, the default
					is 8-bit.
					With a 16-bit parameter the jump
					distances can be from
					-32768 to +32767
					and so on.
				</p>
			</doc>
		</operation>

		<operation>
			<name>BNE</name>
			<desc>Branch on not equal - take branch when Z flag is cleared</desc>
			<prefixBits>RS</prefixBits>
			<opcodes>
				<addressingMode>rel</addressingMode>
				<opcode>0xD0</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>relw</addressingMode>
				<opcode>0xd3</opcode>
				<feature>ce02</feature>
			</opcodes>
			<doc>
				<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					zero status flag is clear.
					The parameter is a
					signed 8-bit value, i.e. jump distances can
					be from
					-128 to +127.
				</p>
				<pre>
					PC &amp;lt;= NextPC + Operand when N=1 else NextPC
				</pre>
			</doc>
			<doc mode="65k">
				<p>The RS prefix determines the width of the parameter, the default
					is 8-bit.
					With a 16-bit parameter the jump
					distances can be from
					-32768 to +32767
					and so on.
				</p>
			</doc>
		</operation>

		<operation>
			<name>BEQ</name>
			<desc>Branch on equal - take branch when Z flag is set</desc>
			<prefixBits>RS</prefixBits>
			<opcodes>
				<addressingMode>rel</addressingMode>
				<opcode>0xf0</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>relw</addressingMode>
				<opcode>0xf3</opcode>
				<feature>ce02</feature>
			</opcodes>
			<doc>
				<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					zero status flag is set.
					The parameter is a signed
					8-bit value, i.e. jump distances can be
					from
					-128 to +127.
				</p>
				<pre>
					PC &amp;lt;= NextPC + Operand when N=1 else NextPC
				</pre>
			</doc>
			<doc mode="65k">
				<p>The RS prefix determines the width of the parameter, the default
					is 8-bit.
					With a 16-bit parameter the jump
					distances can be from
					-32768 to +32767
					and so on.
				</p>
			</doc>
		</operation>

		<operation>
			<name>BRA</name>
			<desc>Branch always - branch independent from any flags</desc>
			<prefixBits>RS</prefixBits>
			<synonym>BRU</synonym>
			<feature>cmos</feature>
			<opcodes>
				<addressingMode>rel</addressingMode>
				<opcode>0x80</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>relw</addressingMode>
				<opcode>0x83</opcode>
				<feature>ce02</feature>
			</opcodes>
			<doc>
				<p>
					Branch (always) to the address given by adding the parameter to
					the
					address of the
					next operation (after the branch
					opcode).
					The
					parameter is a signed 8-bit value, i.e. jump distances can be from
					-128 to +127.
				</p>
				<pre>
					PC &amp;lt;= NextPC + Operand
				</pre>
			</doc>
			<doc mode="65k">
				<p>The RS prefix determines the width of the parameter, the default
					is 8-bit.
					With a 16-bit parameter the jump
					distances can be from
					-32768 to +32767
					and so on.
				</p>
			</doc>
		</operation>

		<operation>
			<name>BRL</name>
			<desc>Branch always - branch independent from any flags</desc>
			<feature>816</feature>
			<opcodes>
				<addressingMode>relw</addressingMode>
				<opcode>0x82</opcode>
			</opcodes>
		</operation>

		<operation>
			<name>BEV</name>
			<desc>Branch on even</desc>
			<prefixBits>RS</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>rel</addressingMode>
				<opcode>0x10</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					if the odd
					status flag is
					set.
					The parameter is a signed 8-bit value, i.e. jump
					distances can be from
					-128 to +127.
				</p>
				<pre>
					PC &amp;lt;= NextPC + Operand when O=0 else NextPC
				</pre>
			</doc>
			<doc mode="65k">
				<p>The RS prefix determines the width of the parameter, the default
					is 8-bit.
					With a 16-bit parameter the jump
					distances can be from
					-32768 to +32767
					and so on.
				</p>
			</doc>
		</operation>

		<operation>
			<name>BOD</name>
			<desc>Branch on odd</desc>
			<prefixBits>RS</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>rel</addressingMode>
				<opcode>0x30</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					if the odd
					status flag is
					set.
					The parameter is a signed 8-bit value, i.e. jump
					distances can be from
					-128 to +127.
				</p>
				<pre>
					PC &amp;lt;= NextPC + Operand when O=1 else NextPC
				</pre>
			</doc>
			<doc mode="65k">
				<p>The RS prefix determines the width of the parameter, the default
					is 8-bit.
					With a 16-bit parameter the jump
					distances can be from
					-32768 to +32767
					and so on.
				</p>
			</doc>
		</operation>

		<operation>
			<name>BLTS</name>
			<desc>Branch on signed less than</desc>
			<prefixBits>RS</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>rel</addressingMode>
				<opcode>0x50</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					if the
					signed greater
					status or equal flag is not set.
					The parameter is a
					signed 8-bit value, i.e. jump distances can
					be from
					-128 to +127.
				</p>
				<pre>
					PC &amp;lt;= NextPC + Operand when G=0 else NextPC
				</pre>
			</doc>
			<doc mode="65k">
				<p>The RS prefix determines the width of the parameter, the default
					is 8-bit.
					With a 16-bit parameter the jump
					distances can be from
					-32768 to +32767
					and so on.
				</p>
			</doc>
		</operation>

		<operation>
			<name>BGES</name>
			<desc>Branch on signed greater or equal than</desc>
			<prefixBits>RS</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>rel</addressingMode>
				<opcode>0x70</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					if the
					signed greater or
					equal status flag G is set.
					The parameter is a
					signed 8-bit value, i.e. jump distances can be
					from
					-128 to +127.
				</p>
				<pre>
					PC &amp;lt;= NextPC + Operand when G=1 else NextPC
				</pre>
			</doc>
			<doc mode="65k">
				<p>The RS prefix determines the width of the parameter, the default
					is 8-bit.
					With a 16-bit parameter the jump
					distances can be from
					-32768 to +32767
					and so on.
				</p>
			</doc>
		</operation>

		<operation>
			<name>BLES</name>
			<desc>Branch if less or equal - take branch when signed greater or
				equal flag G is clear or Z flag is set
			</desc>
			<prefixBits>RS</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>rel</addressingMode>
				<opcode>0xD0</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					signed greater status flag is clear or the zero
					status flag is set.
					The parameter is a
					signed 8-bit value, i.e. jump
					distances can be from
					-128 to +127.
				</p>
				<pre>
					PC &amp;lt;= NextPC + Operand when (G=0 or Z=1) else NextPC
				</pre>
			</doc>
			<doc mode="65k">
				<p>The RS prefix determines the width of the parameter, the default
					is 8-bit.
					With a 16-bit parameter the jump
					distances can be from
					-32768 to +32767
					and so on.
				</p>
			</doc>
		</operation>

		<operation>
			<name>BGTS</name>
			<synonym>(SEQ BGES)</synonym>
			<desc>Branch if greater - take branch when signed greater or equal G
				flag is set but Z flag is clear
			</desc>
			<feature>65k</feature>
			<doc>
				<p>
					Execute a branch given the
					condition that the
					signed greater status flag is set and the zero
					status flag is not set.
					Synonym to "SEQ BGES", i.e. branch on signed greater set, skipped if zero is set. 
				</p>
			</doc>
		</operation>

		<!-- ################################# -->

		<operation>
			<name>SPL</name>
			<desc>Skip on plus - skip next opcode when N flag is cleared</desc>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x1f</opcode>
			</opcodes>
			<doc>
				<p>
					Skip the
					next operation (after the skip opcode)
					given the
					condition that
					the
					negative status flag is clear.
				</p>
			</doc>
		</operation>

		<operation>
			<name>SMI</name>
			<desc>Skip on minus - skip next opcode when N flag is set</desc>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x3f</opcode>
			</opcodes>
			<doc>
				<p>
					Skip the
					next operation (after the skip opcode)
					given the
					condition that
					the
					negative status flag is set.
				</p>
			</doc>
		</operation>

		<operation>
			<name>SVC</name>
			<desc>Skip on overflow clear - skip next opcode when V flag is cleared</desc>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x5f</opcode>
			</opcodes>
			<doc>
				<p>
					Skip the
					next operation (after the skip opcode)
					given the
					condition that
					the
					overflow status flag is cleared.
				</p>
			</doc>
		</operation>

		<operation>
			<name>SVS</name>
			<desc>Skip on overflow set - skip next opcode when V flag is set</desc>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x7f</opcode>
			</opcodes>
			<doc>
				<p>
					Skip the
					next operation (after the skip opcode)
					given the
					condition that
					the
					overflow status flag is set.
				</p>
			</doc>
		</operation>

		<operation>
			<name>SCC</name>
			<desc>Skip on carry clear - skip next opcode when C flag is cleared</desc>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x9f</opcode>
			</opcodes>
			<doc>
				<p>
					Skip the
					next operation (after the skip opcode)
					given the
					condition that
					the
					carry status flag is cleared.
				</p>
			</doc>
		</operation>

		<operation>
			<name>SCS</name>
			<synonym>SGE</synonym>
			<desc>Skip on carry set - skip next opcode when C flag is set</desc>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xbf</opcode>
			</opcodes>
			<doc>
				<p>
					Skip the
					next operation (after the skip opcode)
					given the
					condition that
					the
					carry status flag is set.
				</p>
			</doc>
		</operation>

		<operation>
			<name>SNE</name>
			<desc>Skip on not equal - skip next opcode when Z flag is cleared</desc>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xdf</opcode>
			</opcodes>
			<doc>
				<p>
					Skip the
					next operation (after the skip opcode)
					given the
					condition that
					the
					zero status flag is cleared.
				</p>
			</doc>
		</operation>

		<operation>
			<name>SEQ</name>
			<desc>Skip on equal - skip next opcode when Z flag is set</desc>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xff</opcode>
			</opcodes>
			<doc>
				<p>
					Skip the
					next operation (after the skip opcode)
					given the
					condition that
					the
					zero status flag is set.
				</p>
			</doc>
		</operation>


		<!-- ################################# -->

		<operation>
			<name>JMP</name>
			<desc>Jump to new code address</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>LE</prefixBits>
			<default-le>sign</default-le>
			<opcodes>
				<addressingMode>absindquad</addressingMode>
				<opcode>0x07</opcode>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>absxindquad</addressingMode>
				<opcode>0x27</opcode>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>addr</addressingMode>
				<opcode>0x4c</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>addrbank</addressingMode>
				<opcode>0x5c</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absind</addressingMode>
				<opcode>0x6c</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absxind</addressingMode>
				<opcode>0x7c</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0x4c</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>addrlong</addressingMode>
				<opcode>0x6c</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<doc>
				<p>
					Jump to the address given by the operand (as computed depending
					on the
					respective addressing mode).
				</p>
				<pre>
					PC &amp;lt;= Operand
				</pre>
			</doc>
			<doc mode="65k">
				<p>The AM, OF, LE and UM prefixes are evaluated by the addressing
					modes.
					Note that if UM is set, then the processor
					jumps into user
					mode.
				<pre>
					Status |= U when UM is set
				</pre>
				</p>
				<p>
					If the operand is not as wide as required for an address, it is
					sign-extended.
				</p>
			</doc>
		</operation>

		<operation>
			<name>JML</name>
			<desc>Jump to new code address (24 bit)</desc>
			<feature>816</feature>
			<opcodes>
				<addressingMode>absindbank</addressingMode>
				<opcode>0xdc</opcode>
			</opcodes>
			<doc>
				<p>
					Jump to the address given by the operand (as computed depending
					on the
					respective addressing mode).
				</p>
				<pre>
					PC &amp;lt;= Operand
				</pre>
			</doc>
		</operation>

		<operation>
			<name>JSR</name>
			<desc>Jump subroutine - jump to a new code location, save return
				address on stack for RTS
			</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<default-le>sign</default-le>
			<opcodes>
				<addressingMode>addr</addressingMode>
				<opcode>0x20</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>addrlong</addressingMode>
				<opcode>0x5c</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>absind</addressingMode>
				<opcode>0xdc</opcode>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absind</addressingMode>
				<opcode>0x22</opcode>
				<feature>ce02</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absxind</addressingMode>
				<opcode>0xfc</opcode>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absxind</addressingMode>
				<opcode>0xfc</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absxind</addressingMode>
				<opcode>0x23</opcode>
				<feature>ce02</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absindquad</addressingMode>
				<opcode>0x87</opcode>
				<feature>65k</feature>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>absxindquad</addressingMode>
				<opcode>0xa7</opcode>
				<feature>65k</feature>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0x20</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Jump to the address given by the operand (as computed depending
					on the
					respective addressing mode) and
					store the
					return address (-1)
					on the stack to prepare for the RTS opcode
				</p>
				<pre>
					Stack(SP--) &amp;lt;= &gt; NextPC-1
					Stack(SP--) &amp;lt;=
					&amp;lt; NextPC-1
					PC &amp;lt;= Operand
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF, and LE prefixes are evaluated by the addressing
					modes.
					Note that the UM prefix is not supported.
				</p>
				<p>
					If the operand is not wide enough as required for an address, it
					is
					sign-extended.
				</p>
				<p>
					The RS prefix determines the width of the return address put on
					the
					stack. Note that the
					BYTE width prefix denotes
					the natural width
					of the processor
					(respectively its current mode).
				</p>
				<p>
					The stack pointer used is the stack pointer of the current mode.
				</p>
			</doc>
		</operation>

		<operation>
			<name>JSL</name>
			<desc>Jump subroutine long - jump to a new code location, save return
				address on stack for RTS (24 bit)
			</desc>
			<feature>816</feature>
			<opcodes>
				<addressingMode>addrbank</addressingMode>
				<opcode>0x22</opcode>
			</opcodes>
			<doc>
				<p>
					Jump to the address given by the operand (as computed depending
					on the
					respective addressing mode) and
					store first the program bank register, then the
					return address (-1)
					on the stack to prepare for the RTL opcode
				</p>
				<pre>
					Stack(SP--) &amp;lt;= &gt; PBR
					Stack(SP--) &amp;lt;= &gt; NextPC-1
					Stack(SP--) &amp;lt;=
					&amp;lt; NextPC-1
					PC &amp;lt;= Operand
				</pre>
			</doc>
		</operation>

		<operation>
			<name>BSR</name>
			<desc>Branch subroutine - similar to JSR, but use relative addressing
				similar to branch opcodes
			</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>RS</prefixBits>
			<opcodes>
				<addressingMode>relj</addressingMode>
				<opcode>0x82</opcode>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>reljwide</addressingMode>
				<opcode>0x44</opcode>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>relw</addressingMode>
				<opcode>0x63</opcode>
				<feature>ce02</feature>
			</opcodes>
			<doc>
				<p>
					Branch to the address given by the operand as computed similar to
					the
					branch opcodes.
					Store the return address (-1)
					on the stack to
					prepare for the RTS
					opcode.
				</p>
				<pre>
					Stack(SP--) &amp;lt;= &gt; NextPC-1
					Stack(SP--) &amp;lt;=
					&amp;lt; NextPC-1
					PC &amp;lt;= NextPC + Operand
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The AM prefix is evaluated by the relative addressing modes. Note
					that
					the RS prefix is
					used to determine the return
					address size on
					the stack, so it cannot be
					used as parameter width
					selector. Thus
					there are two opcodes to define 8-bit
					or 16-bit parameter
					width,
					using the AM
					prefix to make that 32- or 64-bit respectively.
				</p>
				<p>
					Note that the UM prefix is not supported.
				</p>
				<p>
					If the operand is not wide enough as required for an address, it
					is
					sign-extended.
				</p>
				<p>
					The RS prefix determines the width of the return address put on
					the
					stack. Note that the
					BYTE width prefix denotes
					the natural width
					of the processor
					(respectively its current mode). This
					is the
					default.
				</p>
				<p>
					The stack pointer used is the stack pointer of the current mode.
				</p>
			</doc>
		</operation>

		<operation>
			<name>RTS</name>
			<desc>Return from subroutine - read return address from stack</desc>
			<prefixBits>RS</prefixBits>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x60</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0x62</opcode>
				<feature>ce02</feature>
			</opcodes>
			<doc>
				<p>
					Take the return address from the stack, increment it by one, and
					continue at the new address.
				</p>
				<pre>
					Tmp(0-7) &amp;lt;= Stack(++SP)
					Tmp(8-15) &amp;lt;= Stack(++SP)
					PC &amp;lt;= Tmp + 1;
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The RS prefix determines the width of the return address read
					from the
					stack. Note that the
					BYTE width prefix
					denotes the natural
					width of the processor
					(respectively its current mode). This
					is the
					default.
				</p>
				<p>
					If the operand is not wide enough as required for an address, it
					is
					extended with the
					rest of the current PC. This
					is to support
					running "narrow" code within
					a e.g. a 64k window
					in a wide system.
				</p>
				<p>
					The stack pointer used is the stack pointer of the current mode.
				</p>
			</doc>
			<doc mode="ce02">
				<p>???</p>
			</doc>
		</operation>

		<operation>
			<name>RTI</name>
			<desc>Return from interrupt</desc>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x40</opcode>
			</opcodes>
			<doc>
				<p>
					Returns from an interrupt or a BRK opcode handling. It first
					pulls the
					status register from the stack, then
					takes
					the return
					address from the stack, increment it by one, and
					continue at the new
					address.
				</p>
				<pre>
					Status &amp;lt;= Stack(++SP) -- bit 5=1
					Tmp(0-7) &amp;lt;=
					Stack(++SP)
					Tmp(8-15) &amp;lt;= Stack(++SP)
					PC &amp;lt;=
					Tmp;
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The RTI prefix first reads the status from the current stack. If
					the
					"Not extended" flag is set
					(bit 5 is always 1
					in the 6502 status
					register, so here it is used as
					"not extended" flag), then
					the normal
					handling as described above
					takes place.
				</p>
				<p>
					If the "not extended" flag is clear, i.e. an extended stack frame
					is
					used:
				</p>
				<pre>
					Status &amp;lt;= Stack(++SP) -- bit 5=0
					ExtStatus &amp;lt;=
					Stack(++SP)
					Tmp(0-7) &amp;lt;= Stack(++SP)
					Tmp(8-15)
					&amp;lt;=
					Stack(++SP)
					...
					PC &amp;lt;= Tmp;
				</pre>
				<p>
					Here the extended status byte is pulled from the stack after the
					standard status. In this extended status
					there are
					two bit that
					determine the size of the return address
					following
					on the stack.
					So
					the return address can be 16-, 32- or
					64-bit. Note that the "00"
					designation (otherwise used for BYTE width)
					maps to the natural
					address width of the
					processor executing the code.
				</p>
				<p>
					Also the user mode bit is stored in the extended stack frame. If
					the
					user mode bit is the same as the
					current mode,
					the execution
					continues in that mode.
					If the RTI code is executed in the
					supervisor mode, and the user mode
					bit is set,
					then the
					return
					address is interpreted as user mode address, and the execution
					continues in the
					user mode. If RTI is
					executed in user mode, and the
					user mode bit is
					clear (i.e. hypervisor mode),
					and ABORT sequence is
					triggered.
				</p>
				<p>
					Note that the "natural" address width is taken from the target
					environment in case the process jumps
					from
					hypervisor to user mode.
				</p>
				<p>
					If the operand is not wide enough as required for an address, it
					is
					sign-extended.
				</p>
			</doc>
		</operation>

		<!-- ################################# -->

		<operation>
			<name>TSB</name>
			<desc>Test and Set Bit - AND the memory location with the
				accumulator,
				and set the Z flag from the result, then SET all
				bits in
				the
				memory location that are set in the accumulator.
			</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<feature>cmos</feature>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x04</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0x0c</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0x0c</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Take the operand, and AND it with the accumulator and evaluate
					the
					Z-flag. Then OR the operand with the accumulator
					and store the
					value back.
				</p>
				<p>
					The use case for this opcode is the synchronization between
					processes
					and implements a variant of the
					"test-and-set"
					primitive.
					Thus this is a Read-Modify-Write operation and will trigger a
					Memory-Lock between the read
					and write
					to make that operation
					atomic.
				</p>
				<pre>
					Tmp &amp;lt;= operand &amp;amp; AC
					Z &amp;lt;= Z(Tmp)
					operand
					&amp;lt; operand | AC
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					The
					UM prefix determines whether the
					operand
					resides in user space or
					not.
				</p>
				<p>
					The NF prefix allows to implement a read-modify-write OR of a
					memory
					location (without the usual or/store
					sequence)
					- without
					setting a flag though.
				</p>
			</doc>
		</operation>

		<operation>
			<name>TRB</name>
			<desc>Test and Reset Bit - AND the memory location with the
				accumulator, and set the Z flag from the result, then
				CLEAR all bits
				in the
				memory location that are set in the accumulator.
			</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<feature>cmos</feature>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x14</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0x1c</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0x1c</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Take the operand, and AND it with the accumulator and evaluate
					the
					Z-flag. Then clear all bits in the operand
					that
					are set in the
					accumulator (basically AND with the inverse of the
					accumulator),
					and
					store the value back.
				</p>
				<p>
					The use case for this opcode is the synchronization between
					processes
					and implements a variant of the
					"test-and-clear"
					primitive. Thus this is a Read-Modify-Write operation and will
					trigger a
					Memory-Lock between the read
					and write
					to make that
					operation atomic.
				</p>
				<pre>
					Tmp &amp;lt;= operand &amp;amp; AC
					Z &amp;lt;= Z(Tmp)
					operand
					&amp;lt; operand | AC
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					The
					UM prefix determines whether the
					operand
					resides in user space or
					not.
				</p>
				<p>
					The NF prefix allows to implement a read-modify-write AND of a
					memory
					location (without the usual and/store
					sequence) - without
					setting a flag though.
				</p>
			</doc>
		</operation>

		<operation>
			<name>BIT</name>
			<desc>Bitwise test with accumulator - AND the memory location with
				the
				accumulator, and set N (=bit 7), V (=bit 7), Z
				(iff all bits
				zero) flags from the result. In case of the accumulator addressing,
				simply
				set the flags from the
				accumulator
			</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x24</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0x2c</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x34</opcode>
				<feature>cmos</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0x3c</opcode>
				<feature>cmos</feature>
			</opcodes>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0x89</opcode>
				<feature>cmos</feature>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0x89</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>A</addressingMode>
				<opcode>0x34</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<doc>
				<p>
					Read the operand and set the N and V flags from the value (from
					the
					highest and next-to-highest bit respectively).
					Then take the
					operand, and AND it with the accumulator and evaluate the
					Z-flag.
				</p>
				<pre>
					N &amp;lt;= Operand(7)
					V &amp;lt;= Operand(6)
					Tmp &amp;lt;=
					Operand &amp;amp; AC
					Z &amp;lt;= Z(Tmp)
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF, LE and RS prefixes are evaluated by the addressing
					modes.
					The UM prefix determines whether the
					operand
					resides in user
					space or not.
				</p>
				<p>
					The NF prefix allows to implement a read-modify-write AND of a
					memory
					location (without the usual and/store
					sequence) - without
					setting a flag though.
				</p>
			</doc>
		</operation>


		<!-- ################################# -->

		<operation>
			<name>LDY</name>
			<desc>Load Y register</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<default-le>zero</default-le>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0xa0</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0xa4</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0xac</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0xb4</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0xbc</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0xa0</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Read the operand and store it in the Y register. Set the flags
					appropriately.
				</p>
				<pre>
					N &amp;lt;= Operand(7)
					Z &amp;lt;= Z(Operand)
					Y &amp;lt;= Operand
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF, LE and RS prefixes are evaluated by the addressing
					modes.
					The UM prefix determines whether the
					operand
					resides in user
					space or not.
				</p>
				<p>
					Note that the default load extension is "zero-extended", to "not
					surprise" programmers.
				</p>
				<p>
					The NF prefix lets the flags unmodified.
				</p>
			</doc>
		</operation>

		<operation>
			<name>LDX</name>
			<desc>Load X register</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<default-le>zero</default-le>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0xa2</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0xa6</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0xae</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpy</addressingMode>
				<opcode>0xb6</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0xbe</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0xad</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Read the operand and store it in the X register. Set the flags
					appropriately.
				</p>
				<pre>
					N &amp;lt;= Operand(7)
					Z &amp;lt;= Z(Operand)
					X &amp;lt;= Operand
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF, LE and RS prefixes are evaluated by the addressing
					modes.
					The UM prefix determines whether the
					operand
					resides in user
					space or not.
				</p>
				<p>
					Note that the default load extension is "zero-extended", to "not
					surprise" programmers.
				</p>
				<p>
					The NF prefix lets the flags unmodified.
				</p>
			</doc>
		</operation>


		<operation>
			<name>LDA</name>
			<desc>Load accumulator</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<default-le>zero</default-le>
			<opcodes>
				<addressingMode>zpy</addressingMode>
				<opcode>0x02</opcode>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absindy</addressingMode>
				<opcode>0x42</opcode>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absindyquad</addressingMode>
				<opcode>0x47</opcode>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>absxind</addressingMode>
				<opcode>0x62</opcode>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absxindquad</addressingMode>
				<opcode>0x67</opcode>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>zpxind</addressingMode>
				<opcode>0xa1</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpxindquad</addressingMode>
				<opcode>0xa3</opcode>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0xa5</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0xa9</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0xad</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindy</addressingMode>
				<opcode>0xb1</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpind</addressingMode>
				<opcode>0xb2</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindz</addressingMode>
				<opcode>0xb2</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindyquad</addressingMode>
				<opcode>0xb3</opcode>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0xb5</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindzquad</addressingMode>
				<opcode>0xb7</opcode>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0xb9</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0xbd</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0xa9</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zpsindy</addressingMode>
				<opcode>0xe2</opcode>
				<feature>ce02</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zps</addressingMode>
				<opcode>0xa3</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zpsindy</addressingMode>
				<opcode>0xb3</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>bank</addressingMode>
				<opcode>0xaf</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>bankx</addressingMode>
				<opcode>0xbf</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absindbank</addressingMode>
				<opcode>0xa7</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absindybank</addressingMode>
				<opcode>0xb7</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zpindbyte</addressingMode>
				<opcode>0x81</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absindbyte</addressingMode>
				<opcode>0x41</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zpindbytequad</addressingMode>
				<opcode>0x82</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absindbytequad</addressingMode>
				<opcode>0x42</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<doc>
				<p>
					Read the operand and store it in the Accumulator. Set the flags
					appropriately.
				</p>
				<pre>
					N &amp;lt;= Operand(7)
					Z &amp;lt;= Z(Operand)
					Y &amp;lt;= Operand
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF, LE and RS prefixes are evaluated by the addressing
					modes.
					The UM prefix determines whether the
					operand
					resides in user
					space or not.
				</p>
				<p>
					Note that the default load extension is "zero-extended", to "not
					surprise" programmers.
				</p>
				<p>
					The NF prefix lets the flags unmodified.
				</p>
			</doc>
		</operation>

		<!-- ################################# -->

		<operation>
			<name>CPY</name>
			<desc>Compare Y register with content of memory location</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>LE</prefixBits>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0xc0</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0xc4</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0xcc</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0xc0</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<doc>
				<p>
					Compare the operand with the Y register and set the flags
					appropriately.
					I.e. substract the operand from Y with an
					implicitly
					set carry in
					binary mode (even if
					decimal mode status bit is set),
					and set the flags from the result.
				</p>
				<pre>
					Tmp, C &amp;lt;= Y - Operand, C=1
					N &amp;lt;= Tmp(7)
					Z &amp;lt;=
					Z(Tmp)
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF, LE and RS prefixes are evaluated by the addressing
					modes.
					UM determines
					whether the operand is in user
					space.
				</p>
				<p>
					Note that the default is to use BYTE-wide operation without load
					extension.
				</p>
			</doc>
		</operation>

		<operation>
			<name>CPX</name>
			<desc>Compare X register with content of memory location</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>LE</prefixBits>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0xe0</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0xe4</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0xec</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0xe0</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Compare the operand with the X register and set the flags
					appropriately.
					I.e. substract the operand from X with an
					implicitly
					set carry in
					binary mode (even if
					decimal mode status bit is set),
					and set the flags from the result.
				</p>
				<pre>
					Tmp, C &amp;lt;= X - Operand, C=1
					N &amp;lt;= Tmp(7)
					Z &amp;lt;=
					Z(Tmp)
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF, LE and RS prefixes are evaluated by the addressing
					modes.
					UM determines
					whether the operand is in user
					space.
				</p>
				<p>
					Note that the default is to use BYTE-wide operation without load
					extension.
				</p>
			</doc>
		</operation>

		<operation>
			<name>CPZ</name>
			<desc>Compare Z register with content of memory location</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>LE</prefixBits>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0xc2</opcode>
				<feature>ce02</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0xd4</opcode>
				<feature>ce02</feature>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0xdc</opcode>
				<feature>ce02</feature>
			</opcodes>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0xd9</opcode>
				<feature>65k</feature>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0xe6</opcode>
				<feature>65k</feature>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0xdc</opcode>
				<feature>65k</feature>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Compare the operand with the Z register and set the flags
					appropriately.
					I.e. substract the operand from Z with an
					implicitly
					set carry in
					binary mode (even if
					decimal mode status bit is set),
					and set the flags from the result.
				</p>
				<pre>
					Tmp, C &amp;lt;= Z - Operand, C=1
					N &amp;lt;= Tmp(7)
					Z &amp;lt;=
					Z(Tmp)
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF, LE and RS prefixes are evaluated by the addressing
					modes.
					UM determines
					whether the operand is in user
					space.
				</p>
				<p>
					Note that the default is to use BYTE-wide operation without load
					extension.
				</p>
			</doc>
		</operation>

		<operation>
			<name>CMP</name>
			<desc>Compare accumulator with content of memory location</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>LE</prefixBits>
			<opcodes>
				<addressingMode>zpxind</addressingMode>
				<opcode>0xc1</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpxindquad</addressingMode>
				<opcode>0xc3</opcode>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0xc5</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0xc9</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0xcd</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindy</addressingMode>
				<opcode>0xd1</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpind</addressingMode>
				<opcode>0xd2</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindz</addressingMode>
				<opcode>0xd2</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindyquad</addressingMode>
				<opcode>0xd3</opcode>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>zpindzquad</addressingMode>
				<opcode>0xd7</opcode>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0xd5</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0xd9</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0xdd</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0xc9</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zps</addressingMode>
				<opcode>0xc3</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zpsindy</addressingMode>
				<opcode>0xd3</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>bank</addressingMode>
				<opcode>0xcf</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>bankx</addressingMode>
				<opcode>0xdf</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absindbank</addressingMode>
				<opcode>0xc7</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absindybank</addressingMode>
				<opcode>0xd7</opcode>
				<feature>816</feature>
			</opcodes>
			<doc>
				<p>
					Compare the operand with the accumulator and set the flags
					appropriately.
					I.e. substract the operand from AC with
					an
					implicitely set carry in
					binary mode (even if
					decimal mode status bit
					is set), and set the flags from the result.
				</p>
				<pre>
					Tmp, C &amp;lt;= Y - Operand, C=1
					N &amp;lt;= Tmp(7)
					Z &amp;lt;=
					Z(Tmp)
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF, LE and RS prefixes are evaluated by the addressing
					modes.
					UM determines
					whether the operand is in user
					space.
				</p>
				<p>
					Note that the default is to use BYTE-wide operation without load
					extension.
				</p>
			</doc>
		</operation>


		<!-- ################################# -->

		<operation>
			<name>ORA</name>
			<desc>Bitwise OR accumulator with content of memory location</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<opcodes>
				<addressingMode>zpxind</addressingMode>
				<opcode>0x01</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpxindquad</addressingMode>
				<opcode>0x03</opcode>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x05</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0x09</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0x0d</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindy</addressingMode>
				<opcode>0x11</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpind</addressingMode>
				<opcode>0x12</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindz</addressingMode>
				<opcode>0x12</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindyquad</addressingMode>
				<opcode>0x13</opcode>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x15</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindzquad</addressingMode>
				<opcode>0x17</opcode>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0x19</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0x1d</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0x09</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zps</addressingMode>
				<opcode>0x03</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zpsindy</addressingMode>
				<opcode>0x13</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>bank</addressingMode>
				<opcode>0x0f</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>bankx</addressingMode>
				<opcode>0x1f</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absindbank</addressingMode>
				<opcode>0x07</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absindybank</addressingMode>
				<opcode>0x17</opcode>
				<feature>816</feature>
			</opcodes>
			<doc>
				<p>
					Bitwise OR the accumulator with the operand and store back in the
					accumulator.
					Set the flags from the result.
				</p>
				<pre>
					AC &amp;lt;= AC | Operand
					N &amp;lt;= Tmp(7)
					Z &amp;lt;= Z(Tmp)
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF, LE and RS prefixes are evaluated by the addressing
					modes.
					UM determines
					whether the operand is in user
					space. NF allows
					to not set the flags.
				</p>
				<p>
					RS and LE together also determine the width of the operation.
					Note that the default is to use BYTE-wide operation
					without load
					extension.
				</p>
			</doc>
		</operation>

		<operation>
			<name>AND</name>
			<desc>Bitwise AND accumulator with content of memory location</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<opcodes>
				<addressingMode>zpxind</addressingMode>
				<opcode>0x21</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpxindquad</addressingMode>
				<opcode>0x23</opcode>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x25</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0x29</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0x2d</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindy</addressingMode>
				<opcode>0x31</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpind</addressingMode>
				<opcode>0x32</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindz</addressingMode>
				<opcode>0x32</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindyquad</addressingMode>
				<opcode>0x33</opcode>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x35</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindzquad</addressingMode>
				<opcode>0x37</opcode>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0x39</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0x3d</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0x29</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zps</addressingMode>
				<opcode>0x23</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zpsindy</addressingMode>
				<opcode>0x33</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>bank</addressingMode>
				<opcode>0x2f</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>bankx</addressingMode>
				<opcode>0x3f</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absindbank</addressingMode>
				<opcode>0x27</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absindybank</addressingMode>
				<opcode>0x37</opcode>
				<feature>816</feature>
			</opcodes>
			<doc>
				<p>
					Bitwise AND the accumulator with the operand and store back in
					the
					accumulator.
					Set the flags from the result.
				</p>
				<pre>
					AC &amp;lt;= AC &amp;amp; Operand
					N &amp;lt;= Tmp(7)
					Z &amp;lt;=
					Z(Tmp)
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF, LE and RS prefixes are evaluated by the addressing
					modes.
					UM determines
					whether the operand is in user
					space. NF allows
					to not set the flags.
				</p>
				<p>
					RS and LE together also determine the width of the operation.
					Note that the default is to use BYTE-wide operation
					without load
					extension.
				</p>
			</doc>
		</operation>

		<operation>
			<name>EOR</name>
			<desc>Bitwise Exclusive-OR accumulator with content of memory
				location
			</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<opcodes>
				<addressingMode>zpxind</addressingMode>
				<opcode>0x41</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpxindquad</addressingMode>
				<opcode>0x43</opcode>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x45</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0x49</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0x4d</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindy</addressingMode>
				<opcode>0x51</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpind</addressingMode>
				<opcode>0x52</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindz</addressingMode>
				<opcode>0x52</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindyquad</addressingMode>
				<opcode>0x53</opcode>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x55</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindzquad</addressingMode>
				<opcode>0x57</opcode>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0x59</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0x5d</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0x49</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zps</addressingMode>
				<opcode>0x43</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zpsindy</addressingMode>
				<opcode>0x53</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>bank</addressingMode>
				<opcode>0x4f</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>bankx</addressingMode>
				<opcode>0x5f</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absindbank</addressingMode>
				<opcode>0x47</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absindybank</addressingMode>
				<opcode>0x57</opcode>
				<feature>816</feature>
			</opcodes>
			<doc>
				<p>
					Bitwise Exclusive-OR the accumulator with the operand and store
					back in
					the
					accumulator.
					Set the flags from the
					result.
				</p>
				<pre>
					AC &amp;lt;= AC ^ Operand
					N &amp;lt;= Tmp(7)
					Z &amp;lt;= Z(Tmp)
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF, LE and RS prefixes are evaluated by the addressing
					modes.
					UM determines
					whether the operand is in user
					space. NF allows
					to not set the flags.
				</p>
				<p>
					RS and LE together also determine the width of the operation.
					Note that the default is to use BYTE-wide operation
					without load
					extension.
				</p>
			</doc>
		</operation>

		<operation>
			<name>ADC</name>
			<desc>Add content of memory location to accumulator</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<opcodes>
				<addressingMode>zpxind</addressingMode>
				<opcode>0x61</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpxindquad</addressingMode>
				<opcode>0x63</opcode>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x65</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0x69</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0x6d</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindy</addressingMode>
				<opcode>0x71</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpind</addressingMode>
				<opcode>0x72</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindz</addressingMode>
				<opcode>0x72</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindyquad</addressingMode>
				<opcode>0x73</opcode>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x75</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindzquad</addressingMode>
				<opcode>0x77</opcode>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0x79</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0x7d</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0x69</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zps</addressingMode>
				<opcode>0x63</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zpsindy</addressingMode>
				<opcode>0x73</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>bank</addressingMode>
				<opcode>0x6f</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>bankx</addressingMode>
				<opcode>0x7f</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absindbank</addressingMode>
				<opcode>0x67</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absindybank</addressingMode>
				<opcode>0x77</opcode>
				<feature>816</feature>
			</opcodes>
			<doc>
				<p>
					Add the operand to the accumulator and store back in the
					accumulator.
					Set the flags from the result. Use Decimal or
					Binary
					add depending
					on whether the
					decimal mode status bis is set or not
					respectively.
				</p>
				<pre>
					AC, C, V &amp;lt;= AC + Operand, C
					N &amp;lt;= Tmp(7)
					Z &amp;lt;=
					Z(Tmp)
				</pre>
				<p>
					For a handling of the V-flag please see
					<a href="http://www.6502.org/tutorials/vflag.html">http://www.6502.org/tutorials/vflag.html</a>
					.
				</p>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF, LE and RS prefixes are evaluated by the addressing
					modes.
					UM determines
					whether the operand is in user
					space. NF allows
					to not set the flags.
				</p>
				<p>
					RS and LE together also determine the width of the operation.
					Note that the default is to use BYTE-wide operation
					without load
					extension.
				</p>
			</doc>
		</operation>

		<operation>
			<name>DAD</name>
			<desc>Decimal adjust of a normal ADC of two BCD numbers.</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>NF</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x1a</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>Adjust the result of an ADC operation to BCD format. For example
					adding $14 and $08 with ADC (and C=0) gives $1c
					in normal mode.
					As
					an addition of two BCD numbers this should be $22 instead. DAD
					adjusts the non-BCD result back into
					a BCD result.
					DAD only works on
					the accumulator, i.e. takes the value from there and
					stores the
					result there.
					Set the
					flags from the result. The decimal flag is
					ignored. C is set
					when the decimal adjust overflows. V is not
					affected.
				</p>
				<pre>
					AC, C &amp;lt;= DecimalAdjustAdd(AC)
					N &amp;lt;= Tmp(7)
					Z &amp;lt;= Z(Tmp)
				</pre>
			</doc>
		</operation>

		<operation>
			<name>DAS</name>
			<desc>Decimal adjust of a normal SBC of two BCD numbers.</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>NF</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x3a</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>Adjust the result of an SBC operation to BCD format. For example
					substracting $08 from $24 with SBC (and C=1)
					gives $1c in normal
					mode.
					As a substraction of two BCD numbers this should be $16
					instead. DAD
					adjusts the non-BCD
					result back into a BCD result.
					DAD
					only works on the accumulator, i.e. takes the value from there and
					stores the
					result there.
					Set the flags from the result. The decimal
					flag is ignored. C is set
					when the decimal adjust overflows.
					V is
					not affected.
				</p>
				<pre>
					AC, C &amp;lt;= DecimalAdjustSub(AC)
					N &amp;lt;= Tmp(7)
					Z &amp;lt;= Z(Tmp)
				</pre>
			</doc>
		</operation>

		<operation>
			<name>ADD</name>
			<desc>Add content of memory location to accumulator without using
				carry as input
			</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0x05</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0x00</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Add the operand to the accumulator and store back in the
					accumulator.
					Set the flags from the result. Use Binary
					mode add
					only.
					Do not use the Carry flag as input.
				</p>
				<pre>
					AC, C, V &amp;lt;= AC + Operand
					N &amp;lt;= Tmp(7)
					Z &amp;lt;=
					Z(Tmp)
				</pre>
				<p>
					For a handling of the V-flag please see
					<a href="http://www.6502.org/tutorials/vflag.html">http://www.6502.org/tutorials/vflag.html</a>
					.
				</p>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF, LE and RS prefixes are evaluated by the addressing
					modes.
					UM determines
					whether the operand is in user
					space. NF allows
					to not set the flags.
				</p>
				<p>
					RS and LE together also determine the width of the operation.
					Note that the default is to use BYTE-wide operation
					without load
					extension.
				</p>
			</doc>
		</operation>


		<operation>
			<name>SBC</name>
			<desc>Substract content of memory location from accumulator</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<opcodes>
				<addressingMode>zpxind</addressingMode>
				<opcode>0xe1</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpxindquad</addressingMode>
				<opcode>0xe3</opcode>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0xe5</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0xe9</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0xeb</opcode>
				<feature>undoc</feature>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0xed</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindy</addressingMode>
				<opcode>0xf1</opcode>
			</opcodes>
			<opcodes>
				<!-- cmos -->
				<addressingMode>zpind</addressingMode>
				<opcode>0xf2</opcode>
			</opcodes>
			<opcodes>
				<!-- 65ce02 -->
				<addressingMode>zpindz</addressingMode>
				<opcode>0xf2</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindyquad</addressingMode>
				<opcode>0xf3</opcode>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0xf5</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindzquad</addressingMode>
				<opcode>0xf7</opcode>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0xf9</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0xfd</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0xe9</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zps</addressingMode>
				<opcode>0xe3</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zpsindy</addressingMode>
				<opcode>0xf3</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>bank</addressingMode>
				<opcode>0xef</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>bankx</addressingMode>
				<opcode>0xff</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absindbank</addressingMode>
				<opcode>0xe7</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absindybank</addressingMode>
				<opcode>0xf7</opcode>
				<feature>816</feature>
			</opcodes>
			<doc>
				<p>
					Substract the operand from the accumulator and store back in the
					accumulator.
					Set the flags from the result. Use
					Decimal or Binary
					add depending
					on whether the
					decimal mode status bis is set or not
					respectively. C status flag is
					used
					as borrow.
				</p>
				<pre>
					AC, C, V &amp;lt;= AC - Operand, C
					N &amp;lt;= Tmp(7)
					Z &amp;lt;=
					Z(Tmp)
				</pre>
				<p>
					For a handling of the V-flag please see
					<a href="http://www.6502.org/tutorials/vflag.html">http://www.6502.org/tutorials/vflag.html</a>
					.
				</p>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF, LE and RS prefixes are evaluated by the addressing
					modes.
					UM determines
					whether the operand is in user
					space. NF allows
					to not set the flags.
				</p>
				<p>
					RS and LE together also determine the width of the operation.
					Note that the default is to use BYTE-wide operation
					without load
					extension.
				</p>
			</doc>
		</operation>

		<operation>
			<name>SUB</name>
			<desc>Substract content of memory location from accumulator without
				using the carry flag as input
			</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0x85</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0x80</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Substract the operand from the accumulator and store back in the
					accumulator.
					Set the flags from the result. Use
					Binary mode add
					only. C status
					flag is not used as
					input, but set as borrow from the
					result.
				</p>
				<pre>
					AC, C, V &amp;lt;= AC - Operand
					N &amp;lt;= Tmp(7)
					Z &amp;lt;=
					Z(Tmp)
				</pre>
				<p>
					For a handling of the V-flag please see
					<a href="http://www.6502.org/tutorials/vflag.html">http://www.6502.org/tutorials/vflag.html</a>
					.
				</p>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF, LE and RS prefixes are evaluated by the addressing
					modes.
					UM determines
					whether the operand is in user
					space. NF allows
					to not set the flags.
				</p>
				<p>
					RS and LE together also determine the width of the operation.
					Note that the default is to use BYTE-wide operation
					without load
					extension.
				</p>
			</doc>
		</operation>

		<!-- ################################# -->

		<operation>
			<name>ASR</name>
			<desc>Arithmetic Shift Right - Similar to LSR, but shifts in the sign
				of the value, not zero
			</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<opcodes>
				<addressingMode>A</addressingMode>
				<opcode>0x43</opcode>
				<feature>ce02</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x06</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x44</opcode>
				<feature>ce02</feature>
			</opcodes>
			<opcodes>
				<addressingMode>A</addressingMode>
				<opcode>0x0a</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0x0e</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x16</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x54</opcode>
				<feature>ce02</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0x1e</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0x1f</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0x1d</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<doc>
				<p>
					Shift the operand or accumulator right one bit (i.e. divide by
					2). Shift
					in the sign (uppermost bit) from the left.
					The bit shifted
					out is moved into the carry flag.
					Note this opcode is a
					read-modify-write opcode and not only has
					memory-oriented addressing
					modes but can work
					on the accumulator alone as well.
				</p>
				<pre>
					C &amp;lt;= AC(0)
					AC(6-0) &amp;lt;= AC(7-1)
					N &amp;lt;= AC7)
					Z
					&amp;lt;= Z(AC)
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					UM
					determines
					whether the operand is in user
					space. NF allows to not
					set the flags.
				</p>
				<p>
					RS also determine the width of the operation. There is no LE
					prefix,
					as the read and write
					widths are the same.
					Note
					that the
					default is to use BYTE-wide operation without load
					extension.
				</p>
			</doc>
		</operation>

		<operation>
			<name>RDL</name>
			<desc>Rotate Direct Left - similar to ROL, but do not shift in carry,
				but the highest bit of the original value
			</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x26</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>A</addressingMode>
				<opcode>0x2a</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0x2e</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x36</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0x3e</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0x3f</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0x3d</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x08</opcode>
				<oppage>QUICK</oppage>
				<feature>65k</feature>
				<expand>0x70</expand>
				<expand8>true</expand8>
			</opcodes>
			<doc>
				<p>
					Shift the operand or accumulator left one bit (i.e. multiply by
					2).
					Shift
					in the sign (uppermost bit) of
					the original
					value from the
					right.
					The bit shifted is also moved into the carry flag.
					Note this
					opcode is a read-modify-write opcode
					and not only has
					memory-oriented addressing modes but can work
					on the accumulator
					alone as well.
				</p>
				<pre>
					C &amp;lt;= AC(7)
					AC(7-1) &amp;lt;= AC(6-0)
					AC(0) &amp;lt;= C
					N
					&amp;lt;= AC7)
					Z &amp;lt;= Z(AC)
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					UM
					determines
					whether the operand is in user
					space. NF allows to not
					set the flags.
				</p>
				<p>
					RS also determine the width of the operation. There is no LE prefix,
					as the read and write widths are the same.
					Note that the default is to use BYTE-wide operation without load
					extension.
				</p>
			</doc>
		</operation>


		<operation>
			<name>RDR</name>
			<feature>65k</feature>
			<desc>Rotate Direct Right - similar to ROR, but do not shift in
				carry,
				but the lowest bit of the original value
			</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x66</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>A</addressingMode>
				<opcode>0x6a</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0x6e</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x76</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0x7e</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0x7f</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0x7d</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x88</opcode>
				<oppage>QUICK</oppage>
				<feature>65k</feature>
				<expand>0x70</expand>
				<expand8>true</expand8>
			</opcodes>
			<doc>
				<p>
					Shift the operand or accumulator right one bit (i.e. divide by
					2). Shift
					in bit 0 (lowermost bit) of
					the original
					value from the
					left.
					The bit shifted is also moved into the carry flag.
					Note this
					opcode is a read-modify-write opcode
					and not only has
					memory-oriented addressing modes but can work
					on the accumulator
					alone as well.
				</p>
				<pre>
					C &amp;lt;= AC(0)
					AC(6-0) &amp;lt;= AC(7-1)
					AC(7) &amp;lt;= C
					N
					&amp;lt;= AC7)
					Z &amp;lt;= Z(AC)
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					UM
					determines
					whether the operand is in user
					space. NF allows to not
					set the flags.
				</p>
				<p>
					RS also determine the width of the operation. There is no LE
					prefix,
					as the read and write
					widths are the same.
					Note
					that the
					default is to use BYTE-wide operation without load
					extension.
				</p>
			</doc>
		</operation>

		<!-- ################################# -->

		<operation>
			<name>ASL</name>
			<desc>Arithmetic Shift Left - shift accumulator one bit to the left,
				shifting in zero in bit 0
			</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x06</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>A</addressingMode>
				<opcode>0x0a</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0x0e</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x16</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0x1e</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0x0f</opcode>
				<feature>65k</feature>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0x0d</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Shift the operand or accumulator left one bit (i.e. multiply by
					2).
					Shift
					in a zero from the right.
					The bit shifted
					out is moved into
					the carry flag.
					Note this opcode is a read-modify-write opcode and
					not only has
					memory-oriented
					addressing modes but can work
					on the
					accumulator alone as well.
				</p>
				<pre>
					C &amp;lt;= AC(7)
					AC(7-1) &amp;lt;= AC(6-0)
					AC(0) &amp;lt;= 0
					N
					&amp;lt;= AC7)
					Z &amp;lt;= Z(AC)
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					UM
					determines
					whether the operand is in user
					space. NF allows to not
					set the flags.
				</p>
				<p>
					RS also determine the width of the operation. There is no LE
					prefix,
					as the read and write
					widths are the same.
					Note
					that the
					default is to use BYTE-wide operation without load
					extension.
				</p>
			</doc>
		</operation>

		<operation>
			<name>LSR</name>
			<desc>Logical Shift Right - shift accumulator one bit to the right,
				shifting in zero in the highest bit
			</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x46</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>A</addressingMode>
				<opcode>0x4a</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0x4e</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x56</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0x5e</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0x4f</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0x4d</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Shift the operand or accumulator right one bit (i.e. divide by
					2). Shift
					in a zero from the left.
					The bit shifted
					out is moved into
					the carry flag.
					Note this opcode is a read-modify-write opcode and
					not only has
					memory-oriented
					addressing modes but can work
					on the
					accumulator alone as well.
				</p>
				<pre>
					C &amp;lt;= AC(0)
					AC(6-0) &amp;lt;= AC(7-1)
					AC(7) &amp;lt;= 0
					N
					&amp;lt;= AC7)
					Z &amp;lt;= Z(AC)
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					UM
					determines
					whether the operand is in user
					space. NF allows to not
					set the flags.
				</p>
				<p>
					RS also determine the width of the operation. There is no LE
					prefix,
					as the read and write
					widths are the same.
					Note
					that the
					default is to use BYTE-wide operation without load
					extension.
				</p>
			</doc>
		</operation>


		<operation>
			<name>ROL</name>
			<desc>Rotate Left - shift accumulator one bit to the left, shifting
				in
				the carry flag in bit 0, and shifting the
				highest bit into the
				carry flag instead.
			</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x26</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>A</addressingMode>
				<opcode>0x2a</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0x2e</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x36</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0x3e</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0x2f</opcode>
				<feature>65k</feature>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0x2d</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x09</opcode>
				<oppage>QUICK</oppage>
				<feature>65k</feature>
				<expand>0x70</expand>
				<expand8>true</expand8>
			</opcodes>
			<doc>
				<p>
					Shift the operand or accumulator left one bit (i.e. multiply by
					2).
					Shift
					in the carry flag from the right.
					The bit
					shifted out is
					moved into the carry flag.
					Note this opcode is a read-modify-write
					opcode and not only has
					memory-oriented addressing modes but can
					work
					on the accumulator alone as well.
				</p>
				<pre>
					Tmp &amp;lt;= AC(7)
					AC(7-1) &amp;lt;= AC(6-0)
					AC(0) &amp;lt;= C
					C
					&amp;lt;= Tmp
					N &amp;lt;= AC7)
					Z &amp;lt;= Z(AC)
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					UM
					determines
					whether the operand is in user
					space. NF allows to not
					set the flags.
				</p>
				<p>
					RS also determine the width of the operation. There is no LE
					prefix,
					as the read and write
					widths are the same.
					Note
					that the
					default is to use BYTE-wide operation without load
					extension.
				</p>
			</doc>
		</operation>


		<operation>
			<name>ROR</name>
			<desc>Rotate Right - shift accumulator one bit to the right, shifting
				in the carry flag in the highest bit, and
				shifting
				bit 0 into the
				carry flag instead.
			</desc>
			<feature>ror</feature>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x66</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>A</addressingMode>
				<opcode>0x6a</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0x6e</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x76</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0x7e</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0x6f</opcode>
				<feature>65k</feature>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0x6d</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x89</opcode>
				<oppage>QUICK</oppage>
				<feature>65k</feature>
				<expand>0x70</expand>
				<expand8>true</expand8>
			</opcodes>
			<doc>
				<p>
					Shift the operand or accumulator right one bit (i.e. divide by
					2). Shift
					in the carry flag from the left.
					The bit
					shifted out is
					moved into the carry flag.
					Note this opcode is a read-modify-write
					opcode and not only has
					memory-oriented addressing modes but can
					work
					on the accumulator alone as well.
				</p>
				<pre>
					Tmp &amp;lt;= AC(0)
					AC(6-0) &amp;lt;= AC(7-1)
					AC(7) &amp;lt;= C
					C
					&amp;lt;= Tmp
					N &amp;lt;= AC7)
					Z &amp;lt;= Z(AC)
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					UM
					determines
					whether the operand is in user
					space. NF allows to not
					set the flags.
				</p>
				<p>
					RS also determine the width of the operation. There is no LE
					prefix,
					as the read and write
					widths are the same.
					Note
					that the
					default is to use BYTE-wide operation without load
					extension.
				</p>
			</doc>
		</operation>

		<operation>
			<name>INC</name>
			<desc>Increment the content of a memory location by one</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0xe6</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>A</addressingMode>
				<opcode>0x1a</opcode>
				<feature>cmos</feature>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0xee</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0xf6</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0xfe</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0xef</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0xed</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x0e</opcode>
				<oppage>QUICK</oppage>
				<feature>65k</feature>
				<expand>0x70</expand>
				<expand8>true</expand8>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0x0d</opcode>
				<oppage>QUICK</oppage>
				<feature>65k</feature>
				<expand>0x70</expand>
				<expand8>true</expand8>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x0c</opcode>
				<oppage>QUICK</oppage>
				<feature>65k</feature>
				<expand>0x70</expand>
				<expand8>true</expand8>
			</opcodes>
			<doc>
				<p>
					Increment the operand by one, i.e. binary add one.
					Note this
					opcode is a read-modify-write opcode and not only has
					memory-oriented addressing modes but can work
					on the accumulator
					alone as well.
				</p>
				<pre>
					Operand &amp;lt;= Operand + 1
					N &amp;lt;= OperandC7)
					Z &amp;lt;=
					Z(AC)
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					UM
					determines
					whether the operand is in user
					space. NF allows to not
					set the flags.
				</p>
				<p>
					RS also determine the width of the operation. There is no LE
					prefix,
					as the read and write
					widths are the same.
					Note
					that the
					default is to use BYTE-wide operation without load
					extension.
				</p>
			</doc>
		</operation>

		<operation>
			<name>DEC</name>
			<desc>Decrement the content of a memory location by one</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0xc6</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>A</addressingMode>
				<opcode>0x3a</opcode>
				<feature>cmos</feature>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0xce</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0xd6</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0xde</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0xcf</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0xcd</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x8e</opcode>
				<oppage>QUICK</oppage>
				<feature>65k</feature>
				<expand>0x70</expand>
				<expand8>true</expand8>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0x8d</opcode>
				<oppage>QUICK</oppage>
				<feature>65k</feature>
				<expand>0x70</expand>
				<expand8>true</expand8>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x8c</opcode>
				<oppage>QUICK</oppage>
				<feature>65k</feature>
				<expand>0x70</expand>
				<expand8>true</expand8>
			</opcodes>
			<doc>
				<p>
					Decrement the operand by one, i.e. binary substract one.
					Note this
					opcode is a read-modify-write opcode and not
					only has
					memory-oriented addressing modes but can work
					on the accumulator
					alone as well.
				</p>
				<pre>
					Operand &amp;lt;= Operand - 1
					N &amp;lt;= OperandC7)
					Z &amp;lt;=
					Z(AC)
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					UM
					determines
					whether the operand is in user
					space. NF allows to not
					set the flags.
				</p>
				<p>
					RS also determine the width of the operation. There is no LE
					prefix,
					as the read and write
					widths are the same.
					Note
					that the
					default is to use BYTE-wide operation without load
					extension.
				</p>
			</doc>
		</operation>



		<!-- ################################# -->

		<operation>
			<name>STA</name>
			<desc>Store the content of the accumulator into a memory location
			</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>UM</prefixBits>
			<opcodes>
				<addressingMode>zpy</addressingMode>
				<opcode>0x22</opcode>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zpxind</addressingMode>
				<opcode>0x81</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpxindquad</addressingMode>
				<opcode>0x83</opcode>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x85</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0x8d</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindy</addressingMode>
				<opcode>0x91</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpind</addressingMode>
				<opcode>0x92</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindz</addressingMode>
				<opcode>0x92</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindyquad</addressingMode>
				<opcode>0x93</opcode>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x95</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindzquad</addressingMode>
				<opcode>0x97</opcode>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0x99</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0x9d</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absindy</addressingMode>
				<opcode>0xc2</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absindyquad</addressingMode>
				<opcode>0xc7</opcode>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>absxind</addressingMode>
				<opcode>0xe2</opcode>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absxindquad</addressingMode>
				<opcode>0xe7</opcode>
				<fixed>
					<name>AM</name>
					<value>1</value>
				</fixed>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0x8d</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zpsindy</addressingMode>
				<opcode>0x82</opcode>
				<feature>ce02</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zps</addressingMode>
				<opcode>0x83</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zpsindy</addressingMode>
				<opcode>0x93</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>bank</addressingMode>
				<opcode>0x8f</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>bankx</addressingMode>
				<opcode>0x9f</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absindbank</addressingMode>
				<opcode>0x87</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absindybank</addressingMode>
				<opcode>0x97</opcode>
				<feature>816</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zpindbyte</addressingMode>
				<opcode>0x91</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absindbyte</addressingMode>
				<opcode>0x51</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zpindbytequad</addressingMode>
				<opcode>0x92</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absindbytequad</addressingMode>
				<opcode>0x52</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<doc>
				<p>
					Store the accumulator into the address given by the operand.
				</p>
				<pre>
					Operand &amp;lt;= A
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					UM
					determines
					whether the operand is in user
					space.
				</p>
				<p>
					RS also determine the width of the operation.
					Note that the
					default is to use BYTE-wide operation without load
					extension.
				</p>
			</doc>
		</operation>

		<operation>
			<name>STZ</name>
			<desc>Store zero into a memory location</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>UM</prefixBits>
			<feature>cmos</feature>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x64</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x74</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0x9c</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0x9e</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0x9e</opcode>
				<feature>65k</feature>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0x9c</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Store zero into the address given by the operand.
				</p>
				<pre>
					Operand &amp;lt;= 0
				</pre>
			</doc>
			<doc mode="ce02">
				<p>Instead of zero, write the value of the Z register.
				</p>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					UM
					determines
					whether the operand is in user
					space.
				</p>
				<p>
					RS also determine the width of the operation.
					Note that the
					default is to use BYTE-wide operation without load
					extension.
				</p>
			</doc>
		</operation>

		<operation>
			<name>STY</name>
			<desc>Store the content of the Y register to memory.</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>UM</prefixBits>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x84</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0x8c</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x94</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0x8f</opcode>
				<feature>65k</feature>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0x8b</opcode>
				<feature>ce02</feature>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0x8c</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Store the content of the Y register into the address given by the
					operand.
				</p>
				<pre>
					Operand &amp;lt;= A
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					UM
					determines
					whether the operand is in user
					space.
				</p>
				<p>
					RS also determine the width of the operation.
					Note that the
					default is to use BYTE-wide operation without load
					extension.
				</p>
			</doc>
		</operation>

		<operation>
			<name>STX</name>
			<desc>Store the content of the X register to memory.</desc>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>UM</prefixBits>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x86</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0x8e</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpy</addressingMode>
				<opcode>0x96</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0xaf</opcode>
				<feature>65k</feature>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0x9b</opcode>
				<feature>ce02</feature>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0x9d</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Store the content of the X register into the address given by the
					operand.
				</p>
				<pre>
					Operand &amp;lt;= A
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The AM, OF and RS prefixes are evaluated by the addressing modes.
					UM
					determines
					whether the operand is in user
					space.
				</p>
				<p>
					RS also determine the width of the operation.
					Note that the
					default is to use BYTE-wide operation without load
					extension.
				</p>
			</doc>
		</operation>


		<!-- ################################# -->

		<operation>
			<name>TRP</name>
			<desc>Trap into 65k supervisor mode</desc>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0xf4</opcode>
			</opcodes>
			<doc>
				<p>
					Trap into supervisor mode. Pushes the return address and the
					extended
					status byte
					on the hypervisor stack and jumps
					into
					hypervisor mode,
					using the appropriate trap vector. To return from
					the trap, the RTU
					operations is used.
					For
					compatibility with RTS, the
					return address minus one is stored on
					the stack.
				</p>
				<pre>
					Stack(SP--) &amp;lt;= &gt; NextPC-1
					Stack(SP--) &amp;lt;=
					&amp;lt; NextPC-1
					Stack(SP--) &amp;lt;= ExtStatus
					PC
					&amp;lt;=
					TrapVector(Operand)
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The address put on the stack always has the natural width of the
					processor.
					Currently no further prefix is
					supported.
					The stack
					pointer used is that of the hypervisor stack.
				</p>
				<p>
					This opcode can be used in user mode as well as in hypervisor
					mode. The
					extended status byte
					contains the user mode
					bit, so that
					the RTU opcode knows whether to return
					to user mode or
					hypervisor
					mode.
				</p>
				<p>
					The extendend status byte also contains width bits that store the
					width
					of the return
					address on stack. BYTE is not
					used, but the real
					width is stored with the
					width bits.
				</p>
				<p>
					Note for future expansions the RS prefix may extend the trap
					number
					(the
					immediate operand)
					to word, or even wider
					widths.
				</p>
			</doc>
		</operation>

		<operation>
			<name>RTU</name>
			<desc>Return from trap handler.</desc>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0x60</opcode>
				<oppage>SYS</oppage>
			</opcodes>
			<doc>
				<p>
					Return from trap handling. Reads the extended status byte and the
					return
					address from hypervisor stack,
					then jumps
					to the return
					address.
				</p>
				<pre>
					&amp;lt;Tmp &amp;lt;= Stack(++SP)
					&gt;Tmp &amp;lt;= Stack(++SP)
					Tmp &amp;lt;= Tmp+1
					PC &amp;lt;= Tmp;
					ExtStatus
					&amp;lt;= Stack(++SP)
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The extended status byte contains the width bits for the return
					address
					as well as the user mode bit
					from where the
					trap came. In RTU
					the user mode bit is restored, so the
					RTU opcode can return to
					user
					as well as hypervisor mode.
				</p>
				<p>
					The stack pointer used is that of the hypervisor stack.
				</p>
				<p>
					Note for future expansions the RS prefix may extend the number of
					traps
					to word, or even wider widths.
				</p>
				<p>
					When executed in user mode, this opcode triggers an ABORT
					exception.
				</p>
			</doc>
		</operation>


		<!-- ################################# -->

		<operation>
			<name>PHP</name>
			<desc>Push processor status register onto the stack</desc>
			<prefixBits>UM</prefixBits>
			<prefixBits>RS</prefixBits>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x08</opcode>
			</opcodes>
			<doc>
				<p>
					Push the standard status register on the stack.
				</p>
				<pre>
					Stack(SP--) &amp;lt;= Status
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The stack pointer used is the one of the current stack if the UM
					prefix
					is not set.
					If UM is set and the opcode is
					executed in
					hypervisor mode, the stack
					pointer used is the
					user mode stack
					pointer and the value is stored in user mode
					memory. If
					executed in
					user mode with UM set an ABORT exception is triggered.
				</p>
				<p>
					The not-extended bit is set (so the status is compatible with the
					6502
					and would denote a
					standard stack frame) as
					long as RS is 00.
				</p>
				<p>
					If RS indicates a word-wide push, the G and OE flags of the
					extended
					status registers are
					pushed (with all other
					bits zero)
					before the standard status register.
					The
					standard status
					register has
					the not-extended bit cleared in this
					case.
				</p>
				<p>
					RS set to long or quad lengths are illegal and trap into an
					ABORT.
				</p>
			</doc>
		</operation>

		<operation>
			<name>CLC</name>
			<desc>Clear the C flag</desc>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x18</opcode>
			</opcodes>
			<doc>
				<p>
					Clear the carry status flag.
				</p>
			</doc>
		</operation>

		<operation>
			<name>PLP</name>
			<desc>Pull processor status register from the stack</desc>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x28</opcode>
			</opcodes>
			<doc>
				<p>
					Pull the standard status register on the stack.
				</p>
				<pre>
					Status &amp;lt;= Stack(++SP)
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The stack pointer used is the one of the current stack if the UM
					prefix
					is not set.
					If UM is set and the opcode is
					executed in
					hypervisor mode, the stack
					pointer used is the
					user mode stack
					pointer and the value is stored in user mode
					memory. If
					executed in
					user mode with UM set an ABORT exception is triggered.
				</p>
				<p>
					When the status register has bit 5 (the not-extended bit) set,
					then PLP
					reads the standard
					status register only.
				</p>
				<p>
					When the status register has bit 5 cleared, it reads a second
					byte from
					the stack and
					restores the G and OE flags
					from that byte
					into the extended status
					register.
					(Note that this introduces a
					slight incompatibility with the 6502. So
					this behaviour may change
					to require the RS width set to word.)
				</p>
			</doc>
		</operation>

		<operation>
			<name>SEC</name>
			<desc>Set the C flag</desc>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x38</opcode>
			</opcodes>
			<doc>
				<p>
					Set the carry status flag.
				</p>
			</doc>
		</operation>

		<operation>
			<name>PHA</name>
			<desc>Push contents of the accumulator onto the stack</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>UM</prefixBits>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x48</opcode>
			</opcodes>
			<doc>
				<p>
					Push the content of the accumulator on the stack.
				</p>
				<pre>
					Stack(SP--) &amp;lt;= A
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The RS prefix determines the width of the accumulator value as
					written
					on the stack.
				</p>
				<p>
					The stack pointer used is the one of the current stack if the UM
					prefix
					is not set.
					If UM is set and the opcode is
					executed in
					hypervisor mode, the stack
					pointer used is the
					user mode stack
					pointer and the value is stored in user mode
					memory. If
					executed in
					user mode with UM set an ABORT exception is triggered.
				</p>
			</doc>
		</operation>

		<operation>
			<name>PHY</name>
			<desc>Push contents of the Y register onto the stack</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>UM</prefixBits>
			<feature>cmos</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x5a</opcode>
			</opcodes>
			<doc>
				<p>
					Push the content of the Y register on the stack.
				</p>
				<pre>
					Stack(SP--) &amp;lt;= Y
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The RS prefix determines the width of the accumulator value as
					written
					on the stack.
				</p>
				<p>
					The stack pointer used is the one of the current stack if the UM
					prefix
					is not set.
					If UM is set and the opcode is
					executed in
					hypervisor mode, the stack
					pointer used is the
					user mode stack
					pointer and the value is stored in user mode
					memory. If
					executed in
					user mode with UM set an ABORT exception is triggered.
				</p>
			</doc>
		</operation>

		<operation>
			<name>PHX</name>
			<desc>Push contents of the X register onto the stack</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>UM</prefixBits>
			<feature>cmos</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xda</opcode>
			</opcodes>
			<doc>
				<p>
					Push the content of the X register on the stack.
				</p>
				<pre>
					Stack(SP--) &amp;lt;= X
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The RS prefix determines the width of the accumulator value as
					written
					on the stack.
				</p>
				<p>
					The stack pointer used is the one of the current stack if the UM
					prefix
					is not set.
					If UM is set and the opcode is
					executed in
					hypervisor mode, the stack
					pointer used is the
					user mode stack
					pointer and the value is stored in user mode
					memory. If
					executed in
					user mode with UM set an ABORT exception is triggered.
				</p>
			</doc>
		</operation>

		<operation>
			<name>CLI</name>
			<desc>Clear the interrupt (I) flag</desc>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x58</opcode>
			</opcodes>
			<doc>
				<p>
					Clear the interrupt status flag.
				</p>
			</doc>
			<doc mode="65k">
				<p>
					Note that the interrupt handling is much more sophisticated in
					the 65k.
					In hypervisor mode setting the interrupt
					status flag
					disables all
					interrupts except the non-maskable interrupt.
					In user
					mode setting the interrupt status flag
					disables all "user
					level
					interrupts", but hypervisor interrupts
					are served. The interrupt
					level for user level
					interrupts can be
					configured in a configuration
					register.
				</p>
			</doc>
		</operation>

		<operation>
			<name>PLA</name>
			<desc>Pull the contents of the accumulator from the stack</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x68</opcode>
			</opcodes>
			<doc>
				<p>
					Pull the value of the accumulator from the stack.
				</p>
				<pre>
					A &amp;lt;= Stack(++SP)
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The RS prefix determines the width of the accumulator value as
					written
					on the stack.
				</p>
				<p>
					The stack pointer used is the one of the current stack if the UM
					prefix
					is not set.
					If UM is set and the opcode is
					executed in
					hypervisor mode, the stack
					pointer used is the
					user mode stack
					pointer and the value is stored in user mode
					memory. If
					executed in
					user mode with UM set an ABORT exception is triggered.
				</p>
			</doc>
		</operation>

		<operation>
			<name>PLY</name>
			<desc>Pull the contents of the Y register from the stack</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<feature>cmos</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x7a</opcode>
			</opcodes>
			<doc>
				<p>
					Pull the value of the Y register from the stack.
				</p>
				<pre>
					Y &amp;lt;= Stack(++SP)
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The RS prefix determines the width of the accumulator value as
					written
					on the stack.
				</p>
				<p>
					The stack pointer used is the one of the current stack if the UM
					prefix
					is not set.
					If UM is set and the opcode is
					executed in
					hypervisor mode, the stack
					pointer used is the
					user mode stack
					pointer and the value is stored in user mode
					memory. If
					executed in
					user mode with UM set an ABORT exception is triggered.
				</p>
			</doc>
		</operation>

		<operation>
			<name>PLX</name>
			<desc>Pull the contents of the X register from the stack</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<feature>cmos</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xfa</opcode>
			</opcodes>
			<doc>
				<p>
					Pull the value of the X register from the stack.
				</p>
				<pre>
					X &amp;lt;= Stack(++SP)
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The RS prefix determines the width of the accumulator value as
					written
					on the stack.
				</p>
				<p>
					The stack pointer used is the one of the current stack if the UM
					prefix
					is not set.
					If UM is set and the opcode is
					executed in
					hypervisor mode, the stack
					pointer used is the
					user mode stack
					pointer and the value is stored in user mode
					memory. If
					executed in
					user mode with UM set an ABORT exception is triggered.
				</p>
			</doc>
		</operation>

		<operation>
			<name>SEI</name>
			<desc>Set the interrupt (I) flag</desc>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x78</opcode>
			</opcodes>
			<doc>
				<p>
					Set the interrupt status flag.
				</p>
			</doc>
			<doc mode="65k">
				<p>
					Note that the interrupt handling is much more sophisticated in
					the 65k.
					In hypervisor mode setting the interrupt
					status flag
					disables all
					interrupts except the non-maskable interrupt.
					In user
					mode setting the interrupt status flag
					disables all "user
					level
					interrupts", but hypervisor interrupts
					are served. The interrupt
					level for user level
					interrupts can be
					configured in a configuration
					register.
				</p>
			</doc>
		</operation>

		<operation>
			<name>DEY</name>
			<desc>Decrement the Y register by one</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>NF</prefixBits>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x88</opcode>
			</opcodes>
			<doc>
				<p>
					Decrement the Y register by one (binary).
				</p>
				<pre>
					Y &amp;lt;= Y-1
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The RS prefix determines the width of the operation. The NF flag
					allows
					to perform the operation
					without setting
					flags.
				</p>
			</doc>
		</operation>

		<operation>
			<name>TYA</name>
			<desc>Transfer the contents of the Y register into the accumulator
			</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>NF</prefixBits>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x98</opcode>
			</opcodes>
			<doc>
				<p>
					Transfer the value of the Y register to the accumulator
				</p>
				<pre>
					A &amp;lt;= Y
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The RS and LE prefixes determines the width of the operation. LE
					determines how to extend the value
					loaded to the
					full (natural)
					width. The NF flag allows to perform the
					operation
					without setting
					flags.
				</p>
			</doc>
		</operation>

		<operation>
			<name>TXA</name>
			<desc>Transfer the contents of the X register into the accumulator
			</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>NF</prefixBits>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x8a</opcode>
			</opcodes>
			<doc>
				<p>
					Transfer the value of the X register to the accumulator
				</p>
				<pre>
					A &amp;lt;= X
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The RS and LE prefixes determines the width of the operation. LE
					determines how to extend the value
					loaded to the
					full (natural)
					width. The NF flag allows to perform the
					operation
					without setting
					flags.
				</p>
			</doc>
		</operation>

		<operation>
			<name>TSX</name>
			<desc>Transfer the contents of the stack pointer into the X register
				(Note: needs RS to keep compatibility with 6502)
			</desc>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xba</opcode>
			</opcodes>
			<doc>
				<p>
					Transfer the value of the stack pointer to the X register
				</p>
				<pre>
					X &amp;lt;= S
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The RS and LE prefixes determines the width of the operation. LE
					determines how to extend the value
					loaded to the
					full (natural)
					width. The NF flag allows to perform the
					operation
					without setting
					flags.
				</p>
				<p>
					The stack pointer used is the current stack pointer. If the user
					mode
					bit is set in hypervisor mode,
					the stack
					pointer used is the
					user mode stack pointer. If the user
					mode
					bit is set in user mode,
					an
					ABORT exception is triggered.
				</p>
			</doc>
		</operation>

		<operation>
			<name>TXS</name>
			<desc>Transfer the contents of X register into the stack pointer
				(Note: needs RS to keep compatibility with 6502)
			</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>UM</prefixBits>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x9a</opcode>
			</opcodes>
			<doc>
				<p>
					Transfer the value of the X register to the stack pointer.
				</p>
				<pre>
					S &amp;lt;= X
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The RS and LE prefixes determines the width of the operation. LE
					determines how to extend the value
					loaded to the
					full (natural)
					width. The NF flag allows to perform the
					operation
					without setting
					flags.
				</p>
				<p>
					The stack pointer used is the current stack pointer. If the user
					mode
					bit is set in hypervisor mode,
					the stack
					pointer used is the
					user mode stack pointer. If the user
					mode
					bit is set in user mode,
					an
					ABORT exception is triggered.
				</p>
			</doc>
		</operation>

		<operation>
			<name>TAY</name>
			<desc>Transfer the contents of accumulator into the Y register</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>NF</prefixBits>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xa8</opcode>
			</opcodes>
			<doc>
				<p>
					Transfer the value of the accumulator to the Y register
				</p>
				<pre>
					Y &amp;lt;= A
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The RS and LE prefixes determines the width of the operation. LE
					determines how to extend the value
					loaded to the
					full (natural)
					width. The NF flag allows to perform the
					operation
					without setting
					flags.
				</p>
			</doc>
		</operation>

		<operation>
			<name>TAX</name>
			<desc>Transfer the contents of accumulator into the X register</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>NF</prefixBits>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xaa</opcode>
			</opcodes>
			<doc>
				<p>
					Transfer the value of the accumulator to the X register
				</p>
				<pre>
					X &amp;lt;= A
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The RS and LE prefixes determines the width of the operation. LE
					determines how to extend the value
					loaded to the
					full (natural)
					width. The NF flag allows to perform the
					operation
					without setting
					flags.
				</p>
			</doc>
		</operation>


		<operation>
			<name>CLV</name>
			<desc>Clear the overflow (V) flag</desc>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xb8</opcode>
			</opcodes>
			<doc>
				<p>
					Clear the overflow status flag.
				</p>
			</doc>
		</operation>

		<operation>
			<name>INY</name>
			<desc>Increment the content of the Y register by one</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>NF</prefixBits>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xc8</opcode>
			</opcodes>
			<doc>
				<p>
					Increment the Y register by one (binary).
				</p>
				<pre>
					Y &amp;lt;= Y+1
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The RS prefix determines the width of the operation. The NF flag
					allows
					to perform the operation
					without setting
					flags.
				</p>
			</doc>
		</operation>

		<operation>
			<name>CLD</name>
			<desc>Clear the decimal (D) flag</desc>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xd8</opcode>
			</opcodes>
			<doc>
				<p>
					Clear the decimal mode status flag.
				</p>
			</doc>
		</operation>

		<operation>
			<name>INX</name>
			<desc>Increment the content of the X register by one</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>NF</prefixBits>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xe8</opcode>
			</opcodes>
			<doc>
				<p>
					Increment the X register by one (binary).
				</p>
				<pre>
					X &amp;lt;= X+1
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The RS prefix determines the width of the operation. The NF flag
					allows
					to perform the operation
					without setting
					flags.
				</p>
			</doc>
		</operation>

		<operation>
			<name>DEX</name>
			<desc>Decrement the content of the X register by one</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>NF</prefixBits>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xca</opcode>
			</opcodes>
			<doc>
				<p>
					Decrement the X register by one (binary).
				</p>
				<pre>
					X &amp;lt;= X-1
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The RS prefix determines the width of the operation. The NF flag
					allows
					to perform the operation
					without setting
					flags.
				</p>
			</doc>
		</operation>

		<operation>
			<name>SED</name>
			<feature>bcd</feature>
			<desc>Set the decimal (D) flag</desc>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xf8</opcode>
			</opcodes>
			<doc>
				<p>
					Set the decimal mode status flag.
				</p>
			</doc>
		</operation>

		<operation>
			<name>NOP</name>
			<desc>No operation</desc>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xea</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x1a</opcode>
				<feature>undoc</feature>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x3a</opcode>
				<feature>undoc</feature>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x5a</opcode>
				<feature>undoc</feature>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x7a</opcode>
				<feature>undoc</feature>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xda</opcode>
				<feature>undoc</feature>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xfa</opcode>
				<feature>undoc</feature>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x80</opcode>
				<feature>undoc</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x04</opcode>
				<feature>undoc</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x14</opcode>
				<feature>undoc</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x34</opcode>
				<feature>undoc</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x44</opcode>
				<feature>undoc</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x54</opcode>
				<feature>undoc</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x64</opcode>
				<feature>undoc</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x74</opcode>
				<feature>undoc</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0xd4</opcode>
				<feature>undoc</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0xf4</opcode>
				<feature>undoc</feature>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0x0c</opcode>
				<feature>undoc</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0x1c</opcode>
				<feature>undoc</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0x3c</opcode>
				<feature>undoc</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0x5c</opcode>
				<feature>undoc</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0x7c</opcode>
				<feature>undoc</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0xdc</opcode>
				<feature>undoc</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0xfc</opcode>
				<feature>undoc</feature>
			</opcodes>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0x89</opcode>
				<feature>undoc</feature>
			</opcodes>
			<doc>
				<p>
					No Operation.
				</p>
			</doc>
		</operation>

		<!-- ################################# -->

		<operation>
			<name>LEA</name>
			<desc>Load Effective Address: compute the effective address and store
				it in the E (effective Address) register (always
				full width)
			</desc>
			<feature>65k</feature>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<opcodes>
				<addressingMode>zpy</addressingMode>
				<opcode>0xf6</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>absindyquad</addressingMode>
				<opcode>0x61</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>absxindquad</addressingMode>
				<opcode>0x71</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>absindy</addressingMode>
				<opcode>0x21</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>absxind</addressingMode>
				<opcode>0x31</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>rel</addressingMode>
				<opcode>0x11</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zpxind</addressingMode>
				<opcode>0xa1</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x46</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0xae</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zpindy</addressingMode>
				<opcode>0xb1</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zpindz</addressingMode>
				<opcode>0xb2</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absind</addressingMode>
				<opcode>0x32</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zpindzquad</addressingMode>
				<opcode>0xf2</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>absindquad</addressingMode>
				<opcode>0x72</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x56</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0xbf</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0xbe</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>relwide</addressingMode>
				<opcode>0x12</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zpindyquad</addressingMode>
				<opcode>0xe1</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zpxindquad</addressingMode>
				<opcode>0xf1</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zpindbyte</addressingMode>
				<opcode>0xa2</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zpindbytequad</addressingMode>
				<opcode>0xe2</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>absindbyte</addressingMode>
				<opcode>0x22</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>absindbytequad</addressingMode>
				<opcode>0x62</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Load the effective address given by the addressing mode into the
					E
					register (without accessing
					the memory pointed to
					by the
					parameter).
				</p>
				<pre>
					E &amp;lt;= EffectiveAddress
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The value stored in E is always in the natural (full) width of
					the
					processor.
				</p>
				<p>
					The AM and OF prefixes are interpreted as usually when computing
					the
					address.
				</p>
				<p>
					The memory and stack pointers used are the current ones when the
					user
					mode prefix is not set.
					When the user mode
					prefix is set in
					hypervisor mode, the memory and
					stack pointer is that of the
					user
					mode. When set in user mode an ABORT
					is triggered.
				</p>
				<p>
					With this approach you can use this in trap handling:
				</p>
				<pre>
					LEA.U S,$08 ; load user space address of offset 8 on the user
					mode stack
					LDA.U (E) ; load the value from user
					space
				</pre>
			</doc>
		</operation>

<!-- replaced by simply using LEA and PHE 
		<operation>
			<name>PEA</name>
			<desc>Push Effective Address: compute the effective address and push
				it onto the stack (always full width)
			</desc>
			<feature>65k</feature>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>UM</prefixBits>
			<opcodes>
				<addressingMode>absindyquad</addressingMode>
				<opcode>0x41</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>absxindquad</addressingMode>
				<opcode>0x51</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zpy</addressingMode>
				<opcode>0xd6</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>absindy</addressingMode>
				<opcode>0x01</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>absxind</addressingMode>
				<opcode>0x11</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>rel</addressingMode>
				<opcode>0x82</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zpxind</addressingMode>
				<opcode>0x81</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x86</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0xce</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zpindy</addressingMode>
				<opcode>0x91</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zpind</addressingMode>
				<opcode>0x92</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absind</addressingMode>
				<opcode>0x12</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zpindzquad</addressingMode>
				<opcode>0xd2</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>absindquad</addressingMode>
				<opcode>0x52</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x96</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0xdf</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0xde</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>relwide</addressingMode>
				<opcode>0x02</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zpindyquad</addressingMode>
				<opcode>0xc1</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zpxindquad</addressingMode>
				<opcode>0xd1</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Push the effective address given by the addressing mode onto the
					stack
					(without accessing
					the memory pointed to by
					the parameter).
				</p>
				<pre>
					Stack(SP- -) &amp;lt;= &gt;EffectiveAddress
					Stack(SP- -) &amp;lt;=
					&amp;lt;EffectiveAddress
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The value pushed is always in the natural (full) width of the
					processor.
				</p>
				<p>
					The AM and OF prefixes are interpreted as usually when computing
					the
					address.
				</p>
				<p>
					The memory and stack pointers used are the current ones when the
					user
					mode prefix is not set.
					When the user mode
					prefix is set in
					hypervisor mode, the memory and
					stack pointer is that of the
					user
					mode. When set in user mode an ABORT
					is triggered.
				</p>
				<p>
					Note that the stack used to actually store the address is always
					(no
					matter the user mode bit)
					the current stack!
				</p>
			</doc>
		</operation>
-->

		<!-- ################################# -->

		<operation>
			<name>MVN</name>
			<desc>Move block of data of size AC from XR to YR, count addresses
				down. All registers full size, interruptable
			</desc>
			<feature>65k10</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x04</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>

		<operation>
			<name>MVP</name>
			<desc>Move block of data of size AC from XR to YR, count addresses
				down. All registers full size, interruptable
			</desc>
			<feature>65k10</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x14</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>

		<operation>
			<name>FIL</name>
			<desc>Fill a memory area of size AC at address XR with a value from
				YR
			</desc>
			<prefixBits>RS</prefixBits>
			<feature>65k10</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x24</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>

		<!-- ################################# -->

		<operation>
			<name>CSW</name>
			<desc>Compare and SWap - compare memory with AC, and if matches, set to value from XR. AC is loaded with the value from the memory location.
			</desc>
			<prefixBits>UM</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>AM</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0xcc</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0xc6</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0xd6</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>zpindy</addressingMode>
				<opcode>0xc1</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0xde</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>


		<operation>
			<name>WBR</name>
			<desc>Write memory BaRrier: flushes dirty caches (globally, or for a
				specific, given location)
			</desc>
			<prefixBits>UM</prefixBits>
			<feature>65k10</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x74</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0xfc</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>

		<operation>
			<name>RBR</name>
			<desc>Read memory BaRrier: invalidates cache content (globally, or
				for
				a specific, given location)
			</desc>
			<prefixBits>UM</prefixBits>
			<feature>65k10</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x64</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0xec</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>

		<operation>
			<name>SCA</name>
			<desc>Store conditional - store the contents of AC into a memory
				location, if location has not been accessed since
				LLA
				with same
				address (and no other LLA in same thread)
			</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>UM</prefixBits>
			<feature>65k10</feature>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0x2c</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>

		<operation>
			<name>LLA</name>
			<desc>Load linked AC - load the content from a memory location into
				accumulator, optimistic-locking the address for
				SCA
			</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<feature>65k10</feature>
			<opcodes>
				<addressingMode>eind</addressingMode>
				<opcode>0x3c</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>

		<operation>
			<name>BCN</name>
			<desc>Bit Count: counts 1-bits in AC or in given location, stores
				number of 1-bits back in AC
			</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>NF</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>A</addressingMode>
				<opcode>0xb4</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<!--opcodes> <addressingMode>eind</addressingMode> <opcode>0xbc</opcode> <oppage>EXT</oppage> </opcodes -->
		</operation>

		<operation>
			<name>BSW</name>
			<desc>Bit Swap: exchanges bit 0 with bit W-1, bit 1 with bit W-2 and
				so on.
			</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>NF</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>A</addressingMode>
				<opcode>0xf4</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>

		<operation>
			<name>HBS</name>
			<desc>Highest Bit Set: Determines the number of the highest bit that
				is set to one.
			</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>NF</prefixBits>
			<feature>65k10</feature>
			<opcodes>
				<addressingMode>A</addressingMode>
				<opcode>0x84</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>

		<operation>
			<name>HBC</name>
			<desc>Highest Bit Clear: Determines the number of the highest bit
				that
				is set to zero.
			</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>NF</prefixBits>
			<feature>65k10</feature>
			<opcodes>
				<addressingMode>A</addressingMode>
				<opcode>0x94</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>

		<operation>
			<name>PSH</name>
			<desc>Push contents of all registers (A, X, Y, B, E) onto the stack
			</desc>
			<prefixBits>UM</prefixBits>
			<feature>65k10</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x44</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Push the content of all registers on the stack.
				</p>
				<pre>
					Stack(SP--) &amp;lt;= A
					Stack(SP--) &amp;lt;= X
					Stack(SP--)
					&amp;lt;= Y
					Stack(SP--) &amp;lt;= B
					Stack(SP--)
					&amp;lt;= E
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					All registers are stored in full (natural) width.
				</p>
				<p>
					The stack pointer used is the one of the current stack if the UM
					prefix
					is not set.
					If UM is set and the opcode is
					executed in
					hypervisor mode, the stack
					pointer used is the
					user mode stack
					pointer and the value is stored in user mode
					memory. If
					executed in
					user mode with UM set an ABORT exception is triggered.
				</p>
			</doc>
		</operation>

		<operation>
			<name>PLL</name>
			<desc>Pull the contents of all registers from the stack</desc>
			<prefixBits>UM</prefixBits>
			<feature>65k10</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x54</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Pull the value of all registers from the stack.
				</p>
				<pre>
					B &amp;lt;= Stack(++SP)
					E &amp;lt;= Stack(++SP)
					Y &amp;lt;=
					Stack(++SP)
					X &amp;lt;= Stack(++SP)
					A &amp;lt;=
					Stack(++SP)
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					All registers are restored in full (natural) width. Flags are not
					set.
				</p>
				<p>
					The stack pointer used is the one of the current stack if the UM
					prefix
					is not set.
					If UM is set and the opcode is
					executed in
					hypervisor mode, the stack
					pointer used is the
					user mode stack
					pointer and the value is stored in user mode
					memory. If
					executed in
					user mode with UM set an ABORT exception is triggered.
				</p>
			</doc>
		</operation>

		<!-- ################################# -->

		<operation>
			<name>NEG</name>
			<synonym>INV</synonym>
			<desc>negate / invert AC, i.e. set AC to the 2s-complement of AC</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>NF</prefixBits>
			<opcodes>
				<addressingMode>A</addressingMode>
				<opcode>0xa4</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>A</addressingMode>
				<opcode>0x42</opcode>
				<feature>ce02</feature>
			</opcodes>
		</operation>

		<operation>
			<name>SWP</name>
			<desc>swap upper and lower half of the operand
			</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>NF</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>A</addressingMode>
				<opcode>0xe4</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Swap upper and lower part nibble / byte / word / long word of a
					byte / word / long / quad (longlong) operand in
					Accumulator
				</p>
			</doc>
		</operation>

		<operation>
			<name>EXT</name>
			<desc>Extend a value in AC from RS to the full size. Setting LE
				defines the type of extension.
			</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>NF</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>A</addressingMode>
				<opcode>0xc4</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>

		<!-- ################################# -->

		<operation>
			<name>LDE</name>
			<desc>Load E with an immediate value</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>NF</prefixBits>
			<default-le>sign</default-le>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0x39</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Read the operand and store it in the E register. Set the flags
					appropriately.
				</p>
				<pre>
					N &amp;lt;= Operand(7)
					Z &amp;lt;= Z(Operand)
					E &amp;lt;= Operand
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The LE and RS prefixes are evaluated by the addressing modes.
				</p>
				<p>
					Note that the default load extension is "sign-extended".
				</p>
				<p>
					The NF prefix lets the flags unmodified.
				</p>
			</doc>
		</operation>

		<operation>
			<name>LDB</name>
			<desc>Load B with an immediate value</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<default-le>sign</default-le>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0x59</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Read the operand and store it in the B register. Set the flags
					appropriately.
				</p>
				<pre>
					N &amp;lt;= Operand(7)
					Z &amp;lt;= Z(Operand)
					B &amp;lt;= Operand
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The LE and RS prefixes are evaluated by the addressing modes.
				</p>
				<p>
					Note that the default load extension is "sign-extended".
				</p>
				<p>
					The NF prefix lets the flags unmodified.
				</p>
			</doc>
		</operation>


		<operation>
			<name>PHE</name>
			<desc>Push E onto stack (always full width)</desc>
			<prefixBits>UM</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x08</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Push the content of the E register on the stack.
				</p>
				<pre>
					Stack(SP--) &amp;lt;= E
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The value stored is always in the natural width of the processor
					(mode).
				</p>
				<p>
					The stack pointer used is the one of the current stack if the UM
					prefix
					is not set.
					If UM is set and the opcode is
					executed in
					hypervisor mode, the stack
					pointer used is the
					user mode stack
					pointer and the value is stored in user mode
					memory. If
					executed in
					user mode with UM set an ABORT exception is triggered.
				</p>
			</doc>
		</operation>

		<operation>
			<name>PLE</name>
			<desc>Pull E from stack (full width)</desc>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x28</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Pull the value of the E register from the stack.
				</p>
				<pre>
					E &amp;lt;= Stack(++SP)
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The value retrieved is always in the natural width of the
					processor
					(mode).
				</p>
				<p>
					The stack pointer used is the one of the current stack if the UM
					prefix
					is not set.
					If UM is set and the opcode is
					executed in
					hypervisor mode, the stack
					pointer used is the
					user mode stack
					pointer and the value is stored in user mode
					memory. If
					executed in
					user mode with UM set an ABORT exception is triggered.
				</p>
			</doc>
		</operation>

		<operation>
			<name>PHB</name>
			<desc>Push B onto stack (full width)</desc>
			<prefixBits>UM</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x48</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Push the content of the B register on the stack.
				</p>
				<pre>
					Stack(SP--) &amp;lt;= B
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The value stored is always in the natural width of the processor
					(mode).
				</p>
				<p>
					The stack pointer used is the one of the current stack if the UM
					prefix
					is not set.
					If UM is set and the opcode is
					executed in
					hypervisor mode, the stack
					pointer used is the
					user mode stack
					pointer and the value is stored in user mode
					memory. If
					executed in
					user mode with UM set an ABORT exception is triggered.
				</p>
			</doc>
		</operation>

		<operation>
			<name>PRB</name>
			<desc>Push and Replace Base register: Push base offset register to
				the
				stack, then transfer E-register to the base
				register
			</desc>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x58</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>

		<operation>
			<name>PLB</name>
			<desc>Pull B from stack (full width)</desc>
			<prefixBits>UM</prefixBits>
			<prefixBits>NF</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x68</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<doc>
				<p>
					Pull the value of the B register from the stack.
				</p>
				<pre>
					B &amp;lt;= Stack(++SP)
				</pre>
			</doc>
			<doc mode="65k">
				<p>
					The value retrieved is always in the natural width of the
					processor
					(mode).
				</p>
				<p>
					The stack pointer used is the one of the current stack if the UM
					prefix
					is not set.
					If UM is set and the opcode is
					executed in
					hypervisor mode, the stack
					pointer used is the
					user mode stack
					pointer and the value is stored in user mode
					memory. If
					executed in
					user mode with UM set an ABORT exception is triggered.
				</p>
			</doc>
		</operation>



		<operation>
			<name>TPA</name>
			<desc>Transfer Program counter to Accumulator</desc>
			<prefixBits>NF</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xc8</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>

		<operation>
			<name>TBA</name>
			<desc>Transfer base register B to Accumulator</desc>
			<prefixBits>NF</prefixBits>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xf8</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x7b</opcode>
				<feature>ce02</feature>
			</opcodes>
		</operation>

		<operation>
			<name>TEA</name>
			<desc>Transfer E register to Accumulator</desc>
			<prefixBits>NF</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x98</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>

		<operation>
			<name>TAE</name>
			<desc>Transfer AC to E register</desc>
			<prefixBits>NF</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>RS</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x88</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>

		<operation>
			<name>TYS</name>
			<desc>Transfer Y to stack pointer</desc>
			<prefixBits>LE</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>UM</prefixBits>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x9a</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x2b</opcode>
				<feature>ce02</feature>
			</opcodes>
		</operation>

		<operation>
			<name>TSY</name>
			<desc>Transfer stack pointer to Y</desc>
			<prefixBits>NF</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xba</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x0b</opcode>
				<feature>ce02</feature>
			</opcodes>
		</operation>

		<operation>
			<name>TAB</name>
			<desc>Transfer AC to B register</desc>
			<prefixBits>NF</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>RS</prefixBits>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xe8</opcode>
				<oppage>EXT</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x5b</opcode>
				<feature>ce02</feature>
			</opcodes>

		</operation>

		<operation>
			<name>TEB</name>
			<desc>Transfer E to B register (full width)</desc>
			<prefixBits>NF</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xea</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>

<!-- replace with LEA 0,B ? -->
		<operation>
			<name>TBE</name>
			<desc>Transfer content of B register into E register (full width)
			</desc>
			<prefixBits>NF</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xfa</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>

		<!-- ################################# -->

		<operation>
			<name>SEB</name>
			<desc>Swap E register with B register. Always done full width, no
				flags set.
			</desc>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xb8</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>

		<operation>
			<name>SAB</name>
			<desc>Swap A register with B register. Always done full width, no
				flags set.
			</desc>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xa8</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>

		<operation>
			<name>SAE</name>
			<desc>Swap AC with E register. Always done full width, no flags set.
			</desc>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xd8</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>

		<operation>
			<name>SAX</name>
			<desc>Swap AC with X register. Always done full width, no flags set.
			</desc>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x84</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>

		<operation>
			<name>SAY</name>
			<desc>Swap AC with Y register. Always done full width, no flags set.
			</desc>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xda</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>


		<operation>
			<name>SXY</name>
			<desc>Swap X with Y register. Always done full width, no flags set.
			</desc>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x94</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>


		<!-- ################################# -->
		<!-- NMOS 6502 undocumented opcodes -->

		<operation>
			<name>ADE</name>
			<desc>Add value to E register</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>NF</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0x25</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>A</addressingMode>
				<opcode>0x35</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>

<!-- replace with LEA / TES 
		<operation>
			<name>ADS</name>
			<desc>Add value to stack pointer</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>NF</prefixBits>
			<prefixBits>UM</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0x45</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>A</addressingMode>
				<opcode>0x55</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>
-->

<!-- replace with LEA / TEB 
		<operation>
			<name>ADB</name>
			<desc>Add value to B register</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>NF</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0x65</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>A</addressingMode>
				<opcode>0x75</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>
-->

		<operation>
			<name>SBE</name>
			<desc>Subtract value from E register</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>NF</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0xa5</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>A</addressingMode>
				<opcode>0xb5</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>

<!-- replace with LEA / TES 
		<operation>
			<name>SBS</name>
			<desc>Subtract value from stack pointer</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>NF</prefixBits>
			<prefixBits>UM</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0xc5</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>A</addressingMode>
				<opcode>0xd5</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>
 -->

<!-- replace with LEA / TEB 
		<operation>
			<name>SBB</name>
			<desc>Substract value from B register</desc>
			<prefixBits>RS</prefixBits>
			<prefixBits>LE</prefixBits>
			<prefixBits>NF</prefixBits>
			<feature>65k</feature>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0xe5</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>A</addressingMode>
				<opcode>0xf5</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>
-->

		<operation>
			<name>ASO</name>
			<synonym>SLO</synonym>
			<desc>ASL operand and OR with AC; this opcode is undocumented.</desc>
			<feature>undoc</feature>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0x0f</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0x1f</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0x1b</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x07</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x17</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpxind</addressingMode>
				<opcode>0x03</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindy</addressingMode>
				<opcode>0x13</opcode>
			</opcodes>
		</operation>

		<operation>
			<name>RLA</name>
			<desc>ROL operand and AND with AC; this opcode is undocumented.</desc>
			<feature>undoc</feature>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0x2f</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0x3f</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0x3b</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x27</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x37</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpxind</addressingMode>
				<opcode>0x23</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindy</addressingMode>
				<opcode>0x33</opcode>
			</opcodes>
		</operation>

		<operation>
			<name>LSE</name>
			<synonym>SRE</synonym>
			<desc>LSR operand and EOR with AC; this opcode is undocumented.</desc>
			<feature>undoc</feature>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0x4f</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0x5f</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0x5b</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x47</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x57</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpxind</addressingMode>
				<opcode>0x43</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindy</addressingMode>
				<opcode>0x53</opcode>
			</opcodes>
		</operation>

		<operation>
			<name>RRA</name>
			<desc>ROR operand and ADC with AC; this opcode is undocumented.</desc>
			<feature>undoc</feature>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0x6f</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0x7f</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0x7b</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x67</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x77</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpxind</addressingMode>
				<opcode>0x63</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindy</addressingMode>
				<opcode>0x73</opcode>
			</opcodes>
		</operation>

		<operation>
			<name>SAX</name>
			<desc>Store the result of X AND A in the given address, without changing flags; this opcode is undocumented.</desc>
			<feature>undoc</feature>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0x8f</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x87</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpy</addressingMode>
				<opcode>0x97</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpxind</addressingMode>
				<opcode>0x83</opcode>
			</opcodes>
		</operation>

		<operation>
			<name>LAX</name>
			<desc>Load both AC and XR with the contents loaded from memory; this opcode is undocumented.</desc>
			<feature>undoc</feature>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0xaf</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0xbf</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0xa7</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpy</addressingMode>
				<opcode>0xb7</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpxind</addressingMode>
				<opcode>0xa3</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindy</addressingMode>
				<opcode>0xb3</opcode>
			</opcodes>
		</operation>

		<operation>
			<name>DCM</name>
			<synonym>DCP</synonym>
			<desc>DEC the content of a memory location, then CMP the result with AC; this opcode is undocumented.</desc>
			<feature>undoc</feature>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0xcf</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0xdf</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0xdb</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0xc7</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0xd7</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpxind</addressingMode>
				<opcode>0xc3</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindy</addressingMode>
				<opcode>0xd3</opcode>
			</opcodes>
		</operation>

		<operation>
			<name>INS</name>
			<synonym>ISC</synonym>
			<desc>INC the content of a memory location, then SBC the result from AC; this opcode is undocumented.</desc>
			<feature>undoc</feature>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0xef</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0xff</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0xfb</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0xe7</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0xf7</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpxind</addressingMode>
				<opcode>0xe3</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindy</addressingMode>
				<opcode>0xf3</opcode>
			</opcodes>
		</operation>

		<operation>
			<name>ALR</name>
			<desc>AND the content of AC with an immediate value, then LSR the result; this opcode is undocumented.</desc>
			<feature>undoc</feature>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0x4b</opcode>
			</opcodes>
		</operation>

		<operation>
			<name>ANE</name>
			<desc>Mostly transfer the value of XR to AC, then AND AC with an immediate value; this opcode is undocumented.</desc>
			<feature>undoc</feature>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0x8b</opcode>
			</opcodes>
			<doc>
				<pre>
					A = (A | #$EE) &amp; X &amp; #byte
					same as
					A = ((A &amp; #$11 &amp; X) | (#$EE &amp; X)) &amp; #byte
				</pre>
				<p>
					The internal parameter $11 may occasionally be $10, $01, or even $00 in real systems. This may depend
					on the state
					of the data left on the external data bus. See "64doc.txt"
				</p>
			</doc>
		</operation>

		<operation>
			<name>LXA</name>
			<desc>OR the AC with #$EE, AND the result with an immediate value and store the result in AC and XR; this opcode is
				undocumented.
			</desc>
			<feature>undoc</feature>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0xab</opcode>
			</opcodes>
			<doc>
				<p>This operation looks similar to ANE, just that it stores the result in AC and XR instead of AC only.</p>
			</doc>
		</operation>

		<operation>
			<name>SBX</name>
			<desc>AND the AC and XR registers, substract an immediate value from that and store the result in XR. ; this opcode
				is undocumented.
			</desc>
			<feature>undoc</feature>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0xcb</opcode>
			</opcodes>
			<doc>
				<p>The substraction works similar to CMP in that no flags are set. It also has no decimal mode, as it
					is a combination of CMP and DEX (the latter to store the result). For details see 64doc.txt.
				</p>
			</doc>
		</operation>


		<operation>
			<name>HLT</name>
			<desc>Crash the processor.</desc>
			<feature>undoc</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x02</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x12</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x22</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x32</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x42</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x52</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x62</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x72</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x82</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x92</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xb2</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xc2</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xd2</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xe2</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xf2</opcode>
			</opcodes>
			<doc>
				<p>When this opcode is executed, the NMOS processor stops execution. No hardware interrupts will be
					executed also.
					This is due to the fact that the internal state engine looses its "running bit" and
					just stops running.
				</p>
				<p>Opcodes 0x82, 0xc2 and 0xe2 are sometimes listed as "NOP, Jams rarely"</p>
			</doc>
		</operation>

		<operation>
			<name>SHS</name>
			<desc>AND the AC and XR registers, transfer the result to the stack pointer; this opcode is undocumented.</desc>
			<feature>undoc</feature>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0x9b</opcode>
			</opcodes>
			<doc>
				<p>SHA and TXS where, X is replaced by (A &amp; X).</p>
				<p>Note: the value to be stored is also copied to ADDR_HI if page boundary is crossed.</p>
			</doc>
		</operation>

		<operation>
			<name>SHY</name>
			<desc>AND the content of the YR registers with the high address byte plus one and store in memory; this opcode is
				undocumented.
			</desc>
			<feature>undoc</feature>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0x9c</opcode>
			</opcodes>
			<doc>
				<pre>
					Store (Y &amp; (ADDR_HI + 1))
				</pre>
			</doc>
		</operation>

		<operation>
			<name>SHX</name>
			<desc>AND the content of the XR registers with the high address byte plus one and store in memory; this opcode is
				undocumented.
			</desc>
			<feature>undoc</feature>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0x9e</opcode>
			</opcodes>
			<doc>
				<pre>
					Store (X &amp; (ADDR_HI + 1))
				</pre>
			</doc>
		</operation>

		<operation>
			<name>SHA</name>
			<synonym>AXA</synonym>
			<desc>AND the content of the AC, XR registers with the high address byte plus one and store in memory; this opcode is
				undocumented.
			</desc>
			<feature>undoc</feature>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0x9f</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zpindy</addressingMode>
				<opcode>0x93</opcode>
			</opcodes>
			<doc>
				<pre>
					Store (A &amp; X &amp; (ADDR_HI + 1))
				</pre>
			</doc>
		</operation>

		<operation>
			<name>ANC</name>
			<desc>AND the content of the AC with an immediate value and move bit 7 into the carry flag; this opcode is
				undocumented.
			</desc>
			<feature>undoc</feature>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x0b</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x2b</opcode>
			</opcodes>
		</operation>

		<operation>
			<name>LAS</name>
			<desc>AND the content of the memory location with the stack pointer and store in AC, XR, and the stack pointer; this
				opcode is undocumented.
			</desc>
			<feature>undoc</feature>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0xbb</opcode>
			</opcodes>
		</operation>

		<operation>
			<name>ARR</name>
			<desc>Weird combination of AND and ROR; this
				opcode is undocumented.
			</desc>
			<feature>undoc</feature>
			<opcodes>
				<addressingMode>absy</addressingMode>
				<opcode>0x6b</opcode>
			</opcodes>
			<doc>
				<p>This operation is not the harmless combination of AND and ROR: it affects the V-flag and has
					a specific decimal mode. See 64doc.txt for more details.
				</p>
			</doc>
		</operation>


		<!-- ################################# -->
		<!-- Rockwell CMOS Bit test/set/branch operations -->

		<operation>
			<name>RMB</name>
			<desc>Reset memory bit</desc>
			<feature>rcmos</feature>
			<!-- repeatedly expand with opcode bits defined in the order given here -->
			<expand>0x70</expand>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x07</opcode>
				<feature>rcmos_bbx</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x07</opcode>
				<oppage>QUICK</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0x06</opcode>
				<oppage>QUICK</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x05</opcode>
				<oppage>QUICK</oppage>
				<feature>65k</feature>
			</opcodes>
			<doc>
				<p>
					Examine the operand value, and clear the given bit in it.
					The Z status register bit is set to the previous value of the memory bit.
				</p>
			</doc>
		</operation>

		<operation>
			<name>SMB</name>
			<desc>Set memory bit</desc>
			<feature>rcmos</feature>
			<!-- repeatedly expand with opcode bits defined in the order given here -->
			<expand>0x70</expand>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x87</opcode>
				<feature>rcmos_bbx</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x87</opcode>
				<oppage>QUICK</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0x86</opcode>
				<oppage>QUICK</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x85</opcode>
				<oppage>QUICK</oppage>
				<feature>65k</feature>
			</opcodes>
			<doc>
				<p>
					Examine the operand value, and set the given bit in it.
					The Z status register bit is set to the previous value of the memory bit.
				</p>
			</doc>
		</operation>

		<operation>
			<name>BBR</name>
			<desc>Branch on bit reset</desc>
			<feature>rcmos</feature>
			<expand>0x70</expand>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>RS</prefixBits>
			<opcodes>
				<addressingMode>zprel</addressingMode>
				<opcode>0x0f</opcode>
				<feature>rcmos_bbx</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zprel</addressingMode>
				<opcode>0x0f</opcode>
				<oppage>QUICK</oppage>
				<feature>65k</feature>
			</opcodes>
			<doc>
				<p>
					Examine the operand value, and check the given bit. If the bit is cleared, branch to the given (relative)
					address.
				</p>
			</doc>
		</operation>

		<operation>
			<name>BBS</name>
			<desc>Branch on bit set</desc>
			<feature>rcmos</feature>
			<expand>0x70</expand>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>UM</prefixBits>
			<prefixBits>RS</prefixBits>
			<opcodes>
				<addressingMode>zprel</addressingMode>
				<opcode>0x8f</opcode>
				<feature>rcmos_bbx</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zprel</addressingMode>
				<opcode>0x8f</opcode>
				<oppage>QUICK</oppage>
				<feature>65k</feature>
			</opcodes>
			<doc>
				<p>
					Examine the operand value, and check the given bit. If the bit is set, branch to the given (relative) address.
				</p>
			</doc>
		</operation>

		<!-- ################################# -->
		<!-- 65ce02 opcodes -->

		<operation>
			<name>CLE</name>
			<desc>Clear Stack Extend disable bit.</desc>
			<feature>ce02</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x02</opcode>
			</opcodes>
		</operation>

		<operation>
			<name>SEE</name>
			<desc>Set Stack Extend disable bit.</desc>
			<feature>ce02</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x03</opcode>
			</opcodes>
		</operation>

		<operation>
			<name>AUG</name>
			<desc>Augmentation opcode for later extensions</desc>
			<feature>ce02</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x5c</opcode>
			</opcodes>
		</operation>


		<operation>
			<name>INW</name>
			<desc>Increment a word value</desc>
			<feature>ce02</feature>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0xe3</opcode>
			</opcodes>
		</operation>

		<operation>
			<name>DEW</name>
			<desc>Decrement a word value</desc>
			<feature>ce02</feature>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0xc3</opcode>
			</opcodes>
		</operation>

		<operation>
			<name>INZ</name>
			<desc>Increment Z register</desc>
			<feature>cmos_indz</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x1b</opcode>
				<feature>ce02</feature>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x18</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>

		<operation>
			<name>DEZ</name>
			<desc>Decrement Z register</desc>
			<feature>cmos_indz</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x3b</opcode>
				<feature>ce02</feature>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x38</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>

		<operation>
			<name>ASW</name>
			<desc>Arithmethic Shift left Word</desc>
			<feature>ce02</feature>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0xcb</opcode>
			</opcodes>
		</operation>

		<operation>
			<name>ROW</name>
			<desc>Rotate left Word</desc>
			<feature>ce02</feature>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0xeb</opcode>
			</opcodes>
		</operation>

		<operation>
			<name>LDZ</name>
			<desc>Load Z register with a value</desc>
			<feature>cmos_indz</feature>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0xa3</opcode>
				<feature>ce02</feature>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0xbb</opcode>
				<feature>ce02</feature>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0xab</opcode>
				<feature>ce02</feature>
			</opcodes>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0x99</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>absx</addressingMode>
				<opcode>0xbc</opcode>
				<oppage>EXT</oppage>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0xac</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>

		<operation>
			<name>PHW</name>
			<desc></desc>
			<feature>ce02</feature>
			<opcodes>
				<addressingMode>imm2</addressingMode>
				<opcode>0xf4</opcode>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0xfc</opcode>
			</opcodes>
		</operation>

		<operation>
			<name>TAZ</name>
			<desc>Transfer AC to Z Register</desc>
			<feature>cmos_indz</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x4b</opcode>
				<feature>ce02</feature>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xaa</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>

		<operation>
			<name>TZA</name>
			<desc>Transfer Z Register to AC</desc>
			<feature>cmos_indz</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x6b</opcode>
				<feature>ce02</feature>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x8a</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>

		<operation>
			<name>PHZ</name>
			<desc>Push Z Register onto stack</desc>
			<feature>cmos_indz</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xdb</opcode>
				<feature>ce02</feature>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x5a</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>

		<operation>
			<name>PLZ</name>
			<desc>Pull Z Register from stack</desc>
			<feature>cmos_indz</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xfb</opcode>
				<feature>ce02</feature>
			</opcodes>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x7a</opcode>
				<oppage>EXT</oppage>
			</opcodes>
		</operation>


		<!-- ################################## -->
		<!-- 65816 opcodes -->

		<operation>
			<name>REP</name>
			<desc>Reset processor status bits</desc>
			<feature>816</feature>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0xc2</opcode>
			</opcodes>
			<doc>
				<p>
					Reset the processor status bits that are set in the immediate operand (all flags but the B-flag)
				</p>
			</doc>
		</operation>

		<operation>
			<name>SEP</name>
			<desc>Set processor status bits</desc>
			<feature>816</feature>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0xe2</opcode>
			</opcodes>
			<doc>
				<p>
					Set the processor status bits that are set in the immediate operand (all flags but the B-flag)
				</p>
			</doc>
		</operation>

		<operation>
			<name>STP</name>
			<desc>Stop processor</desc>
			<feature>816</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xdb</opcode>
			</opcodes>
			<doc>
				<p>
					Stop the processor.
				</p>
			</doc>
		</operation>

		<operation>
			<name>WAI</name>
			<desc>Wait for interrupt</desc>
			<feature>816</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xcb</opcode>
			</opcodes>
			<doc>
				<p>
					Stop the processor and wait for an interrupt, where execution resumes.
				</p>
			</doc>
		</operation>

		<operation>
			<name>XCE</name>
			<desc>Exchange Carry and Emulation Flags</desc>
			<feature>816</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xfb</opcode>
			</opcodes>
		</operation>

		<operation>
			<name>XBA</name>
			<desc>Exchange A and B 8-bit accumulators (i.e. both halfs of the 16 bit AC)</desc>
			<feature>816</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xeb</opcode>
			</opcodes>
		</operation>

		<operation>
			<name>WDM</name>
			<desc>Reserved for future expansion</desc>
			<feature>816</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x42</opcode>
			</opcodes>
		</operation>

		<operation>
			<name>TDC</name>
			<desc>Transfer the contents of direct page register into the 16-bit AC</desc>
			<feature>816</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x7b</opcode>
			</opcodes>
			<doc>
				<p>
					Transfer the value of the DPR to the A register (16 bit)
				</p>
				<pre>
					A &amp;lt;= DPR
				</pre>
			</doc>
		</operation>

		<operation>
			<name>TCD</name>
			<desc>Transfer the contents of the 16-bit AC into the 16-bit direct page register</desc>
			<feature>816</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x5b</opcode>
			</opcodes>
			<doc>
				<p>
					Transfer the value of the A to the DPR register (16 bit)
				</p>
				<pre>
					DPR &amp;lt;= A
				</pre>
			</doc>
		</operation>


		<operation>
			<name>TSC</name>
			<desc>Transfer the contents of 16-bit stack pointer into the 16-bit AC</desc>
			<feature>816</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x3b</opcode>
			</opcodes>
			<doc>
				<p>
					Transfer the value of the S to the A register (16 bit)
				</p>
				<pre>
					A &amp;lt;= S
				</pre>
			</doc>
		</operation>

		<operation>
			<name>TCS</name>
			<desc>Transfer the contents of 16-bit AC into the 16-bit stack pointer</desc>
			<feature>816</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x1b</opcode>
			</opcodes>
			<doc>
				<p>
					Transfer the value of the A to the S register (16 bit)
				</p>
				<pre>
					S &amp;lt;= A
				</pre>
			</doc>
		</operation>


		<operation>
			<name>TXY</name>
			<desc>Transfer the contents of X into the Y register</desc>
			<feature>816</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x9b</opcode>
			</opcodes>
			<doc>
				<p>
					Transfer the value of the X to the Y register
				</p>
				<pre>
					Y &amp;lt;= X
				</pre>
			</doc>
		</operation>

		<operation>
			<name>TYX</name>
			<desc>Transfer the contents of Y into the X register</desc>
			<feature>816</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xbb</opcode>
			</opcodes>
			<doc>
				<p>
					Transfer the value of the Y to the X register
				</p>
				<pre>
					X &amp;lt;= Y
				</pre>
			</doc>
		</operation>

		<operation>
			<name>PEI</name>
			<desc>Push effective indirect address (16 bit)</desc>
			<feature>816</feature>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0xd4</opcode>
			</opcodes>
			<doc>
				<p>
					Push the address to the stack that would result as effective operand address if the operand were used in an indirect
					addressing mode. I.e. read the value at the given direct page operand, and push it onto the stack (as 16 bit value).
				</p>
				<pre>
					Stack(SP--) &amp;lt;= (operand)
				</pre>
			</doc>
		</operation>

		<operation>
			<name>PEA</name>
			<desc>Push effective address (16 bit)</desc>
			<feature>816</feature>
			<opcodes>
				<addressingMode>imm2</addressingMode>
				<opcode>0xf4</opcode>
			</opcodes>
			<doc>
				<p>
					Push the immediate value from the operand onto the stack (as 16 bit value).
				</p>
				<pre>
					Stack(SP--) &amp;lt;= operand
				</pre>
			</doc>
		</operation>

		<operation>
			<name>PER</name>
			<desc>Push effective relative address (16 bit)</desc>
			<feature>816</feature>
			<opcodes>
				<addressingMode>relw</addressingMode>
				<opcode>0x62</opcode>
			</opcodes>
			<doc>
				<p>
					Take the address given as parameter, add the current program counter, and push the resulting
					address onto the stack (as 16 bit value). This is similar to pushing the offset of a branch instruction.
				</p>
				<pre>
					Stack(SP--) &amp;lt;= operand - PC + 1
				</pre>
			</doc>
		</operation>


		<operation>
			<name>PLB</name>
			<desc>Pull data bank register DBR from stack</desc>
			<feature>816</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0xab</opcode>
			</opcodes>
			<doc>
				<p>
					Pull the value of the data bank register register from the stack.
				</p>
				<pre>
					DBR &amp;lt;= Stack(++SP)
				</pre>
			</doc>
		</operation>

		<operation>
			<name>PHB</name>
			<desc>Push data bank register DBR to stack</desc>
			<feature>816</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x8b</opcode>
			</opcodes>
			<doc>
				<p>
					Push the value of the data bank register register to the stack.
				</p>
				<pre>
					Stack(SP--) &amp;lt;= DBR
				</pre>
			</doc>
		</operation>

		<operation>
			<name>PLD</name>
			<desc>Pull direct page register from stack</desc>
			<feature>816</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x2b</opcode>
			</opcodes>
			<doc>
				<p>
					Pull the value of the direct page register register from the stack.
				</p>
				<pre>
					DPR &amp;lt;= Stack(++SP)
				</pre>
			</doc>
		</operation>

		<operation>
			<name>PHD</name>
			<desc>Push direct page register to stack</desc>
			<feature>816</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x0b</opcode>
			</opcodes>
			<doc>
				<p>
					Push the value of the direct page register register to the stack.
				</p>
				<pre>
					Stack(SP--) &amp;lt;= DPR
				</pre>
			</doc>
		</operation>

		<operation>
			<name>PHK</name>
			<desc>Push program bank register to stack</desc>
			<feature>816</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x4b</opcode>
			</opcodes>
			<doc>
				<p>
					Push the value of the program bank register register to the stack.
				</p>
				<pre>
					Stack(SP--) &amp;lt;= PBR
				</pre>
			</doc>
		</operation>

		<operation>
			<name>RTL</name>
			<desc>Return from subroutine long</desc>
			<feature>816</feature>
			<opcodes>
				<addressingMode>implied</addressingMode>
				<opcode>0x6b</opcode>
			</opcodes>
		</operation>

		<operation>
			<name>COP</name>
			<desc>Coprocessor call</desc>
			<feature>816</feature>
			<opcodes>
				<addressingMode>imm</addressingMode>
				<opcode>0x02</opcode>
			</opcodes>
			<doc>
				<p>
					The COP instruction pushes the K register (i.e. the program bank register) onto the stack (in native mode only),
					then the 16 bit address of the COP instruction plus 2, then the status register. The COP instruction is very 
					similar to the BRK instruction.
				</p>
			</doc>
		</operation>

		<operation>
			<name>MVN</name>
			<desc>Move block of data (count index down) 
			</desc>
			<feature>816</feature>
			<opcodes>
				<addressingMode>dimm</addressingMode>
				<opcode>0x54</opcode>
			</opcodes>
			<doc>
				<p>
				 x=source address, y=destination address, ac=number of bytes; the two immediate parameters
				 are the destination and source data bank numbers respectively.
				</p>
			</doc>
		</operation>

		<operation>
			<name>MVP</name>
			<desc>Move block of data (count index up)
			</desc>
			<feature>816</feature>
			<opcodes>
				<addressingMode>dimm</addressingMode>
				<opcode>0x44</opcode>
			</opcodes>
			<doc>
				<p>
				 x=source address, y=destination address, ac=number of bytes; the two immediate parameters
				 are the destination and source data bank numbers respectively.
				</p>
			</doc>
		</operation>

		<!-- QUICK opcode page, mostly with a 3-bit param encoded in the opcode -->
		
		<operation>
			<name>TMB</name>
			<desc>Test memory bit</desc>
			<feature>65k</feature>
			<!-- repeatedly expand with opcode bits defined in the order given here -->
			<expand>0x70</expand>
			<prefixBits>AM</prefixBits>
			<prefixBits>OF</prefixBits>
			<prefixBits>UM</prefixBits>
			<opcodes>
				<addressingMode>zp</addressingMode>
				<opcode>0x03</opcode>
				<oppage>QUICK</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>abs</addressingMode>
				<opcode>0x02</opcode>
				<oppage>QUICK</oppage>
				<feature>65k</feature>
			</opcodes>
			<opcodes>
				<addressingMode>zpx</addressingMode>
				<opcode>0x01</opcode>
				<oppage>QUICK</oppage>
				<feature>65k</feature>
			</opcodes>
			<doc>
				<p>
					Examine the operand value, and set the Z status register bit from the memory value.
				</p>
			</doc>
		</operation>

		
	</operations>


	<!-- ################################# -->

	<syntaxes>
		<syntax>
			<id>implied</id>
			<desc>Empty syntax, either AC or implied addressing modes.</desc>
			<simplesyntax></simplesyntax>
			<mode>
				<!--width>0</width -->
				<addrMode>A</addrMode>
			</mode>
			<mode>
				<!--width>0</width -->
				<addrMode>implied</addrMode>
			</mode>
		</syntax>

		<syntax>
			<id>immediate</id>
			<desc>Immediate addressing: operand directly follows the opcode.
			</desc>
			<simplesyntax>#&lt;operand&gt;</simplesyntax>
			<mode>
				<!--width>1</width -->
				<addrMode>imm</addrMode>
			</mode>
			<mode>
				<!--width>2</width -->
				<addrMode>imm2</addrMode>
				<feature>65k</feature>
				<prefix>
					<name>RS</name>
					<value>01</value>
				</prefix>
			</mode>
			<mode>
				<!--width>4</width -->
				<addrMode>imm4</addrMode>
				<feature>65k</feature>
				<prefix>
					<name>RS</name>
					<value>10</value>
				</prefix>
			</mode>
			<mode>
				<!--width>8</width -->
				<addrMode>imm8</addrMode>
				<feature>65k</feature>
				<prefix>
					<name>RS</name>
					<value>11</value>
				</prefix>
			</mode>
		</syntax>

		<syntax>
			<id>doubleimmediate</id>
			<desc>Double immediate addressing: two operands directly follow the opcode.
			</desc>
			<simplesyntax>#&lt;op1&gt;, #&lt;op2&gt;</simplesyntax>
			<feature>816</feature>
			<mode>
				<!--width>1</width -->
				<addrMode>dimm</addrMode>
			</mode>
		</syntax>

		<syntax>
			<id>absolute</id>
			<desc>Opcode is followed by an address for the operand</desc>
			<simplesyntax>&lt;address&gt;</simplesyntax>
			<mode>
				<addrMode>zp</addrMode>
			</mode>
			<mode>
				<addrMode>abs</addrMode>
			</mode>
			<mode>
				<addrMode>bank</addrMode>
				<feature>816</feature>
			</mode>
			<mode>
				<addrMode>long</addrMode>
				<feature>65k</feature>
				<prefix>
					<name>AM</name>
					<value>1</value>
				</prefix>
			</mode>
			<mode>
				<addrMode>quad</addrMode>
				<feature>65k</feature>
				<prefix>
					<name>AM</name>
					<value>1</value>
				</prefix>
			</mode>
			<mode>
				<addrMode>addr</addrMode>
			</mode>
			<mode>
				<addrMode>addrbank</addrMode>
				<feature>816</feature>
			</mode>
			<mode>
				<addrMode>addrlong</addrMode>
				<feature>65k</feature>
				<prefix>
					<name>AM</name>
					<value>1</value>
				</prefix>
			</mode>
			<mode>
				<addrMode>addrquad</addrMode>
				<feature>65k</feature>
				<prefix>
					<name>AM</name>
					<value>1</value>
				</prefix>
			</mode>
			<mode>
				<addrMode>rel</addrMode>
				<simplesyntax>rel</simplesyntax>
			</mode>
			<mode>
				<addrMode>relwide</addrMode>
				<simplesyntax>relwide</simplesyntax>
				<feature>65k</feature>
				<prefix>
					<name>RS</name>
					<value>01</value>
				</prefix>
			</mode>
			<mode>
				<addrMode>relw</addrMode>
				<simplesyntax>relwide</simplesyntax>
				<feature>816ce02</feature>
			</mode>
			<mode>
				<addrMode>rellong</addrMode>
				<simplesyntax>rellong</simplesyntax>
				<feature>65k</feature>
				<prefix>
					<name>RS</name>
					<value>10</value>
				</prefix>
			</mode>
			<mode>
				<addrMode>relquad</addrMode>
				<simplesyntax>relquad</simplesyntax>
				<feature>65k</feature>
				<prefix>
					<name>RS</name>
					<value>11</value>
				</prefix>
			</mode>
			<mode>
				<addrMode>relj</addrMode>
				<simplesyntax>rel</simplesyntax>
			</mode>
			<mode>
				<addrMode>reljwide</addrMode>
				<simplesyntax>relwide</simplesyntax>
				<feature>65k</feature>
			</mode>
			<mode>
				<addrMode>reljlong</addrMode>
				<simplesyntax>rellong</simplesyntax>
				<feature>65k</feature>
				<prefix>
					<name>AM</name>
					<value>1</value>
				</prefix>
			</mode>
			<mode>
				<addrMode>reljquad</addrMode>
				<simplesyntax>relquad</simplesyntax>
				<feature>65k</feature>
				<prefix>
					<name>AM</name>
					<value>1</value>
				</prefix>
			</mode>
		</syntax>

		<syntax>
			<id>absolutex</id>
			<desc>The X register is added to the operand following the opcode
			</desc>
			<simplesyntax>&lt;address&gt;,X</simplesyntax>
			<mode>
				<addrMode>zpx</addrMode>
			</mode>
			<mode>
				<addrMode>absx</addrMode>
			</mode>
			<mode>
				<addrMode>bankx</addrMode>
				<feature>816</feature>
			</mode>
			<mode>
				<addrMode>longx</addrMode>
				<prefix>
					<name>AM</name>
					<value>1</value>
				</prefix>
				<feature>65k</feature>
			</mode>
			<mode>
				<addrMode>quadx</addrMode>
				<prefix>
					<name>AM</name>
					<value>1</value>
				</prefix>
				<feature>65k</feature>
			</mode>
		</syntax>

		<syntax>
			<id>absolutey</id>
			<desc>The Y register is added to the operand following the opcode
			</desc>
			<simplesyntax>&lt;address&gt;,Y</simplesyntax>
			<mode>
				<addrMode>zpy</addrMode>
			</mode>
			<mode>
				<addrMode>absy</addrMode>
			</mode>
			<mode>
				<addrMode>longy</addrMode>
				<prefix>
					<name>AM</name>
					<value>1</value>
				</prefix>
				<feature>65k</feature>
			</mode>
			<mode>
				<addrMode>quady</addrMode>
				<prefix>
					<name>AM</name>
					<value>1</value>
				</prefix>
				<feature>65k</feature>
			</mode>
		</syntax>

		<syntax>
			<id>absolutes</id>
			<desc>The S register is added to the operand following the opcode
			</desc>
			<feature>816</feature>
			<simplesyntax>&lt;address&gt;,S</simplesyntax>
			<mode>
				<addrMode>zps</addrMode>
			</mode>
		</syntax>

		<syntax>
			<id>indirect</id>
			<desc>The opcode is followed by an address, from which the effective
				address of the operand is read.
				The effective
				address is taken as a
				wide address (16 bit)
			</desc>
			<simplesyntax>(&lt;address&gt;)</simplesyntax>
			<mode>
				<addrMode>zpind</addrMode>
				<feature>cmos_ind</feature>
			</mode>
			<mode>
				<addrMode>absind</addrMode>
			</mode>
		</syntax>

		<syntax>
			<id>indirectz</id>
			<desc>The opcode is followed by an address, from which the effective
				address of the operand is read.
				The effective
				address is taken as a
				wide address (16 bit). The Z register
				is added to the address, the result
				is taken as
				the
				effective address
				of the operand.
			</desc>
			<simplesyntax>(&lt;address&gt;),Z</simplesyntax>
			<mode>
				<addrMode>zpindz</addrMode>
				<feature>cmos_indz</feature>
			</mode>
			<!-- mode> <addrMode>absindz</addrMode> </mode -->
		</syntax>

		<syntax>
			<id>eindirect</id>
			<desc>The effective operand address is taken from the E register
			</desc>
			<simplesyntax>(E)</simplesyntax>
			<mode>
				<addrMode>eind</addrMode>
			</mode>
		</syntax>

		<syntax>
			<id>indirectlong</id>
			<desc>The opcode is followed by an address, from which the effective
				address of the operand is read.
				The effective
				address is taken as a
				long address (32 bit)
			</desc>
			<feature>65k</feature>
			<simplesyntax>[&lt;address&gt;]</simplesyntax>
			<mode>
				<addrMode>zpindlong</addrMode>
				<prefix>
					<name>AM</name>
					<value>1</value>
				</prefix>
			</mode>
			<mode>
				<addrMode>absindlong</addrMode>
				<prefix>
					<name>AM</name>
					<value>1</value>
				</prefix>
			</mode>
		</syntax>

		<syntax>
			<id>indirectbank</id>
			<desc>The opcode is followed by an address, from which the effective
				address of the operand is read.
				The effective
				address is taken as a
				bank address (24 bit)
			</desc>
			<feature>816</feature>
			<simplesyntax>[&lt;address&gt;]</simplesyntax>
			<mode>
				<addrMode>absindbank</addrMode>
			</mode>
		</syntax>

		<syntax>
			<id>indirectquad</id>
			<desc>The opcode is followed by an address, from which the effective
				address of the operand is read.
				The effective
				address is taken as a
				quad address (64 bit)
			</desc>
			<simplesyntax>[[&lt;address&gt;]]</simplesyntax>
			<mode>
				<addrMode>zpindquad</addrMode>
				<prefix>
					<name>AM</name>
					<value>1</value>
				</prefix>
			</mode>
			<mode>
				<addrMode>absindquad</addrMode>
				<prefix>
					<name>AM</name>
					<value>1</value>
				</prefix>
			</mode>
		</syntax>

		<syntax>
			<id>indirecty</id>
			<desc>The opcode is followed by an address, from which an address
				read.
				This address is taken as a wide address (16
				bit). The Y register
				is added to the address, the result
				is taken as the effective address
				of the operand.
			</desc>
			<simplesyntax>(&lt;address&gt;),Y</simplesyntax>
			<mode>
				<addrMode>zpindy</addrMode>
			</mode>
			<mode>
				<addrMode>absindy</addrMode>
			</mode>
		</syntax>

		<syntax>
			<id>indirectoffset</id>
			<desc>The opcode is followed by an address, from which an address
				read.
				This address is taken as a wide address (16
				bit). The offset from the opcode
				is added to the address, the result
				is taken as the effective address
				of the operand.
			</desc>
			<simplesyntax>(&lt;address&gt;),byte</simplesyntax>
			<mode>
				<addrMode>zpindbyte</addrMode>
			</mode>
			<mode>
				<addrMode>absindbyte</addrMode>
			</mode>
		</syntax>

		<syntax>
			<id>indirectoffsetlong</id>
			<desc>The opcode is followed by an address, from which an address
				read.
				This address is taken as a long address (32
				bit). The offset from the opcode
				is added to the address, the result
				is taken as the effective address
				of the operand.
			</desc>
			<simplesyntax>[&lt;address&gt;],byte</simplesyntax>
			<mode>
				<addrMode>zpindbytelong</addrMode>
				<prefix>
					<name>AM</name>
					<value>1</value>
				</prefix>
			</mode>
<!-- 
			<mode>
				<addrMode>absindbytelong</addrMode>
			</mode>
 -->
		</syntax>

		<syntax>
			<id>indirectoffsetquad</id>
			<desc>The opcode is followed by an address, from which an address
				read.
				This address is taken as a quad address (64
				bit). The offset from the opcode
				is added to the address, the result
				is taken as the effective address
				of the operand.
			</desc>
			<simplesyntax>[[&lt;address&gt;]],byte</simplesyntax>
			<mode>
				<addrMode>zpindbytequad</addrMode>
				<prefix>
					<name>AM</name>
					<value>1</value>
				</prefix>
			</mode>
			<mode>
				<addrMode>absindbytequad</addrMode>
			</mode>
		</syntax>


		<syntax>
			<id>indirectylong</id>
			<desc>The opcode is followed by an address, from which an address
				read.
				This address is taken as a long address (32
				bit). The Y register
				is added to the address, the result
				is taken as the effective address
				of the operand.
			</desc>
			<feature>65k</feature>
			<simplesyntax>[&lt;address&gt;],Y</simplesyntax>
			<mode>
				<!--width>1</width -->
				<addrMode>zpindylong</addrMode>
				<prefix>
					<name>AM</name>
					<value>1</value>
				</prefix>
			</mode>
			<mode>
				<addrMode>absindybank</addrMode>
			</mode>
			<mode>
				<!--width>2</width -->
				<addrMode>absindylong</addrMode>
				<prefix>
					<name>AM</name>
					<value>1</value>
				</prefix>
			</mode>
		</syntax>

		<syntax>
			<id>indirectzlong</id>
			<desc>The opcode is followed by an address, from which an address read. This address
				is taken as a long address (32 bit). The Z register is added to the address, the result is taken as the effective
				address
				of the operand.
			</desc>
			<feature>65k</feature>
			<simplesyntax>[&lt;address&gt;],Z</simplesyntax>
			<mode>
				<addrMode>zpindzlong</addrMode>
				<prefix>
					<name>AM</name>
					<value>1</value>
				</prefix>
			</mode>
			<mode>
				<addrMode>absindzlong</addrMode>
				<prefix>
					<name>AM</name>
					<value>1</value>
				</prefix>
			</mode>
		</syntax>

		<syntax>
			<id>indirectyquad</id>
			<desc>The opcode is followed by an address, from which an address
				read.
				This address is taken as a quad address (64
				bit). The Y register
				is added to the address, the result
				is taken as the effective address
				of the operand.
			</desc>
			<feature>65k</feature>
			<simplesyntax>[[&lt;address&gt;]],Y</simplesyntax>
			<mode>
				<!--width>1</width -->
				<addrMode>zpindyquad</addrMode>
				<prefix>
					<name>AM</name>
					<value>1</value>
				</prefix>
			</mode>
			<mode>
				<!--width>2</width -->
				<addrMode>absindyquad</addrMode>
				<prefix>
					<name>AM</name>
					<value>1</value>
				</prefix>
			</mode>
		</syntax>

		<syntax>
			<id>indirectzquad</id>
			<desc>The opcode is followed by an address, from which an address read. This address
				is taken as a quad address (64
				bit). The Z register is added to the address, the result is taken as the effective
				address
				of the operand.
			</desc>
			<feature>65k</feature>
			<simplesyntax>[[&lt;address&gt;]],Z</simplesyntax>
			<mode>
				<addrMode>zpindzquad</addrMode>
				<prefix>
					<name>AM</name>
					<value>1</value>
				</prefix>
			</mode>
			<mode>
				<addrMode>absindzquad</addrMode>
				<prefix>
					<name>AM</name>
					<value>1</value>
				</prefix>
			</mode>
		</syntax>


		<syntax>
			<id>xindirect</id>
			<desc>The opcode is followed by an address. The X register is added
				to
				this address. From the result the effective
				operand address is read.
				The effective address is taken as a wide address (16 bit).
			</desc>
			<simplesyntax>(&lt;address&gt;,X)</simplesyntax>
			<mode>
				<!--width>1</width -->
				<addrMode>zpxind</addrMode>
			</mode>
			<mode>
				<!--width>2</width -->
				<addrMode>absxind</addrMode>
			</mode>
		</syntax>

		<syntax>
			<id>xindirectlong</id>
			<desc>The opcode is followed by an address. The X register is added
				to
				this address. From the result the effective
				operand address is read.
				The effective address is taken as a long address (32 bit).
			</desc>
			<feature>65k</feature>
			<simplesyntax>[&lt;address&gt;,X]</simplesyntax>
			<mode>
				<!--width>1</width -->
				<addrMode>zpxindlong</addrMode>
				<prefix>
					<name>AM</name>
					<value>1</value>
				</prefix>
			</mode>
			<mode>
				<!--width>2</width -->
				<addrMode>absxindlong</addrMode>
				<prefix>
					<name>AM</name>
					<value>1</value>
				</prefix>
			</mode>
		</syntax>

		<syntax>
			<id>xindirectquad</id>
			<desc>The opcode is followed by an address. The X register is added
				to
				this address. From the result the effective
				operand address is read.
				The effective address is taken as a quad address (64 bit).
			</desc>
			<feature>65k</feature>
			<simplesyntax>[[&lt;address&gt;,X]]</simplesyntax>
			<mode>
				<!--width>1</width -->
				<addrMode>zpxindquad</addrMode>
				<prefix>
					<name>AM</name>
					<value>1</value>
				</prefix>
			</mode>
			<mode>
				<!--width>2</width -->
				<addrMode>absxindquad</addrMode>
				<prefix>
					<name>AM</name>
					<value>1</value>
				</prefix>
			</mode>
		</syntax>

		<syntax>
			<id>stackindirectindexed</id>
			<desc>This mode is similar to indirect indexed addressing, only that the
				stack pointer replaces the base page (or
				address zero in standard CMOS) as
				base address.
				The single byte parameter is added to the stack pointer, the result is
				the location of the pointer address in memory, to that y is added to
				give the effective address.
			</desc>
			<simplesyntax>(zp,S),Y</simplesyntax>
			<feature>816ce02</feature>
			<mode>
				<addrMode>zpsindy</addrMode>
			</mode>
		</syntax>

		<syntax>
			<id>zprel</id>
			<desc>Addressing mode with one memory address, and a relative jump location.
				Introduced in the Rockwell bit operations
				BBS/BBR, it allows specifying a zeropage
				location to look at, and on some condition jump to a relative jump location.
			</desc>
			<simplesyntax>zp,rel</simplesyntax>
			<feature>rcmos</feature>
			<mode>
				<addrMode>zprel</addrMode>
			</mode>
			<mode>
				<addrMode>zprelwide</addrMode>
				<simplesyntax>zprelwide</simplesyntax>
				<feature>65k</feature>
				<prefix>
					<name>RS</name>
					<value>01</value>
				</prefix>
			</mode>
		</syntax>

	</syntaxes>


	<!-- ################################# -->

	<addrmodes>
		<addrmode>
			<name>Implied</name>
			<desc>Implied by the operation</desc>
			<identifier>implied</identifier>
			<ignoredPrefixes>AM</ignoredPrefixes>
			<ignoredPrefixes>OF</ignoredPrefixes>
			<width>0</width>
		</addrmode>

		<addrmode>
			<name>Accumulator</name>
			<identifier>A</identifier>
			<desc>Accumulator operation</desc>
			<ignoredPrefixes>AM</ignoredPrefixes>
			<ignoredPrefixes>UM</ignoredPrefixes>
			<ignoredPrefixes>OF</ignoredPrefixes>
			<ignoredPrefixes>LE</ignoredPrefixes>
			<width>0</width>
		</addrmode>

		<!-- ################################# -->

		<addrmode>
			<name>Address</name>
			<desc>The parameter following the opcode is an address (16 bit; for
				JMP, JSR, JPU)
			</desc>
			<identifier>addr</identifier>
			<altMode>addrquad</altMode>
			<width>2</width>
		</addrmode>

		<addrmode>
			<name>Address</name>
			<desc>The parameter following the opcode is an address (24 bit)
			</desc>
			<feature>816</feature>
			<identifier>addrbank</identifier>
			<width>3</width>
		</addrmode>

		<addrmode>
			<name>Address Long</name>
			<desc>The parameter following the opcode is an address (32 bit; for
				JMP, JSR, JPU)
			</desc>
			<feature>65k</feature>
			<identifier>addrlong</identifier>
			<width>4</width>
		</addrmode>

		<addrmode>
			<name>Address Quad</name>
			<desc>The parameter following the opcode is an address (32 bit; for
				JMP, JSR, JPU)
			</desc>
			<feature>65k</feature>
			<identifier>addrquad</identifier>
			<width>8</width>
		</addrmode>

		<!-- ################################# -->

		<addrmode>
			<name>Immediate</name>
			<desc>The immediate addressing mode uses the opcode parameter
				directly, without further lookup. Here it is a byte
				parameter
			</desc>
			<identifier>imm</identifier>
			<ignoredPrefixes>AM</ignoredPrefixes>
			<ignoredPrefixes>UM</ignoredPrefixes>
			<ignoredPrefixes>OF</ignoredPrefixes>
			<width>1</width>
		</addrmode>

		<addrmode>
			<name>Double Immediate</name>
			<desc>The double immediate addressing mode uses two opcode parameters
				directly, without further lookup. Here it is two byte-wide
				parameters
			</desc>
			<feature>816</feature>
			<identifier>dimm</identifier>
			<width>2</width>
		</addrmode>

		<addrmode>
			<name>Immediate 16bit</name>
			<altname>Wide immediate</altname>
			<desc>The immediate addressing mode uses the opcode parameter
				directly, without further lookup. Here it is a word
				(16bit)
				parameter
			</desc>
			<identifier>imm2</identifier>
			<ignoredPrefixes>AM</ignoredPrefixes>
			<ignoredPrefixes>UM</ignoredPrefixes>
			<width>2</width>
		</addrmode>

		<addrmode>
			<name>Immediate 32bit</name>
			<altname>Long immediate</altname>
			<desc>The immediate addressing mode uses the opcode parameter
				directly, without further lookup. Here it is a long
				(32bit)
				parameter
			</desc>
			<identifier>imm4</identifier>
			<ignoredPrefixes>AM</ignoredPrefixes>
			<ignoredPrefixes>UM</ignoredPrefixes>
			<width>4</width>
		</addrmode>

		<addrmode>
			<name>Immediate 64bit</name>
			<desc>The immediate addressing mode uses the opcode parameter
				directly, without further lookup. Here it is a quad
				(64bit)
				parameter
			</desc>
			<identifier>imm8</identifier>
			<ignoredPrefixes>AM</ignoredPrefixes>
			<ignoredPrefixes>UM</ignoredPrefixes>
			<width>8</width>
		</addrmode>

		<!-- ################################# -->

		<addrmode>
			<name>E indirect</name>
			<identifier>eind</identifier>
			<desc>E-register indirect: the effective address is taken from the E
				register.
			</desc>
			<feature>65k</feature>
			<ignoredPrefixes>AM</ignoredPrefixes>
			<ignoredPrefixes>OF</ignoredPrefixes>
			<width>0</width>
		</addrmode>

		<!-- ################################# -->

		<addrmode>
			<name>Zeropage</name>
			<identifier>zp</identifier>
			<desc>Zeropage address; The effective address of the operand is a
				zeropage address (i.e. 8bit)
			</desc>
			<altMode>long</altMode>
			<width>1</width>
		</addrmode>

		<addrmode>
			<name>Zeropage indexed with X</name>
			<altname>Zeropage X-indexed</altname>
			<identifier>zpx</identifier>
			<desc>Zeropage address, plus content of XR; The effective address of
				the operand is the opcode parameter (zeropage
				address), plus the
				value of the X register
			</desc>
			<altMode>longx</altMode>
			<width>1</width>
		</addrmode>

		<addrmode>
			<name>Stack-relative with offset</name>
			<altname>Zeropage S-indexed</altname>
			<identifier>zps</identifier>
			<desc>Stack address, plus a byte offset; The effective address of
				the operand is the opcode parameter (byte value), plus the
				value of the S register
			</desc>
			<feature>816</feature>
			<width>1</width>
		</addrmode>

		<addrmode>
			<name>Zeropage indexed with Y</name>
			<altname>Zeropage Y-indexed</altname>
			<identifier>zpy</identifier>
			<desc>Zeropage address, plus content of YR; The effective address of
				the operand is the opcode parameter (zeropage
				address), plus the
				value of the Y register
			</desc>
			<altMode>longy</altMode>
			<width>1</width>
		</addrmode>

		<addrmode>
			<name>Absolute 16bit</name>
			<altname>Absolute</altname>
			<identifier>abs</identifier>
			<desc>16 bit address; The effective address of the operand is the
				word
				address (i.e. 16 bit) given as opcode parameter
			</desc>
			<altMode>quad</altMode>
			<width>2</width>
		</addrmode>

		<addrmode>
			<name>Absolute 16bit indexed with X</name>
			<altname>Absolute X-indexed</altname>
			<identifier>absx</identifier>
			<desc>16 bit address, plus content of XR; The effective address is
				the
				opcode parameter (word address), plus the value
				of the X register
			</desc>
			<altMode>quadx</altMode>
			<width>2</width>
		</addrmode>

		<addrmode>
			<name>Absolute 16bit indexed with Y</name>
			<altname>Absolute Y-indexed</altname>
			<identifier>absy</identifier>
			<desc>16 bit address, plus content of YR; The effective address is
				the
				opcode parameter (word address), plus the value
				of the Y register
			</desc>
			<altMode>quady</altMode>
			<width>2</width>
		</addrmode>

		<addrmode>
			<name>Absolute 24bit</name>
			<altname>Banked Absolute</altname>
			<feature>816</feature>
			<identifier>bank</identifier>
			<desc>24 bit address; The effective address of the operand is the
				bank plus 16 bit
				address given as opcode parameter
			</desc>
			<width>3</width>
		</addrmode>

		<addrmode>
			<name>Absolute 24bit indexed with X</name>
			<altname>Banked Absolute X-indexed</altname>
			<feature>816</feature>
			<identifier>bankx</identifier>
			<desc>24 bit address; The effective address of the operand is the
				bank plus 16 bit
				address given as opcode parameter, plus the content of the X register.
			</desc>
			<width>3</width>
		</addrmode>

		<addrmode>
			<name>Absolute 32bit</name>
			<altname>Long absolute</altname>
			<identifier>long</identifier>
			<desc>32 bit address; The effective address is the opcode parameter,
				which is a long address (i.e. 32 bit)
			</desc>
			<feature>65k</feature>
			<width>4</width>
		</addrmode>

		<addrmode>
			<name>Absolute 32bit indexed with X</name>
			<altname>Long absolute X-indexed</altname>
			<identifier>longx</identifier>
			<desc>32 bit address, plus content of XR; The effective address is
				the
				opcode parameter (long address), plus the value
				of the X register
			</desc>
			<feature>65k</feature>
			<width>4</width>
		</addrmode>

		<addrmode>
			<name>Absolute 32bit indexed with Y</name>
			<altname>Long absolute Y-indexed</altname>
			<identifier>longy</identifier>
			<desc>32 bit address, plus content of YR; The effective address is
				the
				opcode parameter (long address), plus the value
				of the Y register
			</desc>
			<feature>65k</feature>
			<width>4</width>
		</addrmode>

		<addrmode>
			<name>Absolute 64bit</name>
			<altname>Quad absolute</altname>
			<identifier>quad</identifier>
			<desc>64 bit address; The effective address is the opcode parameter,
				which is a quad address (i.e. 64 bit)
			</desc>
			<feature>65k</feature>
			<width>8</width>
		</addrmode>

		<addrmode>
			<name>Absolute 64bit indexed with X</name>
			<altname>Quad absolute X-indexed</altname>
			<identifier>quadx</identifier>
			<desc>64 bit address, plus content of XR; The effective address is
				the
				opcode parameter (quad address), plus the value
				of the X register
			</desc>
			<feature>65k</feature>
			<width>8</width>
		</addrmode>

		<addrmode>
			<name>Absolute 64bit indexed with Y</name>
			<altname>Quad absolute Y-indexed</altname>
			<identifier>quady</identifier>
			<desc>64 bit address, plus content of YR; The effective address is
				the
				opcode parameter (quad address), plus the value
				of the Y register
			</desc>
			<feature>65k</feature>
			<width>8</width>
		</addrmode>

		<!-- ################################# -->

		<addrmode>
			<name>Zeropage indirect 16bit</name>
			<altname>Zeropage indirect</altname>
			<identifier>zpind</identifier>
			<desc>Load effective 16 bit address from zeropage location given;
				Load
				effective word (16bit) address from zeropage
				location given as
				parameter.
			</desc>
			<altMode>zpindlong</altMode>
			<feature>cmos_ind</feature>
			<width>1</width>
		</addrmode>

		<addrmode>
			<name>Zeropage indirect 16bit indexed with Y</name>
			<altname>Zeropage indirect Y-indexed</altname>
			<identifier>zpindy</identifier>
			<desc>Load effective 16 bit address from zeropage location given,
				then
				add content of YR;
				The effective address is
				computed as the word
				(16bit) address read from
				the zeropage location given as parameter
				plus the value of the Y
				register. The resulting address may be larger
				than 16bit due to
				overflow when Y is added.
			</desc>
			<altMode>zpindylong</altMode>
			<width>1</width>
		</addrmode>

		<addrmode>
			<name>Stack Vector indirect 16bit indexed with Y</name>
			<altname>Stack offset indirect Y-indexed</altname>
			<identifier>zpsindy</identifier>
			<desc>
				Add the parameter to the stack register, then
				load effective 16 bit address from this location,
				then add content
				of YR;
				The effective address is computed as the word
				(16bit) address read from
				the stack pointer location offset by the
				given parameter
				plus the value of the Y
				register.
			</desc>
			<feature>816ce02</feature>
			<width>1</width>
		</addrmode>

		<addrmode>
			<name>Zeropage indirect 16bit indexed with Z</name>
			<altname>Zeropage indirect Z-indexed</altname>
			<identifier>zpindz</identifier>
			<desc>Load effective 16 bit address from zeropage location given,
				then
				add content of ZR;
				The effective address is
				computed as the word
				(16bit) address read from
				the zeropage location given as parameter
				plus the value of the Z
				register. The resulting address may be larger
				than 16bit due to
				overflow when Z is added.
			</desc>
			<feature>cmos_indz</feature>
			<altMode>zpindzlong</altMode>
			<width>1</width>
		</addrmode>

		<addrmode>
			<name>Zeropage indirect 16bit indexed with byte offset</name>
			<identifier>zpindbyte</identifier>
			<desc>Load effective 16 bit address from zeropage location given,
				then
				add offset from opcode;
				The effective address is
				computed as the word
				(16bit) address read from
				the zeropage location given as parameter
				plus the value of the offset. The resulting address may be larger
				than 16bit due to
				overflow when the offset is added.
			</desc>
			<feature>65k</feature>
			<altMode>zpindbytelong</altMode>
			<width>1</width>
			<offset>1</offset>
		</addrmode>


		<addrmode>
			<name>Zeropage indexed with X indirect 16bit</name>
			<altname>Zeropage X-indexed indirect</altname>
			<identifier>zpxind</identifier>
			<desc>Load effective 16 bit address from zeropage location given plus
				content of XR;
				The effective word (16bit) address
				is read from the
				location that is
				computed as the zeropage location given as parameter
				plus the value
				of the X register
			</desc>
			<altMode>zpxindlong</altMode>
			<width>1</width>
		</addrmode>

		<addrmode>
			<name>Absolute indirect 16bit</name>
			<altname>Absolute indirect</altname>
			<identifier>absind</identifier>
			<desc>Load effective 16 bit address from absolute location given;
				The
				effective word (16bit) address is read from word
				location given as
				parameter.
			</desc>
			<altMode>absindlong</altMode>
			<width>2</width>
		</addrmode>

		<addrmode>
			<name>Absolute indirect 16bit indexed with Y</name>
			<altname>Absolute indirect Y-indexed</altname>
			<identifier>absindy</identifier>
			<desc>Load effective 16 bit address from absolute location given,
				then
				add content of YR;
				The effective address is
				computed as the word
				(16bit) address read from
				the word location given as parameter plus
				the value of the Y
				register.
				The resulting address may be larger than
				16bit due to
				overflow when Y is added.
			</desc>
			<altMode>absindylong</altMode>
			<feature>65k</feature>
			<width>2</width>
		</addrmode>

		<addrmode>
			<name>Absolute indirect 16bit indexed with byte offset</name>
			<identifier>absindbyte</identifier>
			<desc>Load effective 16 bit address from absolute location given,
				then
				add offset from opcode;
				The effective address is
				computed as the word
				(16bit) address read from
				the zeropage location given as parameter
				plus the value of the offset. The resulting address may be larger
				than 16bit due to
				overflow when the offset is added.
			</desc>
			<feature>65k</feature>
			<width>2</width>
			<offset>1</offset>
		</addrmode>

		<addrmode>
			<name>Absolute indexed with X indirect 16bit</name>
			<altname>Absolute X-indexed indirect</altname>
			<identifier>absxind</identifier>
			<desc>Load effective 16 bit address from absolute location given plus
				content of XR;
				The effective word address is read
				from the location
				that is computed as
				the word location given as parameter plus the
				value of the X register
			</desc>
			<altMode>absxindlong</altMode>
			<feature>cmos</feature>
			<width>2</width>
		</addrmode>

		<!-- ################################# -->

		<addrmode>
			<name>Absolute indirect 24bit</name>
			<identifier>absindbank</identifier>
			<feature>816</feature>
			<desc>Load effective 24 bit address from absolute location given;
				The
				effective (24bit) address is read from the
				location given as
				parameter.
			</desc>
			<width>2</width>
		</addrmode>

		<addrmode>
			<name>Absolute indirect 24bit indexed with Y</name>
			<identifier>absindybank</identifier>
			<feature>816</feature>
			<desc>Load 24 bit address from absolute location given, then add content of Y register to
			compute effective 24 bit operand address.
			</desc>
			<width>2</width>
		</addrmode>


		<!-- ################################# -->

		<addrmode>
			<name>Zeropage indirect 32bit</name>
			<altname>Long Zeropage indirect</altname>
			<identifier>zpindlong</identifier>
			<desc>Load effective 32 bit address from zeropage location given;
				The
				effective long (32bit) address is read from
				zeropage location given
				as parameter.
			</desc>
			<feature>65k</feature>
			<width>1</width>
		</addrmode>

		<addrmode>
			<name>Zeropage indirect 32bit indexed with Y</name>
			<altname>Zeropage long indirect Y-indexed</altname>
			<identifier>zpindylong</identifier>
			<desc>Load effective 32 bit address from zeropage location given,
				then
				add content of YR;
				The effective address is
				computed as the long
				(32bit) address read from
				the zeropage location given as parameter
				plus the value of the Y
				register. The resulting address may be larger
				than 32bit due to
				overflow when Y is added.
			</desc>
			<feature>65k</feature>
			<width>1</width>
		</addrmode>
		
		<addrmode> 
			<name>Zeropage indirect 32bit indexed with Z</name> 
			<altname>Zeropage long indirect Z-indexed</altname> 
			<identifier>zpindzlong</identifier> 
			<desc>Load effective 32 bit address from zeropage location given, then add content of 
				ZR; The effective address is computed as the long (32bit) address read from the zeropage location given as parameter plus 
				the value of the Z register. The resulting address may be larger than 32bit due to overflow when Z is added.
			</desc> 
			<feature>65k</feature> 
			<width>1</width> 
		</addrmode>

		<addrmode>
			<name>Zeropage indirect 32bit indexed with byte offset</name>
			<identifier>zpindbytelong</identifier>
			<desc>Load effective 32 bit address from zeropage location given,
				then
				add offset from opcode;
				The effective address is
				computed as the long
				(32bit) address read from
				the zeropage location given as parameter
				plus the value of the offset. The resulting address may be larger
				than 32bit due to
				overflow when the offset is added.
			</desc>
			<feature>65k</feature>
			<width>1</width>
			<offset>1</offset>
		</addrmode>


		<addrmode>
			<name>Zeropage indexed with X indirect 32bit</name>
			<altname>Zeropage X-indexed long indirect</altname>
			<identifier>zpxindlong</identifier>
			<desc>Load effective 32 bit address from zeropage location given plus
				content of XR;
				The effective long (32bit) address
				is read from the
				location that is
				computed as the zeropage location given as parameter
				plus the value
				of the X register
			</desc>
			<feature>65k</feature>
			<width>1</width>
		</addrmode>

		<addrmode>
			<name>Absolute indirect 32bit</name>
			<altname>Absolute long indirect</altname>
			<identifier>absindlong</identifier>
			<desc>Load effective 32 bit address from absolute location given;
				The
				effective long (32bit) address is read from word
				location given as
				parameter.
			</desc>
			<feature>65k</feature>
			<width>2</width>
		</addrmode>

		<addrmode>
			<name>Absolute indirect 32bit indexed with Y</name>
			<altname>Absolute long indirect Y-indexed</altname>
			<identifier>absindylong</identifier>
			<desc>Load effective 32 bit address from absolute location given,
				then
				add content of YR;
				The effective address is
				computed as the long
				address read from the word
				location given as parameter plus the value
				of the Y register. The
				resulting address may be larger than 32bit due
				to overflow when Y is
				added.
			</desc>
			<feature>65k</feature>
			<width>2</width>
		</addrmode>

		<addrmode>
			<name>Absolute indirect 32bit indexed with Z</name>
			<altname>Absolute long indirect Z-indexed</altname>
			<identifier>absindzlong</identifier>
			<desc>Load effective 32 bit address from absolute location given, then add content of
				ZR; The effective address is
				computed as the long address read from the word location given as parameter plus the value
				of
				the Z register. The
				resulting address may be larger than 32bit due to overflow when Z is added.
			</desc>
			<feature>ce02</feature>
			<width>2</width>
		</addrmode>

		<addrmode>
			<name>Absolute indexed with X indirect 32bit</name>
			<altname>Absolute X-indexed long indirect</altname>
			<identifier>absxindlong</identifier>
			<desc>Load effective 32 bit address from absolute location given plus
				content of XR;
				The effective long (32bit) address
				is read from the
				location that is
				computed as the word location given as parameter plus
				the value of
				the X register
			</desc>
			<feature>65k</feature>
			<width>2</width>
		</addrmode>

		<!-- ################################# -->

		<addrmode>
			<name>Zeropage indirect 64bit</name>
			<altname>Zeropage quad indirect</altname>
			<identifier>zpindquad</identifier>
			<desc>Load effective 64 bit address from zeropage location given;
				The
				effective quad (64bit) address is read from
				zeropage location given
				as parameter.
			</desc>
			<feature>65k</feature>
			<width>1</width>
		</addrmode>

		<addrmode>
			<name>Zeropage indirect 64bit indexed with Y</name>
			<altname>Zeropage quad indirect Y-indexed</altname>
			<identifier>zpindyquad</identifier>
			<desc>Load effective 64 bit address from zeropage location given,
				then
				add content of YR;
				The effective address is
				computed as the quad
				(64bit) address read from
				the zeropage location given as parameter
				plus the value of the Y
				register
			</desc>
			<feature>65k</feature>
			<width>1</width>
		</addrmode>

		<addrmode>
			<name>Zeropage indirect 64bit indexed with Z</name>
			<altname>Zeropage quad indirect Z-indexed</altname>
			<identifier>zpindzquad</identifier>
			<desc>Load effective 64 bit address from zeropage location given,
				then
				add content of ZR;
				The effective address is
				computed as the quad
				(64bit) address read from
				the zeropage location given as parameter
				plus the value of the Z
				register
			</desc>
			<feature>65k</feature>
			<width>1</width>
		</addrmode>

		<addrmode>
			<name>Zeropage indirect 64bit indexed with byte offset</name>
			<identifier>zpindbytequad</identifier>
			<desc>Load effective 64 bit address from zeropage location given,
				then
				add offset from opcode;
				The effective address is
				computed as the quad
				(64bit) address read from
				the zeropage location given as parameter
				plus the value of the offset. The resulting address may be larger
				than 64bit due to
				overflow when the offset is added.
			</desc>
			<feature>65k</feature>
			<width>1</width>
			<offset>1</offset>
		</addrmode>


		<addrmode>
			<name>Zeropage indexed with X indirect 64bit</name>
			<altname>Zeropage X-indexed quad indirect</altname>
			<identifier>zpxindquad</identifier>
			<desc>Load effective 64 bit address from zeropage location given plus
				content of XR;
				The effective quad (64bit) address
				is read from the
				location that is
				computed as the zeropage location given as parameter
				plus the value
				of the X register
			</desc>
			<feature>65k</feature>
			<width>1</width>
		</addrmode>

		<addrmode>
			<name>Absolute indirect 64bit</name>
			<altname>Absolute quad indirect</altname>
			<identifier>absindquad</identifier>
			<desc>Load effective 64 bit address from absolute location given;
				The
				effective quad (64bit) address is read from word
				location given as
				parameter.
			</desc>
			<feature>65k</feature>
			<width>2</width>
		</addrmode>

		<addrmode>
			<name>Absolute indirect 64bit indexed with Y</name>
			<altname>Absolute quad indirect Y-indexed</altname>
			<identifier>absindyquad</identifier>
			<desc>Load effective 64 bit address from absolute location given,
				then
				add content of YR;
				The effective address is
				computed as the quad
				address read from the word
				location given as parameter plus the value
				of the Y register
			</desc>
			<feature>65k</feature>
			<width>2</width>
		</addrmode>

		<addrmode>
			<name>Absolute indirect 64bit indexed with Z</name>
			<altname>Absolute quad indirect Z-indexed</altname>
			<identifier>absindzquad</identifier>
			<desc>Load effective 64 bit address from absolute location given,
				then
				add content of ZR;
				The effective address is
				computed as the quad
				address read from the word
				location given as parameter plus the value
				of the Z register
			</desc>
			<feature>65k</feature>
			<width>2</width>
		</addrmode>

		<addrmode>
			<name>Absolute indirect 64bit indexed with byte offset</name>
			<identifier>absindbytequad</identifier>
			<desc>Load effective 64 bit address from absolute location given,
				then
				add offset from opcode;
				The effective address is
				computed as the quad
				(64bit) address read from
				the absolute location given as parameter
				plus the value of the offset. The resulting address may be larger
				than 64bit due to
				overflow when the offset is added.
			</desc>
			<feature>65k</feature>
			<width>2</width>
			<offset>1</offset>
		</addrmode>


		<addrmode>
			<name>Absolute indexed with X indirect 64bit</name>
			<altname>Absolute X-indexed quad indirect</altname>
			<identifier>absxindquad</identifier>
			<desc>Load effective 64 bit address from absolute location given plus
				content of XR;
				The effective quad (64bit) address
				is read from the
				location that is
				computed as the word location given as parameter plus
				the value of
				the X register
			</desc>
			<feature>65k</feature>
			<width>2</width>
		</addrmode>

		<!-- ################################# -->

		<addrmode>
			<name>Relative</name>
			<desc>relative addressing modes, used in branches; from -128 to +127
			</desc>
			<identifier>rel</identifier>
			<altMode>rellong</altMode>
			<width>1</width>
		</addrmode>

		<addrmode>
			<name>Relative 16bit</name>
			<altname>Wide relative</altname>
			<desc>relative addressing modes, used in branches; from -32768 to
				+32767
			</desc>
			<identifier>relwide</identifier>
			<feature>65k</feature>
			<altMode>relquad</altMode>
			<width>2</width>
		</addrmode>

		<addrmode>
			<name>Relative 16bit</name>
			<altname>Wide relative</altname>
			<desc>relative addressing modes, used in branches; from -32768 to
				+32767
			</desc>
			<identifier>relw</identifier>
			<feature>816ce02</feature>
			<width>2</width>
		</addrmode>

		<addrmode>
			<name>Relative 32bit</name>
			<altname>Long relative</altname>
			<desc>relative addressing modes, used in branches; from -2^32 to
				+2^32-1
			</desc>
			<identifier>rellong</identifier>
			<feature>65k</feature>
			<width>4</width>
		</addrmode>

		<addrmode>
			<name>Relative 64bit</name>
			<altname>Quad relative</altname>
			<desc>relative addressing modes, used in branches; from -2^64 to
				+2^64-1
			</desc>
			<identifier>relquad</identifier>
			<feature>65k</feature>
			<width>8</width>
		</addrmode>

		<!-- ################################# -->

		<addrmode>
			<name>Relative (BSR)</name>
			<desc>relative addressing modes, used in BSR; from -128 to +127
			</desc>
			<identifier>relj</identifier>
			<feature>65k</feature>
			<altMode>reljlong</altMode>
			<width>1</width>
		</addrmode>

		<addrmode>
			<name>Relative 16bit (BSR)</name>
			<altname>Wide relative</altname>
			<desc>relative addressing modes, used in BSR; from -32768 to +32767
			</desc>
			<identifier>reljwide</identifier>
			<altMode>reljquad</altMode>
			<feature>65k</feature>
			<width>2</width>
		</addrmode>

		<addrmode>
			<name>Relative 32bit (BSR)</name>
			<altname>Long relative</altname>
			<desc>relative addressing modes, used in BSR; from -2^32 to +2^32-1
			</desc>
			<identifier>reljlong</identifier>
			<feature>65k</feature>
			<width>4</width>
		</addrmode>

		<addrmode>
			<name>Relative 64bit (BSR)</name>
			<altname>Quad relative</altname>
			<desc>relative addressing modes, used in BSR; from -2^64 to +2^64-1
			</desc>
			<identifier>reljquad</identifier>
			<feature>65k</feature>
			<width>8</width>
		</addrmode>

		<!-- ################################# -->

		<addrmode>
			<name>Prefix</name>
			<desc>n/a</desc>
			<identifier>prefix</identifier>
			<feature>65k</feature>
			<width>0</width>
		</addrmode>

		<!-- ################################# -->

		<addrmode>
			<name>ZP with branch</name>
			<desc>Zeropage addressing, combined with relative addressing modes, used in branches; from -128 to +127
			</desc>
			<identifier>zprel</identifier>
			<feature>rcmos</feature>
			<width>2</width>
		</addrmode>

		<addrmode>
			<name>ZP with wide branch</name>
			<desc>Zeropage addressing, combined with 16bit relative addressing modes, used in branches; from -32768 to +32767
			</desc>
			<identifier>zprelwide</identifier>
			<feature>65k</feature>
			<width>3</width>
		</addrmode>

	</addrmodes>

	<!-- ################################# -->

	<prefixes>
		<prefix>
			<name>EXT</name>
			<value>0x0f</value>
			<page>EXT</page>
		</prefix>

		<prefix>
			<name>SYS</name>
			<value>0x2f</value>
			<page>SYS</page>
		</prefix>

		<prefix>
			<name>QUICK</name>
			<value>0x4f</value>
			<page>QUICK</page>
		</prefix>

		<prefix>
			<name>reserved prefix</name>
			<value>0x6f</value>
		</prefix>

		<prefix>
			<name>reserved prefix</name>
			<value>0x8f</value>
		</prefix>

		<prefix>
			<name>reserved prefix</name>
			<value>0xaf</value>
		</prefix>

		<prefix>
			<name>reserved prefix</name>
			<value>0xcf</value>
		</prefix>

		<prefix>
			<name>reserved prefix</name>
			<value>0xef</value>
		</prefix>

		<prefix>
			<name>prefix1</name>
			<value>0x03</value>
			<bits>
				<name>Addressing modes</name>
				<mask>0x04</mask>
				<desc>The AM bit allows to extend the addressing modes to larger
					sizes. The zeropage addressing modes become 32-bit
					addressing
					modes,
					while the 16-bit addressing modes become 64-bit addressing modes
				</desc>
				<id>AM</id>
				<value>
					<value>0</value>
					<desc>normal addressing modes (8 / 16 bit)</desc>
				</value>
				<value>
					<value>1</value>
					<desc>extended addressing modes (32 / 64 bit)</desc>
				</value>
			</bits>
			<bits>
				<name>Register and operation size</name>
				<mask>0x30</mask>
				<desc>These bits determine the size of the operation, 8, 16, 32 or
					64
					bit width.
				</desc>
				<id>RS</id>
				<value>
					<value>00</value>
					<desc>8 bit register</desc>
				</value>
				<value>
					<value>01</value>
					<desc>16 bit register</desc>
					<syntaxval>W</syntaxval>
				</value>
				<value>
					<value>10</value>
					<desc>32 bit register</desc>
					<syntaxval>L</syntaxval>
				</value>
				<value>
					<value>11</value>
					<desc>64 bit register</desc>
					<syntaxval>Q</syntaxval>
				</value>
			</bits>
			<bits>
				<name>Offset register</name>
				<mask>0xc0</mask>
				<desc>Allows to add either the stack pointer, program counter, or
					the
					base register to an address.
					For indirect
					addressing modes, the
					offset is added to the address of
					the indirect pointer, not the
					pointer value.
					I.e. for
					&amp;lt;code&gt;LDA (zp),y&amp;lt;/code&gt;
					the offset is added
					to the operand "zp", not to the value read from
					there.
				</desc>
				<id>OF</id>
				<value>
					<value>00</value>
					<desc>No offset added to address</desc>
				</value>
				<value>
					<value>01</value>
					<desc>Add Program Counter (PC) to address</desc>
					<syntaxval>P</syntaxval>
				</value>
				<value>
					<value>10</value>
					<desc>Add Stack Pointer (SP) to address</desc>
					<syntaxval>S</syntaxval>
				</value>
				<value>
					<value>11</value>
					<desc>Add Base Offset Register (BR) to address</desc>
					<syntaxval>B</syntaxval>
				</value>
			</bits>
		</prefix>

		<prefix>
			<name>prefix2</name>
			<value>0x0b</value>
			<bits>
				<name>Load extension</name>
				<mask>0x60</mask>
				<desc>Determines how a value read is extended from width determine
					by
					RS to full width before it is given to an
					operation.
				</desc>
				<id>LE</id>
				<value>
					<value>00</value>
					<desc>Do not extend the value from RS-width.</desc>
					<syntaxval>E</syntaxval>
				</value>
				<value>
					<value>01</value>
					<desc>Extend with the sign of the value</desc>
					<syntaxval>S</syntaxval>
				</value>
				<value>
					<value>10</value>
					<desc>Extend with zero</desc>
					<syntaxval>0</syntaxval>
				</value>
				<value>
					<value>11</value>
					<desc>Extend with one</desc>
					<syntaxval>1</syntaxval>
				</value>
			</bits>
			<bits>
				<name>User mode selector</name>
				<mask>0x80</mask>
				<desc>When the UM mode bit is set, the effective address it not
					computed using the current mode, but the user mode.
					This bit is
					ignored in user mode, but in supervisor mode it switches address
					calculation to user mode. The effective
					addressthen also points to
					user mode memory
				</desc>
				<id>UM</id>
				<value>
					<value>0</value>
					<desc>Current mode environment (user space/hypervisor mode)</desc>
				</value>
				<value>
					<value>1</value>
					<desc>User mode environment (i.e. ignored when used in user mode);
						Stack Pointer for OF=10 is also User Space stack
						pointer
					</desc>
					<syntaxval>U</syntaxval>
				</value>
			</bits>
			<bits>
				<name>No flags selector</name>
				<mask>0x10</mask>
				<desc>When this is set, flags are not updated after an operation as
					is normal done by the 6502.
				</desc>
				<id>NF</id>
				<value>
					<value>0</value>
					<desc>Flags are updated on each (relevant) operation according to
						standard 6502 rules
					</desc>
				</value>
				<value>
					<value>1</value>
					<desc>Flags are not updated.</desc>
					<syntaxval>N</syntaxval>
				</value>
			</bits>
		</prefix>
	</prefixes>

</cpu>
