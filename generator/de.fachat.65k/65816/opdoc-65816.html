<h2>List of operations</h2>
<h3>Branches and Jumps</h3>
<ul>
<li>
<a href="#BCC">BCC</a>
 - Branch on carry clear - take branch when C flag is cleared
			</li>
<li>
<a href="#BCS">BCS</a>
 - Branch on carry set - take branch when C flag is set</li>
<li>
<a href="#BEQ">BEQ</a>
 - Branch on equal - take branch when Z flag is set</li>
<li>
<a href="#BMI">BMI</a>
 - Branch on minus - take branch when N flag is set</li>
<li>
<a href="#BNE">BNE</a>
 - Branch on not equal - take branch when Z flag is cleared</li>
<li>
<a href="#BPL">BPL</a>
 - Branch on plus - take branch when N flag is cleared</li>
<li>
<a href="#BRA">BRA</a>
 - Branch always - branch independent from any flags</li>
<li>
<a href="#BRK">BRK</a>
 - Starts the break routine.</li>
<li>
<a href="#BRL">BRL</a>
 - Branch always - branch independent from any flags</li>
<li>
<a href="#BVC">BVC</a>
 - Branch on overflow clear - take branch when V flag is cleared
			</li>
<li>
<a href="#BVS">BVS</a>
 - Branch on overflow set - take branch when V flag is set</li>
<li>
<a href="#JML">JML</a>
 - Jump to new code address (24 bit)</li>
<li>
<a href="#JMP">JMP</a>
 - Jump to new code address</li>
<li>
<a href="#JSL">JSL</a>
 - Jump subroutine long - jump to a new code location, save return
				address on stack for RTS (24 bit)
			</li>
<li>
<a href="#JSR">JSR</a>
 - Jump subroutine - jump to a new code location, save return
				address on stack for RTS
			</li>
<li>
<a href="#RTI">RTI</a>
 - Return from interrupt</li>
<li>
<a href="#RTL">RTL</a>
 - Return from subroutine long</li>
<li>
<a href="#RTS">RTS</a>
 - Return from subroutine - read return address from stack</li>
</ul>
<h3>Arithmetic & logic</h3>
<ul>
<li>
<a href="#ADC">ADC</a>
 - Add content of memory location to accumulator</li>
<li>
<a href="#AND">AND</a>
 - Bitwise AND accumulator with content of memory location</li>
<li>
<a href="#ASL">ASL</a>
 - Arithmetic Shift Left - shift accumulator one bit to the left,
				shifting in zero in bit 0
			</li>
<li>
<a href="#BIT">BIT</a>
 - Bitwise test with accumulator - AND the memory location with
				the
				accumulator, and set N (=bit 7), V (=bit 7), Z
				(iff all bits
				zero) flags from the result. In case of the accumulator addressing,
				simply
				set the flags from the
				accumulator
			</li>
<li>
<a href="#CMP">CMP</a>
 - Compare accumulator with content of memory location</li>
<li>
<a href="#CPX">CPX</a>
 - Compare X register with content of memory location</li>
<li>
<a href="#CPY">CPY</a>
 - Compare Y register with content of memory location</li>
<li>
<a href="#DEC">DEC</a>
 - Decrement the content of a memory location by one</li>
<li>
<a href="#DEX">DEX</a>
 - Decrement the content of the X register by one</li>
<li>
<a href="#DEY">DEY</a>
 - Decrement the Y register by one</li>
<li>
<a href="#EOR">EOR</a>
 - Bitwise Exclusive-OR accumulator with content of memory
				location
			</li>
<li>
<a href="#INC">INC</a>
 - Increment the content of a memory location by one</li>
<li>
<a href="#INX">INX</a>
 - Increment the content of the X register by one</li>
<li>
<a href="#INY">INY</a>
 - Increment the content of the Y register by one</li>
<li>
<a href="#LSR">LSR</a>
 - Logical Shift Right - shift accumulator one bit to the right,
				shifting in zero in the highest bit
			</li>
<li>
<a href="#ORA">ORA</a>
 - Bitwise OR accumulator with content of memory location</li>
<li>
<a href="#ROL">ROL</a>
 - Rotate Left - shift accumulator one bit to the left, shifting
				in
				the carry flag in bit 0, and shifting the
				highest bit into the
				carry flag instead.
			</li>
<li>
<a href="#ROR">ROR</a>
 - Rotate Right - shift accumulator one bit to the right, shifting
				in the carry flag in the highest bit, and
				shifting
				bit 0 into the
				carry flag instead.
			</li>
<li>
<a href="#SBC">SBC</a>
 - Substract content of memory location from accumulator</li>
<li>
<a href="#TRB">TRB</a>
 - Test and Reset Bit - AND the memory location with the
				accumulator, and set the Z flag from the result, then
				CLEAR all bits
				in the
				memory location that are set in the accumulator.
			</li>
<li>
<a href="#TSB">TSB</a>
 - Test and Set Bit - AND the memory location with the
				accumulator,
				and set the Z flag from the result, then SET all
				bits in
				the
				memory location that are set in the accumulator.
			</li>
</ul>
<h3>Load/Store</h3>
<ul>
<li>
<a href="#LDA">LDA</a>
 - Load accumulator</li>
<li>
<a href="#LDX">LDX</a>
 - Load X register</li>
<li>
<a href="#LDY">LDY</a>
 - Load Y register</li>
<li>
<a href="#MVN">MVN</a>
 - Move block of data (count index down) 
			</li>
<li>
<a href="#MVP">MVP</a>
 - Move block of data (count index up)
			</li>
<li>
<a href="#PEA">PEA</a>
 - Push effective address (16 bit)</li>
<li>
<a href="#PEI">PEI</a>
 - Push effective indirect address (16 bit)</li>
<li>
<a href="#PER">PER</a>
 - Push effective relative address (16 bit)</li>
<li>
<a href="#PHA">PHA</a>
 - Push contents of the accumulator onto the stack</li>
<li>
<a href="#PHB">PHB</a>
 - Push data bank register DBR to stack</li>
<li>
<a href="#PHD">PHD</a>
 - Push direct page register to stack</li>
<li>
<a href="#PHK">PHK</a>
 - Push program bank register to stack</li>
<li>
<a href="#PHP">PHP</a>
 - Push processor status register onto the stack</li>
<li>
<a href="#PHX">PHX</a>
 - Push contents of the X register onto the stack</li>
<li>
<a href="#PHY">PHY</a>
 - Push contents of the Y register onto the stack</li>
<li>
<a href="#PLA">PLA</a>
 - Pull the contents of the accumulator from the stack</li>
<li>
<a href="#PLB">PLB</a>
 - Pull data bank register DBR from stack</li>
<li>
<a href="#PLD">PLD</a>
 - Pull direct page register from stack</li>
<li>
<a href="#PLP">PLP</a>
 - Pull processor status register from the stack</li>
<li>
<a href="#PLX">PLX</a>
 - Pull the contents of the X register from the stack</li>
<li>
<a href="#PLY">PLY</a>
 - Pull the contents of the Y register from the stack</li>
<li>
<a href="#STA">STA</a>
 - Store the content of the accumulator into a memory location
			</li>
<li>
<a href="#STX">STX</a>
 - Store the content of the X register to memory.</li>
<li>
<a href="#STY">STY</a>
 - Store the content of the Y register to memory.</li>
<li>
<a href="#STZ">STZ</a>
 - Store zero into a memory location</li>
<li>
<a href="#TAX">TAX</a>
 - Transfer the contents of accumulator into the X register</li>
<li>
<a href="#TAY">TAY</a>
 - Transfer the contents of accumulator into the Y register</li>
<li>
<a href="#TCD">TCD</a>
 - Transfer the contents of the 16-bit AC into the 16-bit direct page register</li>
<li>
<a href="#TCS">TCS</a>
 - Transfer the contents of 16-bit AC into the 16-bit stack pointer</li>
<li>
<a href="#TDC">TDC</a>
 - Transfer the contents of direct page register into the 16-bit AC</li>
<li>
<a href="#TSC">TSC</a>
 - Transfer the contents of 16-bit stack pointer into the 16-bit AC</li>
<li>
<a href="#TSX">TSX</a>
 - Transfer the contents of the stack pointer into the X register
				(Note: needs RS to keep compatibility with 6502)
			</li>
<li>
<a href="#TXA">TXA</a>
 - Transfer the contents of the X register into the accumulator
			</li>
<li>
<a href="#TXS">TXS</a>
 - Transfer the contents of X register into the stack pointer
				(Note: needs RS to keep compatibility with 6502)
			</li>
<li>
<a href="#TXY">TXY</a>
 - Transfer the contents of X into the Y register</li>
<li>
<a href="#TYA">TYA</a>
 - Transfer the contents of the Y register into the accumulator
			</li>
<li>
<a href="#TYX">TYX</a>
 - Transfer the contents of Y into the X register</li>
<li>
<a href="#XBA">XBA</a>
 - Exchange A and B 8-bit accumulators (i.e. both halfs of the 16 bit AC)</li>
</ul>
<h3>Load/Store/Pushes/Pulls/Transfer</h3>
<ul>
<li>
<a href="#LDA">LDA</a>
 - Load accumulator</li>
<li>
<a href="#LDX">LDX</a>
 - Load X register</li>
<li>
<a href="#LDY">LDY</a>
 - Load Y register</li>
<li>
<a href="#MVN">MVN</a>
 - Move block of data (count index down) 
			</li>
<li>
<a href="#MVP">MVP</a>
 - Move block of data (count index up)
			</li>
<li>
<a href="#PEA">PEA</a>
 - Push effective address (16 bit)</li>
<li>
<a href="#PEI">PEI</a>
 - Push effective indirect address (16 bit)</li>
<li>
<a href="#PER">PER</a>
 - Push effective relative address (16 bit)</li>
<li>
<a href="#PHA">PHA</a>
 - Push contents of the accumulator onto the stack</li>
<li>
<a href="#PHB">PHB</a>
 - Push data bank register DBR to stack</li>
<li>
<a href="#PHD">PHD</a>
 - Push direct page register to stack</li>
<li>
<a href="#PHK">PHK</a>
 - Push program bank register to stack</li>
<li>
<a href="#PHP">PHP</a>
 - Push processor status register onto the stack</li>
<li>
<a href="#PHX">PHX</a>
 - Push contents of the X register onto the stack</li>
<li>
<a href="#PHY">PHY</a>
 - Push contents of the Y register onto the stack</li>
<li>
<a href="#PLA">PLA</a>
 - Pull the contents of the accumulator from the stack</li>
<li>
<a href="#PLB">PLB</a>
 - Pull data bank register DBR from stack</li>
<li>
<a href="#PLD">PLD</a>
 - Pull direct page register from stack</li>
<li>
<a href="#PLP">PLP</a>
 - Pull processor status register from the stack</li>
<li>
<a href="#PLX">PLX</a>
 - Pull the contents of the X register from the stack</li>
<li>
<a href="#PLY">PLY</a>
 - Pull the contents of the Y register from the stack</li>
<li>
<a href="#STA">STA</a>
 - Store the content of the accumulator into a memory location
			</li>
<li>
<a href="#STX">STX</a>
 - Store the content of the X register to memory.</li>
<li>
<a href="#STY">STY</a>
 - Store the content of the Y register to memory.</li>
<li>
<a href="#STZ">STZ</a>
 - Store zero into a memory location</li>
<li>
<a href="#TAX">TAX</a>
 - Transfer the contents of accumulator into the X register</li>
<li>
<a href="#TAY">TAY</a>
 - Transfer the contents of accumulator into the Y register</li>
<li>
<a href="#TCD">TCD</a>
 - Transfer the contents of the 16-bit AC into the 16-bit direct page register</li>
<li>
<a href="#TCS">TCS</a>
 - Transfer the contents of 16-bit AC into the 16-bit stack pointer</li>
<li>
<a href="#TDC">TDC</a>
 - Transfer the contents of direct page register into the 16-bit AC</li>
<li>
<a href="#TSC">TSC</a>
 - Transfer the contents of 16-bit stack pointer into the 16-bit AC</li>
<li>
<a href="#TSX">TSX</a>
 - Transfer the contents of the stack pointer into the X register
				(Note: needs RS to keep compatibility with 6502)
			</li>
<li>
<a href="#TXA">TXA</a>
 - Transfer the contents of the X register into the accumulator
			</li>
<li>
<a href="#TXS">TXS</a>
 - Transfer the contents of X register into the stack pointer
				(Note: needs RS to keep compatibility with 6502)
			</li>
<li>
<a href="#TXY">TXY</a>
 - Transfer the contents of X into the Y register</li>
<li>
<a href="#TYA">TYA</a>
 - Transfer the contents of the Y register into the accumulator
			</li>
<li>
<a href="#TYX">TYX</a>
 - Transfer the contents of Y into the X register</li>
<li>
<a href="#XBA">XBA</a>
 - Exchange A and B 8-bit accumulators (i.e. both halfs of the 16 bit AC)</li>
</ul>
<h3>Flags</h3>
<ul>
<li>
<a href="#CLC">CLC</a>
 - Clear the C flag</li>
<li>
<a href="#CLD">CLD</a>
 - Clear the decimal (D) flag</li>
<li>
<a href="#CLI">CLI</a>
 - Clear the interrupt (I) flag</li>
<li>
<a href="#CLV">CLV</a>
 - Clear the overflow (V) flag</li>
<li>
<a href="#REP">REP</a>
 - Reset processor status bits</li>
<li>
<a href="#SEC">SEC</a>
 - Set the C flag</li>
<li>
<a href="#SED">SED</a>
 - Set the decimal (D) flag</li>
<li>
<a href="#SEI">SEI</a>
 - Set the interrupt (I) flag</li>
<li>
<a href="#SEP">SEP</a>
 - Set processor status bits</li>
<li>
<a href="#XCE">XCE</a>
 - Exchange Carry and Emulation Flags</li>
</ul>
<h3>Others</h3>
<ul>
<li>
<a href="#COP">COP</a>
 - Coprocessor call</li>
<li>
<a href="#STP">STP</a>
 - Stop processor</li>
<li>
<a href="#WAI">WAI</a>
 - Wait for interrupt</li>
<li>
<a href="#WDM">WDM</a>
 - Reserved for future expansion</li>
</ul>
<h2>Operations</h2>
<h2>BCC</h2>
<a name="BCC"> </a><p>Synonyms: BLT</p>
<p>Branch on carry clear - take branch when C flag is cleared
			</p>
<table class="optable"><tr><th colspan="10">BCC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x90</td><td></td><td>Relative</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					carry status flag is clear. After a CMP this is a
					synonym for "less
					than".
					The parameter is
					a signed 8-bit value, i.e.
					jump distances can be from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand when N=1 else NextPC
				</pre><h2>BCS</h2>
<a name="BCS"> </a><p>Synonyms: BGE</p>
<p>Branch on carry set - take branch when C flag is set</p>
<table class="optable"><tr><th colspan="10">BCS</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xB0</td><td></td><td>Relative</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					carry status flag is set. After a CMP this is a
					synonym for "greater or
					equal".
					The
					parameter is a signed 8-bit
					value, i.e. jump distances can be from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand when N=1 else NextPC
				</pre><h2>BEQ</h2>
<a name="BEQ"> </a><p>Branch on equal - take branch when Z flag is set</p>
<table class="optable"><tr><th colspan="10">BEQ</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xf0</td><td></td><td>Relative</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					zero status flag is set.
					The parameter is a signed
					8-bit value, i.e. jump distances can be
					from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand when N=1 else NextPC
				</pre><h2>BMI</h2>
<a name="BMI"> </a><p>Branch on minus - take branch when N flag is set</p>
<table class="optable"><tr><th colspan="10">BMI</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x30</td><td></td><td>Relative</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					negative status flag is set.
					The parameter is a
					signed 8-bit value, i.e. jump distances can
					be from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand when N=1 else NextPC
				</pre><h2>BNE</h2>
<a name="BNE"> </a><p>Branch on not equal - take branch when Z flag is cleared</p>
<table class="optable"><tr><th colspan="10">BNE</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xD0</td><td></td><td>Relative</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					zero status flag is clear.
					The parameter is a
					signed 8-bit value, i.e. jump distances can
					be from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand when N=1 else NextPC
				</pre><h2>BPL</h2>
<a name="BPL"> </a><p>Branch on plus - take branch when N flag is cleared</p>
<table class="optable"><tr><th colspan="10">BPL</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x10</td><td></td><td>Relative</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					negative status flag is clear.
					The parameter is a
					signed 8-bit value, i.e. jump distances
					can be from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand when N=1 else NextPC
				</pre><h2>BRA</h2>
<a name="BRA"> </a><p>Synonyms: BRU</p>
<p>Branch always - branch independent from any flags</p>
<table class="optable"><tr><th colspan="10">BRA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x80</td><td>cmos</td><td>Relative</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch (always) to the address given by adding the parameter to
					the
					address of the
					next operation (after the branch
					opcode).
					The
					parameter is a signed 8-bit value, i.e. jump distances can be from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand
				</pre><h2>BRK</h2>
<a name="BRK"> </a><p>Starts the break routine.</p>
<table class="optable"><tr><th colspan="10">BRK</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x00</td><td></td><td>Immediate</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					The BRK opcode is used to jump to the BRK vector. It pushes the
					return address and the status on the stack, then
					reads the BRK
					vector
					(doubling as IRQ vector) and jumps there.
				</p><p>
					Please note that the address put on the stack is the address of
					the next
					instruction. And the BRK opcode is using
					the immediate
					addressing
					mode
					(although the MOS manual does not state it). Thus the
					address put on the
					stack is two
					bytes behind the address of the BRK!
				</p><p>
					Before storing the status on the stack, the opcode sets the
					I-flag to
					avoid recursive calling of the interrupt
					routine.
				</p><p>
					When storing the status on the stack, the B-flag is set to
					indicate
					that
					the shared IRQ/BRK vector has been called
					from a BRK
					and not an IRQ.
				</p><pre>
					Stack(SP--) &lt;= > NextPC
					Stack(SP--) &lt;= &lt;
					NextPC
					Stack(SP--) &lt;= Status | B | I
					PC
					&lt;= ($FFFE)
				</pre><h2>BRL</h2>
<a name="BRL"> </a><p>Branch always - branch independent from any flags</p>
<table class="optable"><tr><th colspan="10">BRL</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x82</td><td>816ce02</td><td>Relative 16bit</td><td></td><td></td></tr>
</table>
<h2>BVC</h2>
<a name="BVC"> </a><p>Branch on overflow clear - take branch when V flag is cleared
			</p>
<table class="optable"><tr><th colspan="10">BVC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x50</td><td></td><td>Relative</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					overflow status flag is clear.
					The parameter is a
					signed 8-bit value, i.e. jump distances
					can be from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand when N=1 else NextPC
				</pre><h2>BVS</h2>
<a name="BVS"> </a><p>Branch on overflow set - take branch when V flag is set</p>
<table class="optable"><tr><th colspan="10">BVS</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x70</td><td></td><td>Relative</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Branch to the address given by adding the parameter to the
					address of the
					next operation (after the branch opcode)
					given the
					condition that
					the
					overflow status flag is set.
					The parameter is a
					signed 8-bit value, i.e. jump distances can
					be from
					-128 to +127.
				</p><pre>
					PC &lt;= NextPC + Operand when N=1 else NextPC
				</pre><h2>JML</h2>
<a name="JML"> </a><p>Jump to new code address (24 bit)</p>
<table class="optable"><tr><th colspan="10">JML</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xdc</td><td>816</td><td>Absolute indirect 24bit</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Jump to the address given by the operand (as computed depending
					on the
					respective addressing mode).
				</p><pre>
					PC &lt;= Operand
				</pre><h2>JMP</h2>
<a name="JMP"> </a><p>Jump to new code address</p>
<table class="optable"><tr><th colspan="10">JMP</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x4c</td><td></td><td>Address</td><td></td><td></td></tr>
<tr><td></td><td>0x5c</td><td>816</td><td>Address</td><td></td><td></td></tr>
<tr><td></td><td>0x6c</td><td></td><td>Absolute indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x7c</td><td>cmos</td><td>Absolute indexed with X indirect 16bit</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Jump to the address given by the operand (as computed depending
					on the
					respective addressing mode).
				</p><pre>
					PC &lt;= Operand
				</pre><h2>JSL</h2>
<a name="JSL"> </a><p>Jump subroutine long - jump to a new code location, save return
				address on stack for RTS (24 bit)
			</p>
<table class="optable"><tr><th colspan="10">JSL</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x22</td><td>816</td><td>Address</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Jump to the address given by the operand (as computed depending
					on the
					respective addressing mode) and
					store first the program bank register, then the
					return address (-1)
					on the stack to prepare for the RTL opcode
				</p><pre>
					Stack(SP--) &lt;= > PBR
					Stack(SP--) &lt;= > NextPC-1
					Stack(SP--) &lt;=
					&lt; NextPC-1
					PC &lt;= Operand
				</pre><h2>JSR</h2>
<a name="JSR"> </a><p>Jump subroutine - jump to a new code location, save return
				address on stack for RTS
			</p>
<table class="optable"><tr><th colspan="10">JSR</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x20</td><td></td><td>Address</td><td></td><td></td></tr>
<tr><td></td><td>0xfc</td><td>816</td><td>Absolute indexed with X indirect 16bit</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Jump to the address given by the operand (as computed depending
					on the
					respective addressing mode) and
					store the
					return address (-1)
					on the stack to prepare for the RTS opcode
				</p><pre>
					Stack(SP--) &lt;= > NextPC-1
					Stack(SP--) &lt;=
					&lt; NextPC-1
					PC &lt;= Operand
				</pre><h2>RTI</h2>
<a name="RTI"> </a><p>Return from interrupt</p>
<table class="optable"><tr><th colspan="10">RTI</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x40</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Returns from an interrupt or a BRK opcode handling. It first
					pulls the
					status register from the stack, then
					takes
					the return
					address from the stack, increment it by one, and
					continue at the new
					address.
				</p><pre>
					Status &lt;= Stack(++SP) -- bit 5=1
					Tmp(0-7) &lt;=
					Stack(++SP)
					Tmp(8-15) &lt;= Stack(++SP)
					PC &lt;=
					Tmp;
				</pre><h2>RTL</h2>
<a name="RTL"> </a><p>Return from subroutine long</p>
<table class="optable"><tr><th colspan="10">RTL</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x6b</td><td>816</td><td>Implied</td><td></td><td></td></tr>
</table>
<h2>RTS</h2>
<a name="RTS"> </a><p>Return from subroutine - read return address from stack</p>
<table class="optable"><tr><th colspan="10">RTS</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x60</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Take the return address from the stack, increment it by one, and
					continue at the new address.
				</p><pre>
					Tmp(0-7) &lt;= Stack(++SP)
					Tmp(8-15) &lt;= Stack(++SP)
					PC &lt;= Tmp + 1;
				</pre><h2>ADC</h2>
<a name="ADC"> </a><p>Add content of memory location to accumulator</p>
<table class="optable"><tr><th colspan="10">ADC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x61</td><td></td><td>Zeropage indexed with X indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x65</td><td></td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x69</td><td></td><td>Immediate</td><td></td><td></td></tr>
<tr><td></td><td>0x6d</td><td></td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x71</td><td></td><td>Zeropage indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x72</td><td>cmos_ind</td><td>Zeropage indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x75</td><td></td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x79</td><td></td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x7d</td><td></td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x63</td><td>816</td><td>Stack-relative with offset</td><td></td><td></td></tr>
<tr><td></td><td>0x73</td><td>816</td><td>Stack Vector indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x6f</td><td>816</td><td>Absolute 24bit</td><td></td><td></td></tr>
<tr><td></td><td>0x7f</td><td>816</td><td>Absolute 24bit indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x67</td><td>816</td><td>Absolute indirect 24bit</td><td></td><td></td></tr>
<tr><td></td><td>0x77</td><td>816</td><td>Absolute indirect 24bit indexed with Y</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Add the operand to the accumulator and store back in the
					accumulator.
					Set the flags from the result. Use Decimal or
					Binary
					add depending
					on whether the
					decimal mode status bis is set or not
					respectively.
				</p><pre>
					AC, C, V &lt;= AC + Operand, C
					N &lt;= Tmp(7)
					Z &lt;=
					Z(Tmp)
				</pre><p>
					For a handling of the V-flag please see
					<a href="http://www.6502.org/tutorials/vflag.html">http://www.6502.org/tutorials/vflag.html</a>
					.
				</p><h2>AND</h2>
<a name="AND"> </a><p>Bitwise AND accumulator with content of memory location</p>
<table class="optable"><tr><th colspan="10">AND</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x21</td><td></td><td>Zeropage indexed with X indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x25</td><td></td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x29</td><td></td><td>Immediate</td><td></td><td></td></tr>
<tr><td></td><td>0x2d</td><td></td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x31</td><td></td><td>Zeropage indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x32</td><td>cmos_ind</td><td>Zeropage indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x35</td><td></td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x39</td><td></td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x3d</td><td></td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x23</td><td>816</td><td>Stack-relative with offset</td><td></td><td></td></tr>
<tr><td></td><td>0x33</td><td>816</td><td>Stack Vector indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x2f</td><td>816</td><td>Absolute 24bit</td><td></td><td></td></tr>
<tr><td></td><td>0x3f</td><td>816</td><td>Absolute 24bit indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x27</td><td>816</td><td>Absolute indirect 24bit</td><td></td><td></td></tr>
<tr><td></td><td>0x37</td><td>816</td><td>Absolute indirect 24bit indexed with Y</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Bitwise AND the accumulator with the operand and store back in
					the
					accumulator.
					Set the flags from the result.
				</p><pre>
					AC &lt;= AC &amp; Operand
					N &lt;= Tmp(7)
					Z &lt;=
					Z(Tmp)
				</pre><h2>ASL</h2>
<a name="ASL"> </a><p>Arithmetic Shift Left - shift accumulator one bit to the left,
				shifting in zero in bit 0
			</p>
<table class="optable"><tr><th colspan="10">ASL</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x06</td><td></td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x0a</td><td></td><td>Accumulator</td><td></td><td></td></tr>
<tr><td></td><td>0x0e</td><td></td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x16</td><td></td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x1e</td><td></td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Shift the operand or accumulator left one bit (i.e. multiply by
					2).
					Shift
					in a zero from the right.
					The bit shifted
					out is moved into
					the carry flag.
					Note this opcode is a read-modify-write opcode and
					not only has
					memory-oriented
					addressing modes but can work
					on the
					accumulator alone as well.
				</p><pre>
					C &lt;= AC(7)
					AC(7-1) &lt;= AC(6-0)
					AC(0) &lt;= 0
					N
					&lt;= AC7)
					Z &lt;= Z(AC)
				</pre><h2>BIT</h2>
<a name="BIT"> </a><p>Bitwise test with accumulator - AND the memory location with
				the
				accumulator, and set N (=bit 7), V (=bit 7), Z
				(iff all bits
				zero) flags from the result. In case of the accumulator addressing,
				simply
				set the flags from the
				accumulator
			</p>
<table class="optable"><tr><th colspan="10">BIT</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x24</td><td></td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x2c</td><td></td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x34</td><td>cmos</td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x3c</td><td>cmos</td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x89</td><td>cmos</td><td>Immediate</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Read the operand and set the N and V flags from the value (from
					the
					highest and next-to-highest bit respectively).
					Then take the
					operand, and AND it with the accumulator and evaluate the
					Z-flag.
				</p><pre>
					N &lt;= Operand(7)
					V &lt;= Operand(6)
					Tmp &lt;=
					Operand &amp; AC
					Z &lt;= Z(Tmp)
				</pre><h2>CMP</h2>
<a name="CMP"> </a><p>Compare accumulator with content of memory location</p>
<table class="optable"><tr><th colspan="10">CMP</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xc1</td><td></td><td>Zeropage indexed with X indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0xc5</td><td></td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0xc9</td><td></td><td>Immediate</td><td></td><td></td></tr>
<tr><td></td><td>0xcd</td><td></td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0xd1</td><td></td><td>Zeropage indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0xd2</td><td>cmos_ind</td><td>Zeropage indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0xd5</td><td></td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0xd9</td><td></td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0xdd</td><td></td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0xc3</td><td>816</td><td>Stack-relative with offset</td><td></td><td></td></tr>
<tr><td></td><td>0xd3</td><td>816</td><td>Stack Vector indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0xcf</td><td>816</td><td>Absolute 24bit</td><td></td><td></td></tr>
<tr><td></td><td>0xdf</td><td>816</td><td>Absolute 24bit indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0xc7</td><td>816</td><td>Absolute indirect 24bit</td><td></td><td></td></tr>
<tr><td></td><td>0xd7</td><td>816</td><td>Absolute indirect 24bit indexed with Y</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Compare the operand with the accumulator and set the flags
					appropriately.
					I.e. substract the operand from AC with
					an
					implicitely set carry in
					binary mode (even if
					decimal mode status bit
					is set), and set the flags from the result.
				</p><pre>
					Tmp, C &lt;= Y - Operand, C=1
					N &lt;= Tmp(7)
					Z &lt;=
					Z(Tmp)
				</pre><h2>CPX</h2>
<a name="CPX"> </a><p>Compare X register with content of memory location</p>
<table class="optable"><tr><th colspan="10">CPX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xe0</td><td></td><td>Immediate</td><td></td><td></td></tr>
<tr><td></td><td>0xe4</td><td></td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0xec</td><td></td><td>Absolute 16bit</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Compare the operand with the X register and set the flags
					appropriately.
					I.e. substract the operand from X with an
					implicitly
					set carry in
					binary mode (even if
					decimal mode status bit is set),
					and set the flags from the result.
				</p><pre>
					Tmp, C &lt;= X - Operand, C=1
					N &lt;= Tmp(7)
					Z &lt;=
					Z(Tmp)
				</pre><h2>CPY</h2>
<a name="CPY"> </a><p>Compare Y register with content of memory location</p>
<table class="optable"><tr><th colspan="10">CPY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xc0</td><td></td><td>Immediate</td><td></td><td></td></tr>
<tr><td></td><td>0xc4</td><td></td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0xcc</td><td></td><td>Absolute 16bit</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Compare the operand with the Y register and set the flags
					appropriately.
					I.e. substract the operand from Y with an
					implicitly
					set carry in
					binary mode (even if
					decimal mode status bit is set),
					and set the flags from the result.
				</p><pre>
					Tmp, C &lt;= Y - Operand, C=1
					N &lt;= Tmp(7)
					Z &lt;=
					Z(Tmp)
				</pre><h2>DEC</h2>
<a name="DEC"> </a><p>Decrement the content of a memory location by one</p>
<table class="optable"><tr><th colspan="10">DEC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xc6</td><td></td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x3a</td><td>cmos</td><td>Accumulator</td><td></td><td></td></tr>
<tr><td></td><td>0xce</td><td></td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0xd6</td><td></td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0xde</td><td></td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Decrement the operand by one, i.e. binary substract one.
					Note this
					opcode is a read-modify-write opcode and not
					only has
					memory-oriented addressing modes but can work
					on the accumulator
					alone as well.
				</p><pre>
					Operand &lt;= Operand - 1
					N &lt;= OperandC7)
					Z &lt;=
					Z(AC)
				</pre><h2>DEX</h2>
<a name="DEX"> </a><p>Decrement the content of the X register by one</p>
<table class="optable"><tr><th colspan="10">DEX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xca</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Decrement the X register by one (binary).
				</p><pre>
					X &lt;= X-1
				</pre><h2>DEY</h2>
<a name="DEY"> </a><p>Decrement the Y register by one</p>
<table class="optable"><tr><th colspan="10">DEY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x88</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Decrement the Y register by one (binary).
				</p><pre>
					Y &lt;= Y-1
				</pre><h2>EOR</h2>
<a name="EOR"> </a><p>Bitwise Exclusive-OR accumulator with content of memory
				location
			</p>
<table class="optable"><tr><th colspan="10">EOR</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x41</td><td></td><td>Zeropage indexed with X indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x45</td><td></td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x49</td><td></td><td>Immediate</td><td></td><td></td></tr>
<tr><td></td><td>0x4d</td><td></td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x51</td><td></td><td>Zeropage indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x52</td><td>cmos_ind</td><td>Zeropage indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x55</td><td></td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x59</td><td></td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x5d</td><td></td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x43</td><td>816</td><td>Stack-relative with offset</td><td></td><td></td></tr>
<tr><td></td><td>0x53</td><td>816</td><td>Stack Vector indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x4f</td><td>816</td><td>Absolute 24bit</td><td></td><td></td></tr>
<tr><td></td><td>0x5f</td><td>816</td><td>Absolute 24bit indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x47</td><td>816</td><td>Absolute indirect 24bit</td><td></td><td></td></tr>
<tr><td></td><td>0x57</td><td>816</td><td>Absolute indirect 24bit indexed with Y</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Bitwise Exclusive-OR the accumulator with the operand and store
					back in
					the
					accumulator.
					Set the flags from the
					result.
				</p><pre>
					AC &lt;= AC ^ Operand
					N &lt;= Tmp(7)
					Z &lt;= Z(Tmp)
				</pre><h2>INC</h2>
<a name="INC"> </a><p>Increment the content of a memory location by one</p>
<table class="optable"><tr><th colspan="10">INC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xe6</td><td></td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x1a</td><td>cmos</td><td>Accumulator</td><td></td><td></td></tr>
<tr><td></td><td>0xee</td><td></td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0xf6</td><td></td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0xfe</td><td></td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Increment the operand by one, i.e. binary add one.
					Note this
					opcode is a read-modify-write opcode and not only has
					memory-oriented addressing modes but can work
					on the accumulator
					alone as well.
				</p><pre>
					Operand &lt;= Operand + 1
					N &lt;= OperandC7)
					Z &lt;=
					Z(AC)
				</pre><h2>INX</h2>
<a name="INX"> </a><p>Increment the content of the X register by one</p>
<table class="optable"><tr><th colspan="10">INX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xe8</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Increment the X register by one (binary).
				</p><pre>
					X &lt;= X+1
				</pre><h2>INY</h2>
<a name="INY"> </a><p>Increment the content of the Y register by one</p>
<table class="optable"><tr><th colspan="10">INY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xc8</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Increment the Y register by one (binary).
				</p><pre>
					Y &lt;= Y+1
				</pre><h2>LSR</h2>
<a name="LSR"> </a><p>Logical Shift Right - shift accumulator one bit to the right,
				shifting in zero in the highest bit
			</p>
<table class="optable"><tr><th colspan="10">LSR</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x46</td><td></td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x4a</td><td></td><td>Accumulator</td><td></td><td></td></tr>
<tr><td></td><td>0x4e</td><td></td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x56</td><td></td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x5e</td><td></td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Shift the operand or accumulator right one bit (i.e. divide by
					2). Shift
					in a zero from the left.
					The bit shifted
					out is moved into
					the carry flag.
					Note this opcode is a read-modify-write opcode and
					not only has
					memory-oriented
					addressing modes but can work
					on the
					accumulator alone as well.
				</p><pre>
					C &lt;= AC(0)
					AC(6-0) &lt;= AC(7-1)
					AC(7) &lt;= 0
					N
					&lt;= AC7)
					Z &lt;= Z(AC)
				</pre><h2>ORA</h2>
<a name="ORA"> </a><p>Bitwise OR accumulator with content of memory location</p>
<table class="optable"><tr><th colspan="10">ORA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x01</td><td></td><td>Zeropage indexed with X indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x05</td><td></td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x09</td><td></td><td>Immediate</td><td></td><td></td></tr>
<tr><td></td><td>0x0d</td><td></td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x11</td><td></td><td>Zeropage indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x12</td><td>cmos_ind</td><td>Zeropage indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x15</td><td></td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x19</td><td></td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x1d</td><td></td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x03</td><td>816</td><td>Stack-relative with offset</td><td></td><td></td></tr>
<tr><td></td><td>0x13</td><td>816</td><td>Stack Vector indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x0f</td><td>816</td><td>Absolute 24bit</td><td></td><td></td></tr>
<tr><td></td><td>0x1f</td><td>816</td><td>Absolute 24bit indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x07</td><td>816</td><td>Absolute indirect 24bit</td><td></td><td></td></tr>
<tr><td></td><td>0x17</td><td>816</td><td>Absolute indirect 24bit indexed with Y</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Bitwise OR the accumulator with the operand and store back in the
					accumulator.
					Set the flags from the result.
				</p><pre>
					AC &lt;= AC | Operand
					N &lt;= Tmp(7)
					Z &lt;= Z(Tmp)
				</pre><h2>ROL</h2>
<a name="ROL"> </a><p>Rotate Left - shift accumulator one bit to the left, shifting
				in
				the carry flag in bit 0, and shifting the
				highest bit into the
				carry flag instead.
			</p>
<table class="optable"><tr><th colspan="10">ROL</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x26</td><td></td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x2a</td><td></td><td>Accumulator</td><td></td><td></td></tr>
<tr><td></td><td>0x2e</td><td></td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x36</td><td></td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x3e</td><td></td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Shift the operand or accumulator left one bit (i.e. multiply by
					2).
					Shift
					in the carry flag from the right.
					The bit
					shifted out is
					moved into the carry flag.
					Note this opcode is a read-modify-write
					opcode and not only has
					memory-oriented addressing modes but can
					work
					on the accumulator alone as well.
				</p><pre>
					Tmp &lt;= AC(7)
					AC(7-1) &lt;= AC(6-0)
					AC(0) &lt;= C
					C
					&lt;= Tmp
					N &lt;= AC7)
					Z &lt;= Z(AC)
				</pre><h2>ROR</h2>
<a name="ROR"> </a><p>Rotate Right - shift accumulator one bit to the right, shifting
				in the carry flag in the highest bit, and
				shifting
				bit 0 into the
				carry flag instead.
			</p>
<table class="optable"><tr><th colspan="10">ROR</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x66</td><td>ror</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x6a</td><td>ror</td><td>Accumulator</td><td></td><td></td></tr>
<tr><td></td><td>0x6e</td><td>ror</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x76</td><td>ror</td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x7e</td><td>ror</td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Shift the operand or accumulator right one bit (i.e. divide by
					2). Shift
					in the carry flag from the left.
					The bit
					shifted out is
					moved into the carry flag.
					Note this opcode is a read-modify-write
					opcode and not only has
					memory-oriented addressing modes but can
					work
					on the accumulator alone as well.
				</p><pre>
					Tmp &lt;= AC(0)
					AC(6-0) &lt;= AC(7-1)
					AC(7) &lt;= C
					C
					&lt;= Tmp
					N &lt;= AC7)
					Z &lt;= Z(AC)
				</pre><h2>SBC</h2>
<a name="SBC"> </a><p>Substract content of memory location from accumulator</p>
<table class="optable"><tr><th colspan="10">SBC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xe1</td><td></td><td>Zeropage indexed with X indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0xe5</td><td></td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0xe9</td><td></td><td>Immediate</td><td></td><td></td></tr>
<tr><td></td><td>0xed</td><td></td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0xf1</td><td></td><td>Zeropage indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0xf2</td><td>cmos_ind</td><td>Zeropage indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0xf5</td><td></td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0xf9</td><td></td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0xfd</td><td></td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0xe3</td><td>816</td><td>Stack-relative with offset</td><td></td><td></td></tr>
<tr><td></td><td>0xf3</td><td>816</td><td>Stack Vector indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0xef</td><td>816</td><td>Absolute 24bit</td><td></td><td></td></tr>
<tr><td></td><td>0xff</td><td>816</td><td>Absolute 24bit indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0xe7</td><td>816</td><td>Absolute indirect 24bit</td><td></td><td></td></tr>
<tr><td></td><td>0xf7</td><td>816</td><td>Absolute indirect 24bit indexed with Y</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Substract the operand from the accumulator and store back in the
					accumulator.
					Set the flags from the result. Use
					Decimal or Binary
					add depending
					on whether the
					decimal mode status bis is set or not
					respectively. C status flag is
					used
					as borrow.
				</p><pre>
					AC, C, V &lt;= AC - Operand, C
					N &lt;= Tmp(7)
					Z &lt;=
					Z(Tmp)
				</pre><p>
					For a handling of the V-flag please see
					<a href="http://www.6502.org/tutorials/vflag.html">http://www.6502.org/tutorials/vflag.html</a>
					.
				</p><h2>TRB</h2>
<a name="TRB"> </a><p>Test and Reset Bit - AND the memory location with the
				accumulator, and set the Z flag from the result, then
				CLEAR all bits
				in the
				memory location that are set in the accumulator.
			</p>
<table class="optable"><tr><th colspan="10">TRB</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x14</td><td>cmos</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x1c</td><td>cmos</td><td>Absolute 16bit</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Take the operand, and AND it with the accumulator and evaluate
					the
					Z-flag. Then clear all bits in the operand
					that
					are set in the
					accumulator (basically AND with the inverse of the
					accumulator),
					and
					store the value back.
				</p><p>
					The use case for this opcode is the synchronization between
					processes
					and implements a variant of the
					"test-and-clear"
					primitive. Thus this is a Read-Modify-Write operation and will
					trigger a
					Memory-Lock between the read
					and write
					to make that
					operation atomic.
				</p><pre>
					Tmp &lt;= operand &amp; AC
					Z &lt;= Z(Tmp)
					operand
					&lt; operand | AC
				</pre><h2>TSB</h2>
<a name="TSB"> </a><p>Test and Set Bit - AND the memory location with the
				accumulator,
				and set the Z flag from the result, then SET all
				bits in
				the
				memory location that are set in the accumulator.
			</p>
<table class="optable"><tr><th colspan="10">TSB</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x04</td><td>cmos</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x0c</td><td>cmos</td><td>Absolute 16bit</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Take the operand, and AND it with the accumulator and evaluate
					the
					Z-flag. Then OR the operand with the accumulator
					and store the
					value back.
				</p><p>
					The use case for this opcode is the synchronization between
					processes
					and implements a variant of the
					"test-and-set"
					primitive.
					Thus this is a Read-Modify-Write operation and will trigger a
					Memory-Lock between the read
					and write
					to make that operation
					atomic.
				</p><pre>
					Tmp &lt;= operand &amp; AC
					Z &lt;= Z(Tmp)
					operand
					&lt; operand | AC
				</pre><h2>LDA</h2>
<a name="LDA"> </a><p>Load accumulator</p>
<table class="optable"><tr><th colspan="10">LDA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xa1</td><td></td><td>Zeropage indexed with X indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0xa5</td><td></td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0xa9</td><td></td><td>Immediate</td><td></td><td></td></tr>
<tr><td></td><td>0xad</td><td></td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0xb1</td><td></td><td>Zeropage indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0xb2</td><td>cmos_ind</td><td>Zeropage indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0xb5</td><td></td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0xb9</td><td></td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0xbd</td><td></td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0xa3</td><td>816</td><td>Stack-relative with offset</td><td></td><td></td></tr>
<tr><td></td><td>0xb3</td><td>816</td><td>Stack Vector indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0xaf</td><td>816</td><td>Absolute 24bit</td><td></td><td></td></tr>
<tr><td></td><td>0xbf</td><td>816</td><td>Absolute 24bit indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0xa7</td><td>816</td><td>Absolute indirect 24bit</td><td></td><td></td></tr>
<tr><td></td><td>0xb7</td><td>816</td><td>Absolute indirect 24bit indexed with Y</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Read the operand and store it in the Accumulator. Set the flags
					appropriately.
				</p><pre>
					N &lt;= Operand(7)
					Z &lt;= Z(Operand)
					Y &lt;= Operand
				</pre><h2>LDX</h2>
<a name="LDX"> </a><p>Load X register</p>
<table class="optable"><tr><th colspan="10">LDX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xa2</td><td></td><td>Immediate</td><td></td><td></td></tr>
<tr><td></td><td>0xa6</td><td></td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0xae</td><td></td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0xb6</td><td></td><td>Zeropage indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0xbe</td><td></td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Read the operand and store it in the X register. Set the flags
					appropriately.
				</p><pre>
					N &lt;= Operand(7)
					Z &lt;= Z(Operand)
					X &lt;= Operand
				</pre><h2>LDY</h2>
<a name="LDY"> </a><p>Load Y register</p>
<table class="optable"><tr><th colspan="10">LDY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xa0</td><td></td><td>Immediate</td><td></td><td></td></tr>
<tr><td></td><td>0xa4</td><td></td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0xac</td><td></td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0xb4</td><td></td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0xbc</td><td></td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Read the operand and store it in the Y register. Set the flags
					appropriately.
				</p><pre>
					N &lt;= Operand(7)
					Z &lt;= Z(Operand)
					Y &lt;= Operand
				</pre><h2>MVN</h2>
<a name="MVN"> </a><p>Move block of data (count index down) 
			</p>
<table class="optable"><tr><th colspan="10">MVN</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x54</td><td>816</td><td>Double Immediate</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
				 x=source address, y=destination address, ac=number of bytes; the two immediate parameters
				 are the destination and source data bank numbers respectively.
				</p><h2>MVP</h2>
<a name="MVP"> </a><p>Move block of data (count index up)
			</p>
<table class="optable"><tr><th colspan="10">MVP</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x44</td><td>816</td><td>Double Immediate</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
				 x=source address, y=destination address, ac=number of bytes; the two immediate parameters
				 are the destination and source data bank numbers respectively.
				</p><h2>PEA</h2>
<a name="PEA"> </a><p>Push effective address (16 bit)</p>
<table class="optable"><tr><th colspan="10">PEA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xf4</td><td>816</td><td>Immediate 16bit</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Push the immediate value from the operand onto the stack (as 16 bit value).
				</p><pre>
					Stack(SP--) &lt;= operand
				</pre><h2>PEI</h2>
<a name="PEI"> </a><p>Push effective indirect address (16 bit)</p>
<table class="optable"><tr><th colspan="10">PEI</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xd4</td><td>816</td><td>Zeropage</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Push the address to the stack that would result as effective operand address if the operand were used in an indirect
					addressing mode. I.e. read the value at the given direct page operand, and push it onto the stack (as 16 bit value).
				</p><pre>
					Stack(SP--) &lt;= (operand)
				</pre><h2>PER</h2>
<a name="PER"> </a><p>Push effective relative address (16 bit)</p>
<table class="optable"><tr><th colspan="10">PER</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x62</td><td>816ce02</td><td>Relative 16bit</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Take the address given as parameter, add the current program counter, and push the resulting
					address onto the stack (as 16 bit value). This is similar to pushing the offset of a branch instruction.
				</p><pre>
					Stack(SP--) &lt;= operand - PC + 1
				</pre><h2>PHA</h2>
<a name="PHA"> </a><p>Push contents of the accumulator onto the stack</p>
<table class="optable"><tr><th colspan="10">PHA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x48</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Push the content of the accumulator on the stack.
				</p><pre>
					Stack(SP--) &lt;= A
				</pre><h2>PHB</h2>
<a name="PHB"> </a><p>Push data bank register DBR to stack</p>
<table class="optable"><tr><th colspan="10">PHB</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x8b</td><td>816</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Push the value of the data bank register register to the stack.
				</p><pre>
					Stack(SP--) &lt;= DBR
				</pre><h2>PHD</h2>
<a name="PHD"> </a><p>Push direct page register to stack</p>
<table class="optable"><tr><th colspan="10">PHD</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x0b</td><td>816</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Push the value of the direct page register register to the stack.
				</p><pre>
					Stack(SP--) &lt;= DPR
				</pre><h2>PHK</h2>
<a name="PHK"> </a><p>Push program bank register to stack</p>
<table class="optable"><tr><th colspan="10">PHK</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x4b</td><td>816</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Push the value of the program bank register register to the stack.
				</p><pre>
					Stack(SP--) &lt;= PBR
				</pre><h2>PHP</h2>
<a name="PHP"> </a><p>Push processor status register onto the stack</p>
<table class="optable"><tr><th colspan="10">PHP</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x08</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Push the standard status register on the stack.
				</p><pre>
					Stack(SP--) &lt;= Status
				</pre><h2>PHX</h2>
<a name="PHX"> </a><p>Push contents of the X register onto the stack</p>
<table class="optable"><tr><th colspan="10">PHX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xda</td><td>cmos</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Push the content of the X register on the stack.
				</p><pre>
					Stack(SP--) &lt;= X
				</pre><h2>PHY</h2>
<a name="PHY"> </a><p>Push contents of the Y register onto the stack</p>
<table class="optable"><tr><th colspan="10">PHY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x5a</td><td>cmos</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Push the content of the Y register on the stack.
				</p><pre>
					Stack(SP--) &lt;= Y
				</pre><h2>PLA</h2>
<a name="PLA"> </a><p>Pull the contents of the accumulator from the stack</p>
<table class="optable"><tr><th colspan="10">PLA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x68</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Pull the value of the accumulator from the stack.
				</p><pre>
					A &lt;= Stack(++SP)
				</pre><h2>PLB</h2>
<a name="PLB"> </a><p>Pull data bank register DBR from stack</p>
<table class="optable"><tr><th colspan="10">PLB</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xab</td><td>816</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Pull the value of the data bank register register from the stack.
				</p><pre>
					DBR &lt;= Stack(++SP)
				</pre><h2>PLD</h2>
<a name="PLD"> </a><p>Pull direct page register from stack</p>
<table class="optable"><tr><th colspan="10">PLD</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x2b</td><td>816</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Pull the value of the direct page register register from the stack.
				</p><pre>
					DPR &lt;= Stack(++SP)
				</pre><h2>PLP</h2>
<a name="PLP"> </a><p>Pull processor status register from the stack</p>
<table class="optable"><tr><th colspan="10">PLP</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x28</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Pull the standard status register on the stack.
				</p><pre>
					Status &lt;= Stack(++SP)
				</pre><h2>PLX</h2>
<a name="PLX"> </a><p>Pull the contents of the X register from the stack</p>
<table class="optable"><tr><th colspan="10">PLX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xfa</td><td>cmos</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Pull the value of the X register from the stack.
				</p><pre>
					X &lt;= Stack(++SP)
				</pre><h2>PLY</h2>
<a name="PLY"> </a><p>Pull the contents of the Y register from the stack</p>
<table class="optable"><tr><th colspan="10">PLY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x7a</td><td>cmos</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Pull the value of the Y register from the stack.
				</p><pre>
					Y &lt;= Stack(++SP)
				</pre><h2>STA</h2>
<a name="STA"> </a><p>Store the content of the accumulator into a memory location
			</p>
<table class="optable"><tr><th colspan="10">STA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x81</td><td></td><td>Zeropage indexed with X indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x85</td><td></td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x8d</td><td></td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x91</td><td></td><td>Zeropage indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x92</td><td>cmos_ind</td><td>Zeropage indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x95</td><td></td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x99</td><td></td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x9d</td><td></td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x83</td><td>816</td><td>Stack-relative with offset</td><td></td><td></td></tr>
<tr><td></td><td>0x93</td><td>816</td><td>Stack Vector indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x8f</td><td>816</td><td>Absolute 24bit</td><td></td><td></td></tr>
<tr><td></td><td>0x9f</td><td>816</td><td>Absolute 24bit indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x87</td><td>816</td><td>Absolute indirect 24bit</td><td></td><td></td></tr>
<tr><td></td><td>0x97</td><td>816</td><td>Absolute indirect 24bit indexed with Y</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Store the accumulator into the address given by the operand.
				</p><pre>
					Operand &lt;= A
				</pre><h2>STX</h2>
<a name="STX"> </a><p>Store the content of the X register to memory.</p>
<table class="optable"><tr><th colspan="10">STX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x86</td><td></td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x8e</td><td></td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x96</td><td></td><td>Zeropage indexed with Y</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Store the content of the X register into the address given by the
					operand.
				</p><pre>
					Operand &lt;= A
				</pre><h2>STY</h2>
<a name="STY"> </a><p>Store the content of the Y register to memory.</p>
<table class="optable"><tr><th colspan="10">STY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x84</td><td></td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x8c</td><td></td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x94</td><td></td><td>Zeropage indexed with X</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Store the content of the Y register into the address given by the
					operand.
				</p><pre>
					Operand &lt;= A
				</pre><h2>STZ</h2>
<a name="STZ"> </a><p>Store zero into a memory location</p>
<table class="optable"><tr><th colspan="10">STZ</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x64</td><td>cmos</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x74</td><td>cmos</td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x9c</td><td>cmos</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x9e</td><td>cmos</td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Store zero into the address given by the operand.
				</p><pre>
					Operand &lt;= 0
				</pre><h2>TAX</h2>
<a name="TAX"> </a><p>Transfer the contents of accumulator into the X register</p>
<table class="optable"><tr><th colspan="10">TAX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xaa</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the accumulator to the X register
				</p><pre>
					X &lt;= A
				</pre><h2>TAY</h2>
<a name="TAY"> </a><p>Transfer the contents of accumulator into the Y register</p>
<table class="optable"><tr><th colspan="10">TAY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xa8</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the accumulator to the Y register
				</p><pre>
					Y &lt;= A
				</pre><h2>TCD</h2>
<a name="TCD"> </a><p>Transfer the contents of the 16-bit AC into the 16-bit direct page register</p>
<table class="optable"><tr><th colspan="10">TCD</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x5b</td><td>816</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the A to the DPR register (16 bit)
				</p><pre>
					DPR &lt;= A
				</pre><h2>TCS</h2>
<a name="TCS"> </a><p>Transfer the contents of 16-bit AC into the 16-bit stack pointer</p>
<table class="optable"><tr><th colspan="10">TCS</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x1b</td><td>816</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the A to the S register (16 bit)
				</p><pre>
					S &lt;= A
				</pre><h2>TDC</h2>
<a name="TDC"> </a><p>Transfer the contents of direct page register into the 16-bit AC</p>
<table class="optable"><tr><th colspan="10">TDC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x7b</td><td>816</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the DPR to the A register (16 bit)
				</p><pre>
					A &lt;= DPR
				</pre><h2>TSC</h2>
<a name="TSC"> </a><p>Transfer the contents of 16-bit stack pointer into the 16-bit AC</p>
<table class="optable"><tr><th colspan="10">TSC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x3b</td><td>816</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the S to the A register (16 bit)
				</p><pre>
					A &lt;= S
				</pre><h2>TSX</h2>
<a name="TSX"> </a><p>Transfer the contents of the stack pointer into the X register
				(Note: needs RS to keep compatibility with 6502)
			</p>
<table class="optable"><tr><th colspan="10">TSX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xba</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the stack pointer to the X register
				</p><pre>
					X &lt;= S
				</pre><h2>TXA</h2>
<a name="TXA"> </a><p>Transfer the contents of the X register into the accumulator
			</p>
<table class="optable"><tr><th colspan="10">TXA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x8a</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the X register to the accumulator
				</p><pre>
					A &lt;= X
				</pre><h2>TXS</h2>
<a name="TXS"> </a><p>Transfer the contents of X register into the stack pointer
				(Note: needs RS to keep compatibility with 6502)
			</p>
<table class="optable"><tr><th colspan="10">TXS</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x9a</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the X register to the stack pointer.
				</p><pre>
					S &lt;= X
				</pre><h2>TXY</h2>
<a name="TXY"> </a><p>Transfer the contents of X into the Y register</p>
<table class="optable"><tr><th colspan="10">TXY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x9b</td><td>816</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the X to the Y register
				</p><pre>
					Y &lt;= X
				</pre><h2>TYA</h2>
<a name="TYA"> </a><p>Transfer the contents of the Y register into the accumulator
			</p>
<table class="optable"><tr><th colspan="10">TYA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x98</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the Y register to the accumulator
				</p><pre>
					A &lt;= Y
				</pre><h2>TYX</h2>
<a name="TYX"> </a><p>Transfer the contents of Y into the X register</p>
<table class="optable"><tr><th colspan="10">TYX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xbb</td><td>816</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the Y to the X register
				</p><pre>
					X &lt;= Y
				</pre><h2>XBA</h2>
<a name="XBA"> </a><p>Exchange A and B 8-bit accumulators (i.e. both halfs of the 16 bit AC)</p>
<table class="optable"><tr><th colspan="10">XBA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xeb</td><td>816</td><td>Implied</td><td></td><td></td></tr>
</table>
<h2>LDA</h2>
<a name="LDA"> </a><p>Load accumulator</p>
<table class="optable"><tr><th colspan="10">LDA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xa1</td><td></td><td>Zeropage indexed with X indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0xa5</td><td></td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0xa9</td><td></td><td>Immediate</td><td></td><td></td></tr>
<tr><td></td><td>0xad</td><td></td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0xb1</td><td></td><td>Zeropage indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0xb2</td><td>cmos_ind</td><td>Zeropage indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0xb5</td><td></td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0xb9</td><td></td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0xbd</td><td></td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0xa3</td><td>816</td><td>Stack-relative with offset</td><td></td><td></td></tr>
<tr><td></td><td>0xb3</td><td>816</td><td>Stack Vector indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0xaf</td><td>816</td><td>Absolute 24bit</td><td></td><td></td></tr>
<tr><td></td><td>0xbf</td><td>816</td><td>Absolute 24bit indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0xa7</td><td>816</td><td>Absolute indirect 24bit</td><td></td><td></td></tr>
<tr><td></td><td>0xb7</td><td>816</td><td>Absolute indirect 24bit indexed with Y</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Read the operand and store it in the Accumulator. Set the flags
					appropriately.
				</p><pre>
					N &lt;= Operand(7)
					Z &lt;= Z(Operand)
					Y &lt;= Operand
				</pre><h2>LDX</h2>
<a name="LDX"> </a><p>Load X register</p>
<table class="optable"><tr><th colspan="10">LDX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xa2</td><td></td><td>Immediate</td><td></td><td></td></tr>
<tr><td></td><td>0xa6</td><td></td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0xae</td><td></td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0xb6</td><td></td><td>Zeropage indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0xbe</td><td></td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Read the operand and store it in the X register. Set the flags
					appropriately.
				</p><pre>
					N &lt;= Operand(7)
					Z &lt;= Z(Operand)
					X &lt;= Operand
				</pre><h2>LDY</h2>
<a name="LDY"> </a><p>Load Y register</p>
<table class="optable"><tr><th colspan="10">LDY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xa0</td><td></td><td>Immediate</td><td></td><td></td></tr>
<tr><td></td><td>0xa4</td><td></td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0xac</td><td></td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0xb4</td><td></td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0xbc</td><td></td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Read the operand and store it in the Y register. Set the flags
					appropriately.
				</p><pre>
					N &lt;= Operand(7)
					Z &lt;= Z(Operand)
					Y &lt;= Operand
				</pre><h2>MVN</h2>
<a name="MVN"> </a><p>Move block of data (count index down) 
			</p>
<table class="optable"><tr><th colspan="10">MVN</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x54</td><td>816</td><td>Double Immediate</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
				 x=source address, y=destination address, ac=number of bytes; the two immediate parameters
				 are the destination and source data bank numbers respectively.
				</p><h2>MVP</h2>
<a name="MVP"> </a><p>Move block of data (count index up)
			</p>
<table class="optable"><tr><th colspan="10">MVP</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x44</td><td>816</td><td>Double Immediate</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
				 x=source address, y=destination address, ac=number of bytes; the two immediate parameters
				 are the destination and source data bank numbers respectively.
				</p><h2>PEA</h2>
<a name="PEA"> </a><p>Push effective address (16 bit)</p>
<table class="optable"><tr><th colspan="10">PEA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xf4</td><td>816</td><td>Immediate 16bit</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Push the immediate value from the operand onto the stack (as 16 bit value).
				</p><pre>
					Stack(SP--) &lt;= operand
				</pre><h2>PEI</h2>
<a name="PEI"> </a><p>Push effective indirect address (16 bit)</p>
<table class="optable"><tr><th colspan="10">PEI</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xd4</td><td>816</td><td>Zeropage</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Push the address to the stack that would result as effective operand address if the operand were used in an indirect
					addressing mode. I.e. read the value at the given direct page operand, and push it onto the stack (as 16 bit value).
				</p><pre>
					Stack(SP--) &lt;= (operand)
				</pre><h2>PER</h2>
<a name="PER"> </a><p>Push effective relative address (16 bit)</p>
<table class="optable"><tr><th colspan="10">PER</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x62</td><td>816ce02</td><td>Relative 16bit</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Take the address given as parameter, add the current program counter, and push the resulting
					address onto the stack (as 16 bit value). This is similar to pushing the offset of a branch instruction.
				</p><pre>
					Stack(SP--) &lt;= operand - PC + 1
				</pre><h2>PHA</h2>
<a name="PHA"> </a><p>Push contents of the accumulator onto the stack</p>
<table class="optable"><tr><th colspan="10">PHA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x48</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Push the content of the accumulator on the stack.
				</p><pre>
					Stack(SP--) &lt;= A
				</pre><h2>PHB</h2>
<a name="PHB"> </a><p>Push data bank register DBR to stack</p>
<table class="optable"><tr><th colspan="10">PHB</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x8b</td><td>816</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Push the value of the data bank register register to the stack.
				</p><pre>
					Stack(SP--) &lt;= DBR
				</pre><h2>PHD</h2>
<a name="PHD"> </a><p>Push direct page register to stack</p>
<table class="optable"><tr><th colspan="10">PHD</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x0b</td><td>816</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Push the value of the direct page register register to the stack.
				</p><pre>
					Stack(SP--) &lt;= DPR
				</pre><h2>PHK</h2>
<a name="PHK"> </a><p>Push program bank register to stack</p>
<table class="optable"><tr><th colspan="10">PHK</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x4b</td><td>816</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Push the value of the program bank register register to the stack.
				</p><pre>
					Stack(SP--) &lt;= PBR
				</pre><h2>PHP</h2>
<a name="PHP"> </a><p>Push processor status register onto the stack</p>
<table class="optable"><tr><th colspan="10">PHP</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x08</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Push the standard status register on the stack.
				</p><pre>
					Stack(SP--) &lt;= Status
				</pre><h2>PHX</h2>
<a name="PHX"> </a><p>Push contents of the X register onto the stack</p>
<table class="optable"><tr><th colspan="10">PHX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xda</td><td>cmos</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Push the content of the X register on the stack.
				</p><pre>
					Stack(SP--) &lt;= X
				</pre><h2>PHY</h2>
<a name="PHY"> </a><p>Push contents of the Y register onto the stack</p>
<table class="optable"><tr><th colspan="10">PHY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x5a</td><td>cmos</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Push the content of the Y register on the stack.
				</p><pre>
					Stack(SP--) &lt;= Y
				</pre><h2>PLA</h2>
<a name="PLA"> </a><p>Pull the contents of the accumulator from the stack</p>
<table class="optable"><tr><th colspan="10">PLA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x68</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Pull the value of the accumulator from the stack.
				</p><pre>
					A &lt;= Stack(++SP)
				</pre><h2>PLB</h2>
<a name="PLB"> </a><p>Pull data bank register DBR from stack</p>
<table class="optable"><tr><th colspan="10">PLB</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xab</td><td>816</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Pull the value of the data bank register register from the stack.
				</p><pre>
					DBR &lt;= Stack(++SP)
				</pre><h2>PLD</h2>
<a name="PLD"> </a><p>Pull direct page register from stack</p>
<table class="optable"><tr><th colspan="10">PLD</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x2b</td><td>816</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Pull the value of the direct page register register from the stack.
				</p><pre>
					DPR &lt;= Stack(++SP)
				</pre><h2>PLP</h2>
<a name="PLP"> </a><p>Pull processor status register from the stack</p>
<table class="optable"><tr><th colspan="10">PLP</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x28</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Pull the standard status register on the stack.
				</p><pre>
					Status &lt;= Stack(++SP)
				</pre><h2>PLX</h2>
<a name="PLX"> </a><p>Pull the contents of the X register from the stack</p>
<table class="optable"><tr><th colspan="10">PLX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xfa</td><td>cmos</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Pull the value of the X register from the stack.
				</p><pre>
					X &lt;= Stack(++SP)
				</pre><h2>PLY</h2>
<a name="PLY"> </a><p>Pull the contents of the Y register from the stack</p>
<table class="optable"><tr><th colspan="10">PLY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x7a</td><td>cmos</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Pull the value of the Y register from the stack.
				</p><pre>
					Y &lt;= Stack(++SP)
				</pre><h2>STA</h2>
<a name="STA"> </a><p>Store the content of the accumulator into a memory location
			</p>
<table class="optable"><tr><th colspan="10">STA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x81</td><td></td><td>Zeropage indexed with X indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x85</td><td></td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x8d</td><td></td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x91</td><td></td><td>Zeropage indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x92</td><td>cmos_ind</td><td>Zeropage indirect 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x95</td><td></td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x99</td><td></td><td>Absolute 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x9d</td><td></td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x83</td><td>816</td><td>Stack-relative with offset</td><td></td><td></td></tr>
<tr><td></td><td>0x93</td><td>816</td><td>Stack Vector indirect 16bit indexed with Y</td><td></td><td></td></tr>
<tr><td></td><td>0x8f</td><td>816</td><td>Absolute 24bit</td><td></td><td></td></tr>
<tr><td></td><td>0x9f</td><td>816</td><td>Absolute 24bit indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x87</td><td>816</td><td>Absolute indirect 24bit</td><td></td><td></td></tr>
<tr><td></td><td>0x97</td><td>816</td><td>Absolute indirect 24bit indexed with Y</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Store the accumulator into the address given by the operand.
				</p><pre>
					Operand &lt;= A
				</pre><h2>STX</h2>
<a name="STX"> </a><p>Store the content of the X register to memory.</p>
<table class="optable"><tr><th colspan="10">STX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x86</td><td></td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x8e</td><td></td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x96</td><td></td><td>Zeropage indexed with Y</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Store the content of the X register into the address given by the
					operand.
				</p><pre>
					Operand &lt;= A
				</pre><h2>STY</h2>
<a name="STY"> </a><p>Store the content of the Y register to memory.</p>
<table class="optable"><tr><th colspan="10">STY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x84</td><td></td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x8c</td><td></td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x94</td><td></td><td>Zeropage indexed with X</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Store the content of the Y register into the address given by the
					operand.
				</p><pre>
					Operand &lt;= A
				</pre><h2>STZ</h2>
<a name="STZ"> </a><p>Store zero into a memory location</p>
<table class="optable"><tr><th colspan="10">STZ</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x64</td><td>cmos</td><td>Zeropage</td><td></td><td></td></tr>
<tr><td></td><td>0x74</td><td>cmos</td><td>Zeropage indexed with X</td><td></td><td></td></tr>
<tr><td></td><td>0x9c</td><td>cmos</td><td>Absolute 16bit</td><td></td><td></td></tr>
<tr><td></td><td>0x9e</td><td>cmos</td><td>Absolute 16bit indexed with X</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Store zero into the address given by the operand.
				</p><pre>
					Operand &lt;= 0
				</pre><h2>TAX</h2>
<a name="TAX"> </a><p>Transfer the contents of accumulator into the X register</p>
<table class="optable"><tr><th colspan="10">TAX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xaa</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the accumulator to the X register
				</p><pre>
					X &lt;= A
				</pre><h2>TAY</h2>
<a name="TAY"> </a><p>Transfer the contents of accumulator into the Y register</p>
<table class="optable"><tr><th colspan="10">TAY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xa8</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the accumulator to the Y register
				</p><pre>
					Y &lt;= A
				</pre><h2>TCD</h2>
<a name="TCD"> </a><p>Transfer the contents of the 16-bit AC into the 16-bit direct page register</p>
<table class="optable"><tr><th colspan="10">TCD</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x5b</td><td>816</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the A to the DPR register (16 bit)
				</p><pre>
					DPR &lt;= A
				</pre><h2>TCS</h2>
<a name="TCS"> </a><p>Transfer the contents of 16-bit AC into the 16-bit stack pointer</p>
<table class="optable"><tr><th colspan="10">TCS</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x1b</td><td>816</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the A to the S register (16 bit)
				</p><pre>
					S &lt;= A
				</pre><h2>TDC</h2>
<a name="TDC"> </a><p>Transfer the contents of direct page register into the 16-bit AC</p>
<table class="optable"><tr><th colspan="10">TDC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x7b</td><td>816</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the DPR to the A register (16 bit)
				</p><pre>
					A &lt;= DPR
				</pre><h2>TSC</h2>
<a name="TSC"> </a><p>Transfer the contents of 16-bit stack pointer into the 16-bit AC</p>
<table class="optable"><tr><th colspan="10">TSC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x3b</td><td>816</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the S to the A register (16 bit)
				</p><pre>
					A &lt;= S
				</pre><h2>TSX</h2>
<a name="TSX"> </a><p>Transfer the contents of the stack pointer into the X register
				(Note: needs RS to keep compatibility with 6502)
			</p>
<table class="optable"><tr><th colspan="10">TSX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xba</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the stack pointer to the X register
				</p><pre>
					X &lt;= S
				</pre><h2>TXA</h2>
<a name="TXA"> </a><p>Transfer the contents of the X register into the accumulator
			</p>
<table class="optable"><tr><th colspan="10">TXA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x8a</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the X register to the accumulator
				</p><pre>
					A &lt;= X
				</pre><h2>TXS</h2>
<a name="TXS"> </a><p>Transfer the contents of X register into the stack pointer
				(Note: needs RS to keep compatibility with 6502)
			</p>
<table class="optable"><tr><th colspan="10">TXS</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x9a</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the X register to the stack pointer.
				</p><pre>
					S &lt;= X
				</pre><h2>TXY</h2>
<a name="TXY"> </a><p>Transfer the contents of X into the Y register</p>
<table class="optable"><tr><th colspan="10">TXY</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x9b</td><td>816</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the X to the Y register
				</p><pre>
					Y &lt;= X
				</pre><h2>TYA</h2>
<a name="TYA"> </a><p>Transfer the contents of the Y register into the accumulator
			</p>
<table class="optable"><tr><th colspan="10">TYA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x98</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the Y register to the accumulator
				</p><pre>
					A &lt;= Y
				</pre><h2>TYX</h2>
<a name="TYX"> </a><p>Transfer the contents of Y into the X register</p>
<table class="optable"><tr><th colspan="10">TYX</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xbb</td><td>816</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Transfer the value of the Y to the X register
				</p><pre>
					X &lt;= Y
				</pre><h2>XBA</h2>
<a name="XBA"> </a><p>Exchange A and B 8-bit accumulators (i.e. both halfs of the 16 bit AC)</p>
<table class="optable"><tr><th colspan="10">XBA</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xeb</td><td>816</td><td>Implied</td><td></td><td></td></tr>
</table>
<h2>CLC</h2>
<a name="CLC"> </a><p>Clear the C flag</p>
<table class="optable"><tr><th colspan="10">CLC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x18</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Clear the carry status flag.
				</p><h2>CLD</h2>
<a name="CLD"> </a><p>Clear the decimal (D) flag</p>
<table class="optable"><tr><th colspan="10">CLD</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xd8</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Clear the decimal mode status flag.
				</p><h2>CLI</h2>
<a name="CLI"> </a><p>Clear the interrupt (I) flag</p>
<table class="optable"><tr><th colspan="10">CLI</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x58</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Clear the interrupt status flag.
				</p><h2>CLV</h2>
<a name="CLV"> </a><p>Clear the overflow (V) flag</p>
<table class="optable"><tr><th colspan="10">CLV</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xb8</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Clear the overflow status flag.
				</p><h2>REP</h2>
<a name="REP"> </a><p>Reset processor status bits</p>
<table class="optable"><tr><th colspan="10">REP</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xc2</td><td>816</td><td>Immediate</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Reset the processor status bits that are set in the immediate operand (all flags but the B-flag)
				</p><h2>SEC</h2>
<a name="SEC"> </a><p>Set the C flag</p>
<table class="optable"><tr><th colspan="10">SEC</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x38</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Set the carry status flag.
				</p><h2>SED</h2>
<a name="SED"> </a><p>Set the decimal (D) flag</p>
<table class="optable"><tr><th colspan="10">SED</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xf8</td><td>bcd</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Set the decimal mode status flag.
				</p><h2>SEI</h2>
<a name="SEI"> </a><p>Set the interrupt (I) flag</p>
<table class="optable"><tr><th colspan="10">SEI</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x78</td><td></td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Set the interrupt status flag.
				</p><h2>SEP</h2>
<a name="SEP"> </a><p>Set processor status bits</p>
<table class="optable"><tr><th colspan="10">SEP</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xe2</td><td>816</td><td>Immediate</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Set the processor status bits that are set in the immediate operand (all flags but the B-flag)
				</p><h2>XCE</h2>
<a name="XCE"> </a><p>Exchange Carry and Emulation Flags</p>
<table class="optable"><tr><th colspan="10">XCE</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xfb</td><td>816</td><td>Implied</td><td></td><td></td></tr>
</table>
<h2>COP</h2>
<a name="COP"> </a><p>Coprocessor call</p>
<table class="optable"><tr><th colspan="10">COP</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x02</td><td>816</td><td>Immediate</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					The COP instruction pushes the K register (i.e. the program bank register) onto the stack (in native mode only),
					then the 16 bit address of the COP instruction plus 2, then the status register. The COP instruction is very 
					similar to the BRK instruction.
				</p><h2>STP</h2>
<a name="STP"> </a><p>Stop processor</p>
<table class="optable"><tr><th colspan="10">STP</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xdb</td><td>816</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Stop the processor.
				</p><h2>WAI</h2>
<a name="WAI"> </a><p>Wait for interrupt</p>
<table class="optable"><tr><th colspan="10">WAI</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0xcb</td><td>816</td><td>Implied</td><td></td><td></td></tr>
</table>
<h3>Description</h3>
<p>
					Stop the processor and wait for an interrupt, where execution resumes.
				</p><h2>WDM</h2>
<a name="WDM"> </a><p>Reserved for future expansion</p>
<table class="optable"><tr><th colspan="10">WDM</th></tr>
<tr><th>Page</th><th>Opcode</th><th>Class</th><th>Addressing Mode</th><th>Bit/Offset/Num</th></tr>
<tr><td></td><td>0x42</td><td>816</td><td>Implied</td><td></td><td></td></tr>
</table>
