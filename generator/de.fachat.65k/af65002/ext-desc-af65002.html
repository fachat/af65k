<ul>
<li>
<a href="af65002opdesc.html#ADC">ADC: </a>
Add content of memory location to accumulator</li>
<li>
<a href="af65002opdesc.html#ADD">ADD: </a>
Add content of memory location to accumulator without using
				carry as input
			</li>
<li>
<a href="af65002opdesc.html#ADE">ADE: </a>
Add value to E register</li>
<li>
<a href="af65002opdesc.html#ADI">ADI: </a>
Add immediate value to a memory location</li>
<li>
<a href="af65002opdesc.html#ADQ">ADQ: </a>
Add immediate value to a register</li>
<li>
<a href="af65002opdesc.html#AND">AND: </a>
Bitwise AND accumulator with content of memory location</li>
<li>
<a href="af65002opdesc.html#ASL">ASL: </a>
Arithmetic Shift Left - shift accumulator one bit to the left,
				shifting in zero in bit 0
			</li>
<li>
<a href="af65002opdesc.html#ASR">ASR: </a>
Arithmetic Shift Right - Similar to LSR, but shifts in the sign
				of the value, not zero
			</li>
<li>
<a href="af65002opdesc.html#BCN">BCN: </a>
Bit Count: counts 1-bits in AC or in given location, stores
				number of 1-bits back in AC
			</li>
<li>
<a href="af65002opdesc.html#BEV">BEV: </a>
Branch on even</li>
<li>
<a href="af65002opdesc.html#BGES">BGES: </a>
Branch on signed greater or equal than</li>
<li>
<a href="af65002opdesc.html#BIT">BIT: </a>
Bitwise test with accumulator - AND the memory location with
				the
				accumulator, and set N (=bit 7), V (=bit 7), Z
				(iff all bits
				zero) flags from the result. In case of the accumulator addressing,
				simply
				set the flags from the
				accumulator
			</li>
<li>
<a href="af65002opdesc.html#BLE">BLE: </a>
Branch if less or equal - take branch when C flag is clear or Z
				flag is set
			</li>
<li>
<a href="af65002opdesc.html#BLES">BLES: </a>
Branch if less or equal - take branch when signed greater or
				equal flag G is clear or Z flag is set
			</li>
<li>
<a href="af65002opdesc.html#BLTS">BLTS: </a>
Branch on signed less than</li>
<li>
<a href="af65002opdesc.html#BOD">BOD: </a>
Branch on odd</li>
<li>
<a href="af65002opdesc.html#BSW">BSW: </a>
Bit Swap: exchanges bit 0 with bit W-1, bit 1 with bit W-2 and
				so on.
			</li>
<li>
<a href="af65002opdesc.html#CMP">CMP: </a>
Compare accumulator with content of memory location</li>
<li>
<a href="af65002opdesc.html#CPX">CPX: </a>
Compare X register with content of memory location</li>
<li>
<a href="af65002opdesc.html#CPY">CPY: </a>
Compare Y register with content of memory location</li>
<li>
<a href="af65002opdesc.html#CPZ">CPZ: </a>
Compare Z register with content of memory location</li>
<li>
<a href="af65002opdesc.html#CSW">CSW: </a>
Compare and SWap - compare memory with AC, and if matches, set to value from XR. AC is loaded with the value from the memory location.
			</li>
<li>
<a href="af65002opdesc.html#DAD">DAD: </a>
Decimal adjust of a normal ADC of two BCD numbers.</li>
<li>
<a href="af65002opdesc.html#DAS">DAS: </a>
Decimal adjust of a normal SBC of two BCD numbers.</li>
<li>
<a href="af65002opdesc.html#DEC">DEC: </a>
Decrement the content of a memory location by one</li>
<li>
<a href="af65002opdesc.html#DEZ">DEZ: </a>
Decrement Z register</li>
<li>
<a href="af65002opdesc.html#EOR">EOR: </a>
Bitwise Exclusive-OR accumulator with content of memory
				location
			</li>
<li>
<a href="af65002opdesc.html#EXT">EXT: </a>
Extend a value in AC from RS to the full size. Setting LE
				defines the type of extension.
			</li>
<li>
<a href="af65002opdesc.html#INC">INC: </a>
Increment the content of a memory location by one</li>
<li>
<a href="af65002opdesc.html#INV">INV: </a>
Invert AC, i.e. set AC to the 1s-complement of AC</li>
<li>
<a href="af65002opdesc.html#INZ">INZ: </a>
Increment Z register</li>
<li>
<a href="af65002opdesc.html#JMP">JMP: </a>
Jump to new code address</li>
<li>
<a href="af65002opdesc.html#JSR">JSR: </a>
Jump subroutine - jump to a new code location, save return
				address on stack for RTS
			</li>
<li>
<a href="af65002opdesc.html#LDA">LDA: </a>
Load accumulator</li>
<li>
<a href="af65002opdesc.html#LDB">LDB: </a>
Load B with an immediate value</li>
<li>
<a href="af65002opdesc.html#LDE">LDE: </a>
Load E with an immediate value</li>
<li>
<a href="af65002opdesc.html#LDX">LDX: </a>
Load X register</li>
<li>
<a href="af65002opdesc.html#LDY">LDY: </a>
Load Y register</li>
<li>
<a href="af65002opdesc.html#LDZ">LDZ: </a>
Load Z register with a value</li>
<li>
<a href="af65002opdesc.html#LEA">LEA: </a>
Load Effective Address: compute the effective address and store
				it in the E (effective Address) register (always
				full width)
			</li>
<li>
<a href="af65002opdesc.html#LSR">LSR: </a>
Logical Shift Right - shift accumulator one bit to the right,
				shifting in zero in the highest bit
			</li>
<li>
<a href="af65002opdesc.html#NEG">NEG: </a>
negate AC, i.e. set AC to the 2s-complement of AC</li>
<li>
<a href="af65002opdesc.html#ORA">ORA: </a>
Bitwise OR accumulator with content of memory location</li>
<li>
<a href="af65002opdesc.html#PHB">PHB: </a>
Push B onto stack (full width)</li>
<li>
<a href="af65002opdesc.html#PHE">PHE: </a>
Push E onto stack (always full width)</li>
<li>
<a href="af65002opdesc.html#PHI">PHI: </a>
Push immediate value onto the stack</li>
<li>
<a href="af65002opdesc.html#PHM">PHM: </a>
Push contents of multiple registers onto the stack</li>
<li>
<a href="af65002opdesc.html#PHZ">PHZ: </a>
Push Z Register onto stack</li>
<li>
<a href="af65002opdesc.html#PLB">PLB: </a>
Pull B from stack (full width)</li>
<li>
<a href="af65002opdesc.html#PLE">PLE: </a>
Pull E from stack (full width)</li>
<li>
<a href="af65002opdesc.html#PLM">PLM: </a>
Pull contents of multiple registers from the stack</li>
<li>
<a href="af65002opdesc.html#PLZ">PLZ: </a>
Pull Z Register from stack</li>
<li>
<a href="af65002opdesc.html#PRB">PRB: </a>
Push and Replace Base register: Push base offset register to
				the
				stack, then transfer E-register to the base
				register
			</li>
<li>
<a href="af65002opdesc.html#RDL">RDL: </a>
Rotate Direct Left - similar to ROL, but do not shift in carry,
				but the highest bit of the original value
			</li>
<li>
<a href="af65002opdesc.html#RDR">RDR: </a>
Rotate Direct Right - similar to ROR, but do not shift in
				carry,
				but the lowest bit of the original value
			</li>
<li>
<a href="af65002opdesc.html#ROL">ROL: </a>
Rotate Left - shift accumulator one bit to the left, shifting
				in
				the carry flag in bit 0, and shifting the
				highest bit into the
				carry flag instead.
			</li>
<li>
<a href="af65002opdesc.html#ROR">ROR: </a>
Rotate Right - shift accumulator one bit to the right, shifting
				in the carry flag in the highest bit, and
				shifting
				bit 0 into the
				carry flag instead.
			</li>
<li>
<a href="af65002opdesc.html#SBC">SBC: </a>
Substract content of memory location from accumulator</li>
<li>
<a href="af65002opdesc.html#SBE">SBE: </a>
Subtract value from E register</li>
<li>
<a href="af65002opdesc.html#SBI">SBI: </a>
Subtract immediate value from a memory location</li>
<li>
<a href="af65002opdesc.html#SBQ">SBQ: </a>
Subtract immediate value from a register</li>
<li>
<a href="af65002opdesc.html#STA">STA: </a>
Store the content of the accumulator into a memory location
			</li>
<li>
<a href="af65002opdesc.html#STI">STI: </a>
Store immediate byte value into a memory location</li>
<li>
<a href="af65002opdesc.html#STX">STX: </a>
Store the content of the X register to memory.</li>
<li>
<a href="af65002opdesc.html#STY">STY: </a>
Store the content of the Y register to memory.</li>
<li>
<a href="af65002opdesc.html#STZ">STZ: </a>
Store zero (or Z-register) into a memory location</li>
<li>
<a href="af65002opdesc.html#SUB">SUB: </a>
Subtract content of memory location from accumulator without
				using the carry flag as input
			</li>
<li>
<a href="af65002opdesc.html#SWP">SWP: </a>
swap upper and lower half of the operand
			</li>
<li>
<a href="af65002opdesc.html#TAB">TAB: </a>
Transfer AC to B register</li>
<li>
<a href="af65002opdesc.html#TAZ">TAZ: </a>
Transfer AC to Z Register</li>
<li>
<a href="af65002opdesc.html#TEA">TEA: </a>
Transfer E register to Accumulator</li>
<li>
<a href="af65002opdesc.html#TEB">TEB: </a>
Transfer E to B register (full width)</li>
<li>
<a href="af65002opdesc.html#TPA">TPA: </a>
Transfer Program counter to Accumulator</li>
<li>
<a href="af65002opdesc.html#TRB">TRB: </a>
Test and Reset Bit - AND the memory location with the
				accumulator, and set the Z flag from the result, then
				CLEAR all bits
				in the
				memory location that are set in the accumulator.
			</li>
<li>
<a href="af65002opdesc.html#TSB">TSB: </a>
Test and Set Bit - AND the memory location with the
				accumulator,
				and set the Z flag from the result, then SET all
				bits in
				the
				memory location that are set in the accumulator.
			</li>
<li>
<a href="af65002opdesc.html#TSY">TSY: </a>
Transfer stack pointer to Y</li>
<li>
<a href="af65002opdesc.html#TYS">TYS: </a>
Transfer Y to stack pointer</li>
<li>
<a href="af65002opdesc.html#TZA">TZA: </a>
Transfer Z Register to AC</li>
<li>
<a href="af65002opdesc.html#XAB">XAB: </a>
eXchange A register with B register. Always done full width, no
				flags set.
			</li>
<li>
<a href="af65002opdesc.html#XAX">XAX: </a>
eXchange AC with X register. Always done full width, no flags set.
			</li>
<li>
<a href="af65002opdesc.html#XAY">XAY: </a>
eXchange AC with Y register. Always done full width, no flags set.
			</li>
<li>
<a href="af65002opdesc.html#XYX">XYX: </a>
eXchange X with Y register. Always done full width, no flags set.
			</li>
<li>
<a href="af65002opdesc.html#XZX">XZX: </a>
eXchange X with Z register. Always done full width, no flags set.
			</li>
</ul>
