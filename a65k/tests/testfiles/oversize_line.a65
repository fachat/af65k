/****************************************************************************    tokenizing a line    Copyright (C) 2015 Andre Fachat    This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.    This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.    You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.****************************************************************************/// this code simply tokenizes the input string given some simple basic rules.#include <ctype.h>#include <stdbool.h>#include "types.h"#include "mem.h"#include "err.h"#include "tokenizer.h"static type_t tokenizer_memtype = {	"tokenizer_r",	sizeof(tokenizer_r)};// initialize a tokenizer tokenizer_r *tokenizer_init(const char *line) {		tokenizer_r *tok = mem_alloc(&tokenizer_memtype);	tok->line = line;	tok->ptr = 0;	tok->len = 0;	tok->value = 0;	tok->type = T_INIT;	return tok;}static bool_t parse_base(tokenizer_r *tok, int ptr, int base) {	int limit = base - 10;	const char *line = tok->line;	signed char c = 0;	long value = 0;	while (line[ptr] != 0) {		if (isdigit(c = tok->line[ptr])) {			c &= 0x0f;			if (c > (base-1)) {				tok->value = E_TOK_DIGITRANGE;				tok->type = T_ERROR;				return false;			}			value = value * base + c;		} else 		if (base > 10) {			c = tolower(c) - 'a';					// c is char, which is unsigned, so no need to compare for <0			if (c < limit) {				value = value * base + c;			} else {				break;			}		} else {			break;		}		ptr++;	}	tok->value = value;	tok->len = ptr - tok->ptr;	if (tok->len == 0) {		// syntax error		tok->value = E_TOK_EMPTY;		tok->type = T_ERROR;		return false;	}	return true;}static inline bool_t parse_decimal(tokenizer_r *tok, int ptr) {	tok->type = T_DECIMAL_LITERAL;	return parse_base(tok, ptr, 10);}static inline bool_t parse_octal(tokenizer_r *tok, int ptr) {	tok->type = T_OCTAL_LITERAL;	return parse_base(tok, ptr, 8);}static inline bool_t parse_binary(tokenizer_r *tok, int ptr) {	tok->type = T_BINARY_LITERAL;	return parse_base(tok, ptr, 2);}static inline bool_t parse_hex(tokenizer_r *tok, int ptr) {	tok->type = T_HEX_LITERAL;	return parse_base(tok, ptr, 16);}static inline bool_t parse_string(tokenizer_r *tok, int ptr) {	const char *line = tok->line;	char delim = line[ptr];	tok->type = T_STRING_LITERAL;	ptr++;	tok->strptr = ptr;	while (isPrint(line[ptr])) {		if (line[ptr] == delim) {			break;		}		ptr++;	}	tok->strlen = ptr - tok->strptr;		if (line[ptr] == delim) {		ptr++;	} else 	if (line[ptr] != 0) {		// non-printable char ends string		tok->value = E_TOK_NONPRINT;		tok->type = T_ERROR;		return false;	}	tok->len = ptr - tok->ptr;	if (tok->strlen == 0) {		// empty string		tok->value = E_TOK_EMPTY;		tok->type = T_ERROR;		return false;	}	return true;}static inline bool_t parse_name(tokenizer_r *tok, int ptr) {	const char *line = tok->line;	tok->type = T_NAME;	while (isalnum(line[ptr]) || (line[ptr] == '_')) {		ptr++;	}	tok->len = ptr - tok->ptr;	return true;}static inline bool_t parse_token(tokenizer_r *tok, int ptr, int can_have_operator) {	const char *line = tok->line;	char c = line[ptr];	// default outcome	tok->value = c;	tok->type = T_TOKEN;	tok->len = 1;	switch(c) {	case '!':	case '@':	case '`':	case '(':	case ')':	case '#':	case '[':	case ']':	case '*':	case ',':	case '+':	case '-':	case '/':	case ':':	case '.':	case ';':		return true;	case '>':		if (can_have_operator) {			// check ">>", ">=", "><"			switch (line[ptr+1]) {			case '>':				tok->value = OP_SHIFTRIGHT;				tok->len++;				return true;			case '=':				tok->value = OP_LARGEROREQUAL;				tok->len++;				return true;			case '<':				tok->value = OP_NOTEQUAL;				tok->len++;				return true;			default:				// default				return true;			}		} else {			// ">" for high byte modifier or larger than			return true;		}	case '<':		if (can_have_operator) {			// check "<<", "<=", "<>"			switch (line[ptr+1]) {			case '<':				tok->value = OP_SHIFTLEFT;				tok->len++;				return true;			case '=':				tok->value = OP_LESSOREQUAL;				tok->len++;				return true;			case '>':				tok->value = OP_NOTEQUAL;				tok->len++;				return true;			default:				// default				return true;			}		} else {			// "<" for high byte modifier			return true;		}	case '=':		if (can_have_operator) {			// check "==", "=>", "=<"			switch (line[ptr+1]) {			case '<':				tok->value = OP_LESSOREQUAL;				tok->len++;				return true;			case '=':				tok->value = OP_EQUAL;				tok->len++;				return true;			case '>':				tok->value = OP_LARGEROREQUAL;				tok->len++;				return true;			default:				// default, assign				return true;			}		} else {			// '=' assign			return true;		}	case '&':		// check "&", "&&"		if (line[ptr+1] == '&') {			tok->value = OP_LOGICAND;			tok->len++;		} 		return true;	case '|':		// check "|", "||"		if (line[ptr+1] == '|') {			tok->value = OP_LOGICOR;			tok->len++;		} 		return true;	case '^':		// check "^", "^^"		if (line[ptr+1] == '^') {			tok->value = OP_LOGICXOR;			tok->len++;		} 		return true;	default:		tok->value = E_TOK_UNKNOWN;		tok->type = T_ERROR;		return false;	}	return true;}// set to next token; return true when there is a valid tokenbool_t tokenizer_next(tokenizer_r *tok) {	tok->value = 0;	// move behind last token	int ptr = tok->ptr + tok->len;	const char *line = tok->line;	// attempt to not have to store an extra operand/operator flag in the tokenizer		// or even have to pass it to this function as parameter...	bool_t can_have_operator = (tok->type == T_DECIMAL_LITERAL) 			|| (tok->type == T_OCTAL_LITERAL)			|| (tok->type == T_BINARY_LITERAL)			|| (tok->type == T_HEX_LITERAL)			|| (tok->type == T_TOKEN && line[ptr] == ')');	// skip whilespace	while (line[ptr] != 0 && isspace(line[ptr])) {		ptr++;	}	tok->ptr = ptr;	//printf("ptr=%d, c=%d\n", ptr, line[ptr]);	// are we done with the line yet?	if (line[ptr] == 0 || tok->type == T_END || tok->type == T_ERROR) {		tok->len = 0;		tok->type = T_END;		return false;	}	char c = line[ptr];	if (isdigit(c)) {		// handle octal (starting with '0'), hex (starting with '0x'), dec		if (c == '0') {			if (line[ptr+1] == 'x' || line[ptr+1] == 'X') {				// hex				ptr += 2;				tok->ptr = ptr;				return parse_hex(tok, ptr);			} else {				// octal				return parse_octal(tok, ptr);			}		} else {			// dec			return parse_decimal(tok, ptr);		}	} else	if ((!can_have_operator) && (c == '%')) {		// binary		ptr++;		tok->ptr = ptr;		return parse_binary(tok, ptr);	} else	if ((!can_have_operator) && (c == '$')) {		// hex		ptr++;		tok->ptr = ptr;		return parse_hex(tok, ptr);	} else	if ((!can_have_operator) && (c == '&')) {		// octal		ptr++;		tok->ptr = ptr;		return parse_octal(tok, ptr);	} else	if (c == '\'' || c == '"') {		// string literal		return parse_string(tok, ptr);	} else	if (isalpha(c) || c == '_') {		// name		return parse_name(tok, ptr);	} else	if (ispunct(c)) {		// any other token		return parse_token(tok, ptr, can_have_operator);	} else {		// non-printable - error		tok->value = E_TOK_UNKNOWN;		tok->type = T_ERROR;		return false;	}	}void tokenizer_free(tokenizer_r *tok) {		tok->line = NULL;	mem_free(tok);}/****************************************************************************    input file handling    Copyright (C) 2012 Andre Fachat    This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.    This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.    You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.****************************************************************************/#include <string.h>#include <strings.h>#include "log.h"#include "mem.h"#include "infiles.h"#include "linked_list.h"#define	PATH_SEPARATOR_CHAR 	'/'#define	PATH_SEPARATOR_STR 	"/"#define	INITIAL_BUFFER_SIZE	4096static type_t openfile_memtype = {	"openfile",	sizeof(openfile_t)};static openfile_t *current_file = NULL;static line_t line;// contains the stack of open files// with entries of openfile_t. Note that entries are not // deleted (freed) when the file is closed, as other parts// hold references to e.g. the file namestatic list_t *filestack;// list of input files as given by the command line (char*)static list_t *infiles;// iterator over the input filesstatic list_iterator_t *infile_iter;// list of include dirs to be used when finding an input file,// be it from the command line or from include statementsstatic list_t *incdirs;void infiles_init(void) {	infiles = linked_list_init();	infile_iter = NULL;	incdirs = linked_list_init();	filestack = linked_list_init();	current_file = NULL;}// add an include directory to the input file processingvoid infiles_includedir(const char *dirname) {	list_add(incdirs, (char*) dirname);}// register a top level input file void infiles_register(const char *filename) {	list_add(infiles, (char*) filename);}// combine the (optional) path and the name into a full file path,// allocating memory for it and copying it there.static char *alloc_fullpath(const char *path, const char *name) {		char *fp = NULL;	int len = strlen(name);	int plen = path == NULL ? 0 : strlen(path);	// two strings, path separator, and final zero byte	fp = mem_alloc_c(plen + 1 + len + 1, "fullpath");	fp[0] = '\0';	if (path != NULL) {		strcat(fp, path);		strcat(fp, PATH_SEPARATOR_STR);	}	strcat(fp, name);		return fp;}// low level open given single path. Return NULL on not foundstatic openfile_t *open_file(char *filepath) {	FILE *filep = fopen(filepath, "r");	if (filep != NULL) {		openfile_t *of = mem_alloc(&openfile_memtype);				of->buffer_size = INITIAL_BUFFER_SIZE;		of->buffer = mem_alloc_c(of->buffer_size, "openfile_buffer");		of->filep = filep;		of->current_line = 1;				// separate into file name and path		char *lastsep = rindex(filepath, PATH_SEPARATOR_CHAR);		if (lastsep == NULL) {			of->filename = mem_alloc_str(filepath);		} else {			of->filename = mem_alloc_str(lastsep+1);			*lastsep='\0';			of->filepath = mem_alloc_str(filepath);		}		mem_free(filepath);		return of;	} else {		// file not opened		log_errno("Could not open file: '%s'", filepath);		mem_free(filepath);		return NULL;	}}// open a file, checking all the include dirsstatic openfile_t *infile_open(const char *filename) {	// first try with current dir	char *fullpath = alloc_fullpath(current_file == NULL ? NULL : current_file->filepath, filename);	// opens file, frees fullpath, returns openfile struct or NULL	openfile_t *ofile = open_file(fullpath);	// not found, so try include dirs	if (ofile == NULL) {		list_iterator_t *iter = list_iterator(incdirs);		while (ofile == NULL && list_iterator_has_next(iter)) {			char *incpath = (char*) list_iterator_next(iter);			fullpath = alloc_fullpath(incpath, filename);			ofile = open_file(fullpath);		}		list_iterator_free(iter);	}	// still not found, so use current dir (if not yet checked if current_file is NULL)	if (ofile == NULL && current_file != NULL) {		fullpath = alloc_fullpath(NULL, filename);		ofile = open_file(fullpath);	}	return ofile;}void infiles_include(const char *filename) {	list_add(filestack, current_file);	current_file = infile_open(filename);}// low level close, also releases the allocated attributes (buffer)// but not the struct itself, as references to it can be held static void infiles_close(openfile_t *file) {	fclose(file->filep);	mem_free(file->buffer);	file->buffer = NULL;	if (current_file == file) {		current_file = NULL;	}}line_t *infiles_readline() {	if (infile_iter == NULL) {		infile_iter = list_iterator(infiles);	}	if (current_file != NULL && feof(current_file->filep)) {		// file completely read, close it		infiles_close(current_file);	}	// first check if we are in an include, and return to parent file	if (current_file == NULL) {		current_file = list_pop(filestack);	}	// we were not in an include, so try the next top level file		if (current_file == NULL) {		char *filename = list_iterator_next(infile_iter);		if (filename == NULL) {			// last input file done			// end of pass			return NULL;		}		current_file = infile_open(filename);		if (current_file == NULL) {			// could not open file			log_error("Could not open file from all include dirs: %s\n", filename);			return NULL;		}	}	char *buffer = current_file->buffer;	// current_file is not NULL	char *r = fgets(buffer, current_file->buffer_size, current_file->filep);	if (r == NULL) {		// EOF without chars, or error		if (ferror(current_file->filep)) {			log_error("Error on reading file %s\n", current_file->filename);			infiles_close(current_file);			return NULL;		}		// EOF without chars		// should not happen		log_warn("EOF for file %s without chars!\n", current_file->filename);		// fake return empty line		strcpy(current_file->buffer, "\n");	}	int len = strlen(buffer);	if (buffer[len-1] != '\n') {		if (len >= current_file->buffer_size) {			// buffer overflow			log_error("Line buffer overflow on line %d of file %s after %d bytes\n", 				current_file->current_line, current_file->filename, current_file->buffer_size);		}	} else {		// overwrite final newline		buffer[len-1] = 0;	}	line.file = current_file;	line.line = buffer;	line.lineno = current_file->current_line;	current_file->current_line++;	return &line;}